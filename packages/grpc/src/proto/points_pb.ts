// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file points.proto (package qdrant, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Value } from "./json_with_int_pb.js";
import { PayloadIndexParams } from "./collections_pb.js";

/**
 * @generated from enum qdrant.WriteOrderingType
 */
export enum WriteOrderingType {
  /**
   * Write operations may be reordered, works faster, default
   *
   * @generated from enum value: Weak = 0;
   */
  Weak = 0,

  /**
   * Write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change
   *
   * @generated from enum value: Medium = 1;
   */
  Medium = 1,

  /**
   * Write operations go through the permanent leader, consistent, but may be unavailable if leader is down
   *
   * @generated from enum value: Strong = 2;
   */
  Strong = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(WriteOrderingType)
proto3.util.setEnumType(WriteOrderingType, "qdrant.WriteOrderingType", [
  { no: 0, name: "Weak" },
  { no: 1, name: "Medium" },
  { no: 2, name: "Strong" },
]);

/**
 * @generated from enum qdrant.ReadConsistencyType
 */
export enum ReadConsistencyType {
  /**
   * Send request to all nodes and return points which are present on all of them
   *
   * @generated from enum value: All = 0;
   */
  All = 0,

  /**
   * Send requests to all nodes and return points which are present on majority of them
   *
   * @generated from enum value: Majority = 1;
   */
  Majority = 1,

  /**
   * Send requests to half + 1 nodes, return points which are present on all of them
   *
   * @generated from enum value: Quorum = 2;
   */
  Quorum = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ReadConsistencyType)
proto3.util.setEnumType(ReadConsistencyType, "qdrant.ReadConsistencyType", [
  { no: 0, name: "All" },
  { no: 1, name: "Majority" },
  { no: 2, name: "Quorum" },
]);

/**
 * @generated from enum qdrant.FieldType
 */
export enum FieldType {
  /**
   * @generated from enum value: FieldTypeKeyword = 0;
   */
  FieldTypeKeyword = 0,

  /**
   * @generated from enum value: FieldTypeInteger = 1;
   */
  FieldTypeInteger = 1,

  /**
   * @generated from enum value: FieldTypeFloat = 2;
   */
  FieldTypeFloat = 2,

  /**
   * @generated from enum value: FieldTypeGeo = 3;
   */
  FieldTypeGeo = 3,

  /**
   * @generated from enum value: FieldTypeText = 4;
   */
  FieldTypeText = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(FieldType)
proto3.util.setEnumType(FieldType, "qdrant.FieldType", [
  { no: 0, name: "FieldTypeKeyword" },
  { no: 1, name: "FieldTypeInteger" },
  { no: 2, name: "FieldTypeFloat" },
  { no: 3, name: "FieldTypeGeo" },
  { no: 4, name: "FieldTypeText" },
]);

/**
 * @generated from enum qdrant.UpdateStatus
 */
export enum UpdateStatus {
  /**
   * @generated from enum value: UnknownUpdateStatus = 0;
   */
  UnknownUpdateStatus = 0,

  /**
   * Update is received, but not processed yet
   *
   * @generated from enum value: Acknowledged = 1;
   */
  Acknowledged = 1,

  /**
   * Update is applied and ready for search
   *
   * @generated from enum value: Completed = 2;
   */
  Completed = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UpdateStatus)
proto3.util.setEnumType(UpdateStatus, "qdrant.UpdateStatus", [
  { no: 0, name: "UnknownUpdateStatus" },
  { no: 1, name: "Acknowledged" },
  { no: 2, name: "Completed" },
]);

/**
 * @generated from message qdrant.WriteOrdering
 */
export class WriteOrdering extends Message<WriteOrdering> {
  /**
   * Write ordering guarantees
   *
   * @generated from field: qdrant.WriteOrderingType type = 1;
   */
  type = WriteOrderingType.Weak;

  constructor(data?: PartialMessage<WriteOrdering>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.WriteOrdering";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(WriteOrderingType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteOrdering {
    return new WriteOrdering().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteOrdering {
    return new WriteOrdering().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteOrdering {
    return new WriteOrdering().fromJsonString(jsonString, options);
  }

  static equals(a: WriteOrdering | PlainMessage<WriteOrdering> | undefined, b: WriteOrdering | PlainMessage<WriteOrdering> | undefined): boolean {
    return proto3.util.equals(WriteOrdering, a, b);
  }
}

/**
 * @generated from message qdrant.ReadConsistency
 */
export class ReadConsistency extends Message<ReadConsistency> {
  /**
   * @generated from oneof qdrant.ReadConsistency.value
   */
  value: {
    /**
     * Common read consistency configurations
     *
     * @generated from field: qdrant.ReadConsistencyType type = 1;
     */
    value: ReadConsistencyType;
    case: "type";
  } | {
    /**
     * Send request to a specified number of nodes, and return points which are present on all of them
     *
     * @generated from field: uint64 factor = 2;
     */
    value: bigint;
    case: "factor";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReadConsistency>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ReadConsistency";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(ReadConsistencyType), oneof: "value" },
    { no: 2, name: "factor", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadConsistency {
    return new ReadConsistency().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadConsistency {
    return new ReadConsistency().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadConsistency {
    return new ReadConsistency().fromJsonString(jsonString, options);
  }

  static equals(a: ReadConsistency | PlainMessage<ReadConsistency> | undefined, b: ReadConsistency | PlainMessage<ReadConsistency> | undefined): boolean {
    return proto3.util.equals(ReadConsistency, a, b);
  }
}

/**
 * @generated from message qdrant.PointId
 */
export class PointId extends Message<PointId> {
  /**
   * @generated from oneof qdrant.PointId.point_id_options
   */
  pointIdOptions: {
    /**
     * Numerical ID of the point
     *
     * @generated from field: uint64 num = 1;
     */
    value: bigint;
    case: "num";
  } | {
    /**
     * UUID
     *
     * @generated from field: string uuid = 2;
     */
    value: string;
    case: "uuid";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PointId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PointId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "point_id_options" },
    { no: 2, name: "uuid", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "point_id_options" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointId {
    return new PointId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointId {
    return new PointId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointId {
    return new PointId().fromJsonString(jsonString, options);
  }

  static equals(a: PointId | PlainMessage<PointId> | undefined, b: PointId | PlainMessage<PointId> | undefined): boolean {
    return proto3.util.equals(PointId, a, b);
  }
}

/**
 * @generated from message qdrant.Vector
 */
export class Vector extends Message<Vector> {
  /**
   * @generated from field: repeated float data = 1;
   */
  data: number[] = [];

  constructor(data?: PartialMessage<Vector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.Vector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vector {
    return new Vector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vector {
    return new Vector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vector {
    return new Vector().fromJsonString(jsonString, options);
  }

  static equals(a: Vector | PlainMessage<Vector> | undefined, b: Vector | PlainMessage<Vector> | undefined): boolean {
    return proto3.util.equals(Vector, a, b);
  }
}

/**
 * @generated from message qdrant.UpsertPoints
 */
export class UpsertPoints extends Message<UpsertPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * @generated from field: repeated qdrant.PointStruct points = 3;
   */
  points: PointStruct[] = [];

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  constructor(data?: PartialMessage<UpsertPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.UpsertPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "points", kind: "message", T: PointStruct, repeated: true },
    { no: 4, name: "ordering", kind: "message", T: WriteOrdering, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpsertPoints {
    return new UpsertPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpsertPoints {
    return new UpsertPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpsertPoints {
    return new UpsertPoints().fromJsonString(jsonString, options);
  }

  static equals(a: UpsertPoints | PlainMessage<UpsertPoints> | undefined, b: UpsertPoints | PlainMessage<UpsertPoints> | undefined): boolean {
    return proto3.util.equals(UpsertPoints, a, b);
  }
}

/**
 * @generated from message qdrant.DeletePoints
 */
export class DeletePoints extends Message<DeletePoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 3;
   */
  points?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  constructor(data?: PartialMessage<DeletePoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.DeletePoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "points", kind: "message", T: PointsSelector },
    { no: 4, name: "ordering", kind: "message", T: WriteOrdering, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePoints {
    return new DeletePoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePoints {
    return new DeletePoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePoints {
    return new DeletePoints().fromJsonString(jsonString, options);
  }

  static equals(a: DeletePoints | PlainMessage<DeletePoints> | undefined, b: DeletePoints | PlainMessage<DeletePoints> | undefined): boolean {
    return proto3.util.equals(DeletePoints, a, b);
  }
}

/**
 * @generated from message qdrant.GetPoints
 */
export class GetPoints extends Message<GetPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * List of points to retrieve
   *
   * @generated from field: repeated qdrant.PointId ids = 2;
   */
  ids: PointId[] = [];

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 4;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 5;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 6;
   */
  readConsistency?: ReadConsistency;

  constructor(data?: PartialMessage<GetPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.GetPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ids", kind: "message", T: PointId, repeated: true },
    { no: 4, name: "with_payload", kind: "message", T: WithPayloadSelector },
    { no: 5, name: "with_vectors", kind: "message", T: WithVectorsSelector, opt: true },
    { no: 6, name: "read_consistency", kind: "message", T: ReadConsistency, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetPoints {
    return new GetPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetPoints {
    return new GetPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetPoints {
    return new GetPoints().fromJsonString(jsonString, options);
  }

  static equals(a: GetPoints | PlainMessage<GetPoints> | undefined, b: GetPoints | PlainMessage<GetPoints> | undefined): boolean {
    return proto3.util.equals(GetPoints, a, b);
  }
}

/**
 * @generated from message qdrant.SetPayloadPoints
 */
export class SetPayloadPoints extends Message<SetPayloadPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * New payload values
   *
   * @generated from field: map<string, qdrant.Value> payload = 3;
   */
  payload: { [key: string]: Value } = {};

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 5;
   */
  pointsSelector?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;

  constructor(data?: PartialMessage<SetPayloadPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.SetPayloadPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "payload", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
    { no: 5, name: "points_selector", kind: "message", T: PointsSelector, opt: true },
    { no: 6, name: "ordering", kind: "message", T: WriteOrdering, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetPayloadPoints {
    return new SetPayloadPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetPayloadPoints {
    return new SetPayloadPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetPayloadPoints {
    return new SetPayloadPoints().fromJsonString(jsonString, options);
  }

  static equals(a: SetPayloadPoints | PlainMessage<SetPayloadPoints> | undefined, b: SetPayloadPoints | PlainMessage<SetPayloadPoints> | undefined): boolean {
    return proto3.util.equals(SetPayloadPoints, a, b);
  }
}

/**
 * @generated from message qdrant.DeletePayloadPoints
 */
export class DeletePayloadPoints extends Message<DeletePayloadPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * List of keys to delete
   *
   * @generated from field: repeated string keys = 3;
   */
  keys: string[] = [];

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 5;
   */
  pointsSelector?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;

  constructor(data?: PartialMessage<DeletePayloadPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.DeletePayloadPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "keys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "points_selector", kind: "message", T: PointsSelector, opt: true },
    { no: 6, name: "ordering", kind: "message", T: WriteOrdering, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeletePayloadPoints {
    return new DeletePayloadPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeletePayloadPoints {
    return new DeletePayloadPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeletePayloadPoints {
    return new DeletePayloadPoints().fromJsonString(jsonString, options);
  }

  static equals(a: DeletePayloadPoints | PlainMessage<DeletePayloadPoints> | undefined, b: DeletePayloadPoints | PlainMessage<DeletePayloadPoints> | undefined): boolean {
    return proto3.util.equals(DeletePayloadPoints, a, b);
  }
}

/**
 * @generated from message qdrant.ClearPayloadPoints
 */
export class ClearPayloadPoints extends Message<ClearPayloadPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 3;
   */
  points?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  constructor(data?: PartialMessage<ClearPayloadPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ClearPayloadPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "points", kind: "message", T: PointsSelector },
    { no: 4, name: "ordering", kind: "message", T: WriteOrdering, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClearPayloadPoints {
    return new ClearPayloadPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClearPayloadPoints {
    return new ClearPayloadPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClearPayloadPoints {
    return new ClearPayloadPoints().fromJsonString(jsonString, options);
  }

  static equals(a: ClearPayloadPoints | PlainMessage<ClearPayloadPoints> | undefined, b: ClearPayloadPoints | PlainMessage<ClearPayloadPoints> | undefined): boolean {
    return proto3.util.equals(ClearPayloadPoints, a, b);
  }
}

/**
 * @generated from message qdrant.CreateFieldIndexCollection
 */
export class CreateFieldIndexCollection extends Message<CreateFieldIndexCollection> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Field name to index
   *
   * @generated from field: string field_name = 3;
   */
  fieldName = "";

  /**
   * Field type.
   *
   * @generated from field: optional qdrant.FieldType field_type = 4;
   */
  fieldType?: FieldType;

  /**
   * Payload index params.
   *
   * @generated from field: optional qdrant.PayloadIndexParams field_index_params = 5;
   */
  fieldIndexParams?: PayloadIndexParams;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;

  constructor(data?: PartialMessage<CreateFieldIndexCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CreateFieldIndexCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "field_type", kind: "enum", T: proto3.getEnumType(FieldType), opt: true },
    { no: 5, name: "field_index_params", kind: "message", T: PayloadIndexParams, opt: true },
    { no: 6, name: "ordering", kind: "message", T: WriteOrdering, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateFieldIndexCollection {
    return new CreateFieldIndexCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateFieldIndexCollection {
    return new CreateFieldIndexCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateFieldIndexCollection {
    return new CreateFieldIndexCollection().fromJsonString(jsonString, options);
  }

  static equals(a: CreateFieldIndexCollection | PlainMessage<CreateFieldIndexCollection> | undefined, b: CreateFieldIndexCollection | PlainMessage<CreateFieldIndexCollection> | undefined): boolean {
    return proto3.util.equals(CreateFieldIndexCollection, a, b);
  }
}

/**
 * @generated from message qdrant.DeleteFieldIndexCollection
 */
export class DeleteFieldIndexCollection extends Message<DeleteFieldIndexCollection> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Field name to delete
   *
   * @generated from field: string field_name = 3;
   */
  fieldName = "";

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  constructor(data?: PartialMessage<DeleteFieldIndexCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.DeleteFieldIndexCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "field_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ordering", kind: "message", T: WriteOrdering, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteFieldIndexCollection {
    return new DeleteFieldIndexCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteFieldIndexCollection {
    return new DeleteFieldIndexCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteFieldIndexCollection {
    return new DeleteFieldIndexCollection().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteFieldIndexCollection | PlainMessage<DeleteFieldIndexCollection> | undefined, b: DeleteFieldIndexCollection | PlainMessage<DeleteFieldIndexCollection> | undefined): boolean {
    return proto3.util.equals(DeleteFieldIndexCollection, a, b);
  }
}

/**
 * @generated from message qdrant.PayloadIncludeSelector
 */
export class PayloadIncludeSelector extends Message<PayloadIncludeSelector> {
  /**
   * List of payload keys to include into result
   *
   * @generated from field: repeated string fields = 1;
   */
  fields: string[] = [];

  constructor(data?: PartialMessage<PayloadIncludeSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PayloadIncludeSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadIncludeSelector {
    return new PayloadIncludeSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadIncludeSelector {
    return new PayloadIncludeSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadIncludeSelector {
    return new PayloadIncludeSelector().fromJsonString(jsonString, options);
  }

  static equals(a: PayloadIncludeSelector | PlainMessage<PayloadIncludeSelector> | undefined, b: PayloadIncludeSelector | PlainMessage<PayloadIncludeSelector> | undefined): boolean {
    return proto3.util.equals(PayloadIncludeSelector, a, b);
  }
}

/**
 * @generated from message qdrant.PayloadExcludeSelector
 */
export class PayloadExcludeSelector extends Message<PayloadExcludeSelector> {
  /**
   * List of payload keys to exclude from the result
   *
   * @generated from field: repeated string fields = 1;
   */
  fields: string[] = [];

  constructor(data?: PartialMessage<PayloadExcludeSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PayloadExcludeSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadExcludeSelector {
    return new PayloadExcludeSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadExcludeSelector {
    return new PayloadExcludeSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadExcludeSelector {
    return new PayloadExcludeSelector().fromJsonString(jsonString, options);
  }

  static equals(a: PayloadExcludeSelector | PlainMessage<PayloadExcludeSelector> | undefined, b: PayloadExcludeSelector | PlainMessage<PayloadExcludeSelector> | undefined): boolean {
    return proto3.util.equals(PayloadExcludeSelector, a, b);
  }
}

/**
 * @generated from message qdrant.WithPayloadSelector
 */
export class WithPayloadSelector extends Message<WithPayloadSelector> {
  /**
   * @generated from oneof qdrant.WithPayloadSelector.selector_options
   */
  selectorOptions: {
    /**
     * If `true` - return all payload, if `false` - none
     *
     * @generated from field: bool enable = 1;
     */
    value: boolean;
    case: "enable";
  } | {
    /**
     * @generated from field: qdrant.PayloadIncludeSelector include = 2;
     */
    value: PayloadIncludeSelector;
    case: "include";
  } | {
    /**
     * @generated from field: qdrant.PayloadExcludeSelector exclude = 3;
     */
    value: PayloadExcludeSelector;
    case: "exclude";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WithPayloadSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.WithPayloadSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enable", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "selector_options" },
    { no: 2, name: "include", kind: "message", T: PayloadIncludeSelector, oneof: "selector_options" },
    { no: 3, name: "exclude", kind: "message", T: PayloadExcludeSelector, oneof: "selector_options" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WithPayloadSelector {
    return new WithPayloadSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WithPayloadSelector {
    return new WithPayloadSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WithPayloadSelector {
    return new WithPayloadSelector().fromJsonString(jsonString, options);
  }

  static equals(a: WithPayloadSelector | PlainMessage<WithPayloadSelector> | undefined, b: WithPayloadSelector | PlainMessage<WithPayloadSelector> | undefined): boolean {
    return proto3.util.equals(WithPayloadSelector, a, b);
  }
}

/**
 * @generated from message qdrant.NamedVectors
 */
export class NamedVectors extends Message<NamedVectors> {
  /**
   * @generated from field: map<string, qdrant.Vector> vectors = 1;
   */
  vectors: { [key: string]: Vector } = {};

  constructor(data?: PartialMessage<NamedVectors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.NamedVectors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vectors", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Vector} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NamedVectors {
    return new NamedVectors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NamedVectors {
    return new NamedVectors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NamedVectors {
    return new NamedVectors().fromJsonString(jsonString, options);
  }

  static equals(a: NamedVectors | PlainMessage<NamedVectors> | undefined, b: NamedVectors | PlainMessage<NamedVectors> | undefined): boolean {
    return proto3.util.equals(NamedVectors, a, b);
  }
}

/**
 * @generated from message qdrant.Vectors
 */
export class Vectors extends Message<Vectors> {
  /**
   * @generated from oneof qdrant.Vectors.vectors_options
   */
  vectorsOptions: {
    /**
     * @generated from field: qdrant.Vector vector = 1;
     */
    value: Vector;
    case: "vector";
  } | {
    /**
     * @generated from field: qdrant.NamedVectors vectors = 2;
     */
    value: NamedVectors;
    case: "vectors";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Vectors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.Vectors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vector", kind: "message", T: Vector, oneof: "vectors_options" },
    { no: 2, name: "vectors", kind: "message", T: NamedVectors, oneof: "vectors_options" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Vectors {
    return new Vectors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Vectors {
    return new Vectors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Vectors {
    return new Vectors().fromJsonString(jsonString, options);
  }

  static equals(a: Vectors | PlainMessage<Vectors> | undefined, b: Vectors | PlainMessage<Vectors> | undefined): boolean {
    return proto3.util.equals(Vectors, a, b);
  }
}

/**
 * @generated from message qdrant.VectorsSelector
 */
export class VectorsSelector extends Message<VectorsSelector> {
  /**
   * List of vectors to include into result
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[] = [];

  constructor(data?: PartialMessage<VectorsSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.VectorsSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorsSelector {
    return new VectorsSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorsSelector {
    return new VectorsSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorsSelector {
    return new VectorsSelector().fromJsonString(jsonString, options);
  }

  static equals(a: VectorsSelector | PlainMessage<VectorsSelector> | undefined, b: VectorsSelector | PlainMessage<VectorsSelector> | undefined): boolean {
    return proto3.util.equals(VectorsSelector, a, b);
  }
}

/**
 * @generated from message qdrant.WithVectorsSelector
 */
export class WithVectorsSelector extends Message<WithVectorsSelector> {
  /**
   * @generated from oneof qdrant.WithVectorsSelector.selector_options
   */
  selectorOptions: {
    /**
     * If `true` - return all vectors, if `false` - none
     *
     * @generated from field: bool enable = 1;
     */
    value: boolean;
    case: "enable";
  } | {
    /**
     * List of payload keys to include into result
     *
     * @generated from field: qdrant.VectorsSelector include = 2;
     */
    value: VectorsSelector;
    case: "include";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WithVectorsSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.WithVectorsSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enable", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "selector_options" },
    { no: 2, name: "include", kind: "message", T: VectorsSelector, oneof: "selector_options" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WithVectorsSelector {
    return new WithVectorsSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WithVectorsSelector {
    return new WithVectorsSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WithVectorsSelector {
    return new WithVectorsSelector().fromJsonString(jsonString, options);
  }

  static equals(a: WithVectorsSelector | PlainMessage<WithVectorsSelector> | undefined, b: WithVectorsSelector | PlainMessage<WithVectorsSelector> | undefined): boolean {
    return proto3.util.equals(WithVectorsSelector, a, b);
  }
}

/**
 * @generated from message qdrant.QuantizationSearchParams
 */
export class QuantizationSearchParams extends Message<QuantizationSearchParams> {
  /**
   *
   * If set to true, search will ignore quantized vector data
   *
   * @generated from field: optional bool ignore = 1;
   */
  ignore?: boolean;

  /**
   *
   * If true, use original vectors to re-score top-k results. Default is true.
   *
   * @generated from field: optional bool rescore = 2;
   */
  rescore?: boolean;

  constructor(data?: PartialMessage<QuantizationSearchParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.QuantizationSearchParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ignore", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "rescore", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuantizationSearchParams {
    return new QuantizationSearchParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuantizationSearchParams {
    return new QuantizationSearchParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuantizationSearchParams {
    return new QuantizationSearchParams().fromJsonString(jsonString, options);
  }

  static equals(a: QuantizationSearchParams | PlainMessage<QuantizationSearchParams> | undefined, b: QuantizationSearchParams | PlainMessage<QuantizationSearchParams> | undefined): boolean {
    return proto3.util.equals(QuantizationSearchParams, a, b);
  }
}

/**
 * @generated from message qdrant.SearchParams
 */
export class SearchParams extends Message<SearchParams> {
  /**
   *
   * Params relevant to HNSW index. Size of the beam in a beam-search.
   * Larger the value - more accurate the result, more time required for search.
   *
   * @generated from field: optional uint64 hnsw_ef = 1;
   */
  hnswEf?: bigint;

  /**
   *
   * Search without approximation. If set to true, search may run long but with exact results.
   *
   * @generated from field: optional bool exact = 2;
   */
  exact?: boolean;

  /**
   *
   * If set to true, search will ignore quantized vector data
   *
   * @generated from field: optional qdrant.QuantizationSearchParams quantization = 3;
   */
  quantization?: QuantizationSearchParams;

  constructor(data?: PartialMessage<SearchParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.SearchParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hnsw_ef", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "exact", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "quantization", kind: "message", T: QuantizationSearchParams, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchParams {
    return new SearchParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchParams {
    return new SearchParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchParams {
    return new SearchParams().fromJsonString(jsonString, options);
  }

  static equals(a: SearchParams | PlainMessage<SearchParams> | undefined, b: SearchParams | PlainMessage<SearchParams> | undefined): boolean {
    return proto3.util.equals(SearchParams, a, b);
  }
}

/**
 * @generated from message qdrant.SearchPoints
 */
export class SearchPoints extends Message<SearchPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * vector
   *
   * @generated from field: repeated float vector = 2;
   */
  vector: number[] = [];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 4;
   */
  limit = protoInt64.zero;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 7;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 8;
   */
  scoreThreshold?: number;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 9;
   */
  offset?: bigint;

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 10;
   */
  vectorName?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 11;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  constructor(data?: PartialMessage<SearchPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.SearchPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "vector", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
    { no: 3, name: "filter", kind: "message", T: Filter },
    { no: 4, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "with_payload", kind: "message", T: WithPayloadSelector },
    { no: 7, name: "params", kind: "message", T: SearchParams },
    { no: 8, name: "score_threshold", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 9, name: "offset", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 10, name: "vector_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "with_vectors", kind: "message", T: WithVectorsSelector, opt: true },
    { no: 12, name: "read_consistency", kind: "message", T: ReadConsistency, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchPoints {
    return new SearchPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchPoints {
    return new SearchPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchPoints {
    return new SearchPoints().fromJsonString(jsonString, options);
  }

  static equals(a: SearchPoints | PlainMessage<SearchPoints> | undefined, b: SearchPoints | PlainMessage<SearchPoints> | undefined): boolean {
    return proto3.util.equals(SearchPoints, a, b);
  }
}

/**
 * @generated from message qdrant.SearchBatchPoints
 */
export class SearchBatchPoints extends Message<SearchBatchPoints> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * @generated from field: repeated qdrant.SearchPoints search_points = 2;
   */
  searchPoints: SearchPoints[] = [];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  constructor(data?: PartialMessage<SearchBatchPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.SearchBatchPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "search_points", kind: "message", T: SearchPoints, repeated: true },
    { no: 3, name: "read_consistency", kind: "message", T: ReadConsistency, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchBatchPoints {
    return new SearchBatchPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchBatchPoints {
    return new SearchBatchPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchBatchPoints {
    return new SearchBatchPoints().fromJsonString(jsonString, options);
  }

  static equals(a: SearchBatchPoints | PlainMessage<SearchBatchPoints> | undefined, b: SearchBatchPoints | PlainMessage<SearchBatchPoints> | undefined): boolean {
    return proto3.util.equals(SearchBatchPoints, a, b);
  }
}

/**
 * @generated from message qdrant.ScrollPoints
 */
export class ScrollPoints extends Message<ScrollPoints> {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * Start with this ID
   *
   * @generated from field: optional qdrant.PointId offset = 3;
   */
  offset?: PointId;

  /**
   * Max number of result
   *
   * @generated from field: optional uint32 limit = 4;
   */
  limit?: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 7;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 8;
   */
  readConsistency?: ReadConsistency;

  constructor(data?: PartialMessage<ScrollPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ScrollPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "filter", kind: "message", T: Filter },
    { no: 3, name: "offset", kind: "message", T: PointId, opt: true },
    { no: 4, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 6, name: "with_payload", kind: "message", T: WithPayloadSelector },
    { no: 7, name: "with_vectors", kind: "message", T: WithVectorsSelector, opt: true },
    { no: 8, name: "read_consistency", kind: "message", T: ReadConsistency, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScrollPoints {
    return new ScrollPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScrollPoints {
    return new ScrollPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScrollPoints {
    return new ScrollPoints().fromJsonString(jsonString, options);
  }

  static equals(a: ScrollPoints | PlainMessage<ScrollPoints> | undefined, b: ScrollPoints | PlainMessage<ScrollPoints> | undefined): boolean {
    return proto3.util.equals(ScrollPoints, a, b);
  }
}

/**
 * @generated from message qdrant.LookupLocation
 */
export class LookupLocation extends Message<LookupLocation> {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 2;
   */
  vectorName?: string;

  constructor(data?: PartialMessage<LookupLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.LookupLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "vector_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupLocation {
    return new LookupLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupLocation {
    return new LookupLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupLocation {
    return new LookupLocation().fromJsonString(jsonString, options);
  }

  static equals(a: LookupLocation | PlainMessage<LookupLocation> | undefined, b: LookupLocation | PlainMessage<LookupLocation> | undefined): boolean {
    return proto3.util.equals(LookupLocation, a, b);
  }
}

/**
 * @generated from message qdrant.RecommendPoints
 */
export class RecommendPoints extends Message<RecommendPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Look for vectors closest to those
   *
   * @generated from field: repeated qdrant.PointId positive = 2;
   */
  positive: PointId[] = [];

  /**
   * Try to avoid vectors like this
   *
   * @generated from field: repeated qdrant.PointId negative = 3;
   */
  negative: PointId[] = [];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 5;
   */
  limit = protoInt64.zero;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 7;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 8;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 9;
   */
  scoreThreshold?: number;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 10;
   */
  offset?: bigint;

  /**
   * Define which vector to use for recommendation, if not specified - default vector
   *
   * @generated from field: optional string using = 11;
   */
  using?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 12;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Name of the collection to use for points lookup, if not specified - use current collection
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 13;
   */
  lookupFrom?: LookupLocation;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
   */
  readConsistency?: ReadConsistency;

  constructor(data?: PartialMessage<RecommendPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RecommendPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "positive", kind: "message", T: PointId, repeated: true },
    { no: 3, name: "negative", kind: "message", T: PointId, repeated: true },
    { no: 4, name: "filter", kind: "message", T: Filter },
    { no: 5, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "with_payload", kind: "message", T: WithPayloadSelector },
    { no: 8, name: "params", kind: "message", T: SearchParams },
    { no: 9, name: "score_threshold", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 10, name: "offset", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 11, name: "using", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 12, name: "with_vectors", kind: "message", T: WithVectorsSelector, opt: true },
    { no: 13, name: "lookup_from", kind: "message", T: LookupLocation, opt: true },
    { no: 14, name: "read_consistency", kind: "message", T: ReadConsistency, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendPoints {
    return new RecommendPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendPoints {
    return new RecommendPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendPoints {
    return new RecommendPoints().fromJsonString(jsonString, options);
  }

  static equals(a: RecommendPoints | PlainMessage<RecommendPoints> | undefined, b: RecommendPoints | PlainMessage<RecommendPoints> | undefined): boolean {
    return proto3.util.equals(RecommendPoints, a, b);
  }
}

/**
 * @generated from message qdrant.RecommendBatchPoints
 */
export class RecommendBatchPoints extends Message<RecommendBatchPoints> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * @generated from field: repeated qdrant.RecommendPoints recommend_points = 2;
   */
  recommendPoints: RecommendPoints[] = [];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  constructor(data?: PartialMessage<RecommendBatchPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RecommendBatchPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "recommend_points", kind: "message", T: RecommendPoints, repeated: true },
    { no: 3, name: "read_consistency", kind: "message", T: ReadConsistency, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendBatchPoints {
    return new RecommendBatchPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendBatchPoints {
    return new RecommendBatchPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendBatchPoints {
    return new RecommendBatchPoints().fromJsonString(jsonString, options);
  }

  static equals(a: RecommendBatchPoints | PlainMessage<RecommendBatchPoints> | undefined, b: RecommendBatchPoints | PlainMessage<RecommendBatchPoints> | undefined): boolean {
    return proto3.util.equals(RecommendBatchPoints, a, b);
  }
}

/**
 * @generated from message qdrant.CountPoints
 */
export class CountPoints extends Message<CountPoints> {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * If `true` - return exact count, if `false` - return approximate count
   *
   * @generated from field: optional bool exact = 3;
   */
  exact?: boolean;

  constructor(data?: PartialMessage<CountPoints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CountPoints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "filter", kind: "message", T: Filter },
    { no: 3, name: "exact", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountPoints {
    return new CountPoints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountPoints {
    return new CountPoints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountPoints {
    return new CountPoints().fromJsonString(jsonString, options);
  }

  static equals(a: CountPoints | PlainMessage<CountPoints> | undefined, b: CountPoints | PlainMessage<CountPoints> | undefined): boolean {
    return proto3.util.equals(CountPoints, a, b);
  }
}

/**
 * @generated from message qdrant.PointsOperationResponse
 */
export class PointsOperationResponse extends Message<PointsOperationResponse> {
  /**
   * @generated from field: qdrant.UpdateResult result = 1;
   */
  result?: UpdateResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<PointsOperationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PointsOperationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: UpdateResult },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsOperationResponse {
    return new PointsOperationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsOperationResponse {
    return new PointsOperationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsOperationResponse {
    return new PointsOperationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PointsOperationResponse | PlainMessage<PointsOperationResponse> | undefined, b: PointsOperationResponse | PlainMessage<PointsOperationResponse> | undefined): boolean {
    return proto3.util.equals(PointsOperationResponse, a, b);
  }
}

/**
 * @generated from message qdrant.UpdateResult
 */
export class UpdateResult extends Message<UpdateResult> {
  /**
   * Number of operation
   *
   * @generated from field: uint64 operation_id = 1;
   */
  operationId = protoInt64.zero;

  /**
   * Operation status
   *
   * @generated from field: qdrant.UpdateStatus status = 2;
   */
  status = UpdateStatus.UnknownUpdateStatus;

  constructor(data?: PartialMessage<UpdateResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.UpdateResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(UpdateStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateResult {
    return new UpdateResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateResult {
    return new UpdateResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateResult {
    return new UpdateResult().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateResult | PlainMessage<UpdateResult> | undefined, b: UpdateResult | PlainMessage<UpdateResult> | undefined): boolean {
    return proto3.util.equals(UpdateResult, a, b);
  }
}

/**
 * @generated from message qdrant.ScoredPoint
 */
export class ScoredPoint extends Message<ScoredPoint> {
  /**
   * Point id
   *
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * Payload
   *
   * @generated from field: map<string, qdrant.Value> payload = 2;
   */
  payload: { [key: string]: Value } = {};

  /**
   * Similarity score
   *
   * @generated from field: float score = 3;
   */
  score = 0;

  /**
   * Last update operation applied to this point
   *
   * @generated from field: uint64 version = 5;
   */
  version = protoInt64.zero;

  /**
   * Vectors to search
   *
   * @generated from field: optional qdrant.Vectors vectors = 6;
   */
  vectors?: Vectors;

  constructor(data?: PartialMessage<ScoredPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ScoredPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: PointId },
    { no: 2, name: "payload", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
    { no: 3, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "version", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "vectors", kind: "message", T: Vectors, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScoredPoint {
    return new ScoredPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScoredPoint {
    return new ScoredPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScoredPoint {
    return new ScoredPoint().fromJsonString(jsonString, options);
  }

  static equals(a: ScoredPoint | PlainMessage<ScoredPoint> | undefined, b: ScoredPoint | PlainMessage<ScoredPoint> | undefined): boolean {
    return proto3.util.equals(ScoredPoint, a, b);
  }
}

/**
 * @generated from message qdrant.SearchResponse
 */
export class SearchResponse extends Message<SearchResponse> {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<SearchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.SearchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: ScoredPoint, repeated: true },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchResponse {
    return new SearchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchResponse {
    return new SearchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchResponse | PlainMessage<SearchResponse> | undefined, b: SearchResponse | PlainMessage<SearchResponse> | undefined): boolean {
    return proto3.util.equals(SearchResponse, a, b);
  }
}

/**
 * @generated from message qdrant.BatchResult
 */
export class BatchResult extends Message<BatchResult> {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[] = [];

  constructor(data?: PartialMessage<BatchResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.BatchResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: ScoredPoint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchResult {
    return new BatchResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchResult {
    return new BatchResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchResult {
    return new BatchResult().fromJsonString(jsonString, options);
  }

  static equals(a: BatchResult | PlainMessage<BatchResult> | undefined, b: BatchResult | PlainMessage<BatchResult> | undefined): boolean {
    return proto3.util.equals(BatchResult, a, b);
  }
}

/**
 * @generated from message qdrant.SearchBatchResponse
 */
export class SearchBatchResponse extends Message<SearchBatchResponse> {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<SearchBatchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.SearchBatchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: BatchResult, repeated: true },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchBatchResponse {
    return new SearchBatchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchBatchResponse {
    return new SearchBatchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchBatchResponse {
    return new SearchBatchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchBatchResponse | PlainMessage<SearchBatchResponse> | undefined, b: SearchBatchResponse | PlainMessage<SearchBatchResponse> | undefined): boolean {
    return proto3.util.equals(SearchBatchResponse, a, b);
  }
}

/**
 * @generated from message qdrant.CountResponse
 */
export class CountResponse extends Message<CountResponse> {
  /**
   * @generated from field: qdrant.CountResult result = 1;
   */
  result?: CountResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<CountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: CountResult },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountResponse {
    return new CountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountResponse {
    return new CountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountResponse {
    return new CountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CountResponse | PlainMessage<CountResponse> | undefined, b: CountResponse | PlainMessage<CountResponse> | undefined): boolean {
    return proto3.util.equals(CountResponse, a, b);
  }
}

/**
 * @generated from message qdrant.ScrollResponse
 */
export class ScrollResponse extends Message<ScrollResponse> {
  /**
   * Use this offset for the next query
   *
   * @generated from field: optional qdrant.PointId next_page_offset = 1;
   */
  nextPageOffset?: PointId;

  /**
   * @generated from field: repeated qdrant.RetrievedPoint result = 2;
   */
  result: RetrievedPoint[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 3;
   */
  time = 0;

  constructor(data?: PartialMessage<ScrollResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ScrollResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_page_offset", kind: "message", T: PointId, opt: true },
    { no: 2, name: "result", kind: "message", T: RetrievedPoint, repeated: true },
    { no: 3, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScrollResponse {
    return new ScrollResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScrollResponse {
    return new ScrollResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScrollResponse {
    return new ScrollResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ScrollResponse | PlainMessage<ScrollResponse> | undefined, b: ScrollResponse | PlainMessage<ScrollResponse> | undefined): boolean {
    return proto3.util.equals(ScrollResponse, a, b);
  }
}

/**
 * @generated from message qdrant.CountResult
 */
export class CountResult extends Message<CountResult> {
  /**
   * @generated from field: uint64 count = 1;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<CountResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CountResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountResult {
    return new CountResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountResult {
    return new CountResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountResult {
    return new CountResult().fromJsonString(jsonString, options);
  }

  static equals(a: CountResult | PlainMessage<CountResult> | undefined, b: CountResult | PlainMessage<CountResult> | undefined): boolean {
    return proto3.util.equals(CountResult, a, b);
  }
}

/**
 * @generated from message qdrant.RetrievedPoint
 */
export class RetrievedPoint extends Message<RetrievedPoint> {
  /**
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * @generated from field: map<string, qdrant.Value> payload = 2;
   */
  payload: { [key: string]: Value } = {};

  /**
   * @generated from field: optional qdrant.Vectors vectors = 4;
   */
  vectors?: Vectors;

  constructor(data?: PartialMessage<RetrievedPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RetrievedPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: PointId },
    { no: 2, name: "payload", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
    { no: 4, name: "vectors", kind: "message", T: Vectors, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetrievedPoint {
    return new RetrievedPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetrievedPoint {
    return new RetrievedPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetrievedPoint {
    return new RetrievedPoint().fromJsonString(jsonString, options);
  }

  static equals(a: RetrievedPoint | PlainMessage<RetrievedPoint> | undefined, b: RetrievedPoint | PlainMessage<RetrievedPoint> | undefined): boolean {
    return proto3.util.equals(RetrievedPoint, a, b);
  }
}

/**
 * @generated from message qdrant.GetResponse
 */
export class GetResponse extends Message<GetResponse> {
  /**
   * @generated from field: repeated qdrant.RetrievedPoint result = 1;
   */
  result: RetrievedPoint[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<GetResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.GetResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: RetrievedPoint, repeated: true },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetResponse {
    return new GetResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetResponse {
    return new GetResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetResponse {
    return new GetResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetResponse | PlainMessage<GetResponse> | undefined, b: GetResponse | PlainMessage<GetResponse> | undefined): boolean {
    return proto3.util.equals(GetResponse, a, b);
  }
}

/**
 * @generated from message qdrant.RecommendResponse
 */
export class RecommendResponse extends Message<RecommendResponse> {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<RecommendResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RecommendResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: ScoredPoint, repeated: true },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendResponse {
    return new RecommendResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendResponse {
    return new RecommendResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendResponse {
    return new RecommendResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RecommendResponse | PlainMessage<RecommendResponse> | undefined, b: RecommendResponse | PlainMessage<RecommendResponse> | undefined): boolean {
    return proto3.util.equals(RecommendResponse, a, b);
  }
}

/**
 * @generated from message qdrant.RecommendBatchResponse
 */
export class RecommendBatchResponse extends Message<RecommendBatchResponse> {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<RecommendBatchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RecommendBatchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: BatchResult, repeated: true },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecommendBatchResponse {
    return new RecommendBatchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecommendBatchResponse {
    return new RecommendBatchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecommendBatchResponse {
    return new RecommendBatchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RecommendBatchResponse | PlainMessage<RecommendBatchResponse> | undefined, b: RecommendBatchResponse | PlainMessage<RecommendBatchResponse> | undefined): boolean {
    return proto3.util.equals(RecommendBatchResponse, a, b);
  }
}

/**
 * @generated from message qdrant.Filter
 */
export class Filter extends Message<Filter> {
  /**
   * At least one of those conditions should match
   *
   * @generated from field: repeated qdrant.Condition should = 1;
   */
  should: Condition[] = [];

  /**
   * All conditions must match
   *
   * @generated from field: repeated qdrant.Condition must = 2;
   */
  must: Condition[] = [];

  /**
   * All conditions must NOT match
   *
   * @generated from field: repeated qdrant.Condition must_not = 3;
   */
  mustNot: Condition[] = [];

  constructor(data?: PartialMessage<Filter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.Filter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "should", kind: "message", T: Condition, repeated: true },
    { no: 2, name: "must", kind: "message", T: Condition, repeated: true },
    { no: 3, name: "must_not", kind: "message", T: Condition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
    return new Filter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
    return new Filter().fromJsonString(jsonString, options);
  }

  static equals(a: Filter | PlainMessage<Filter> | undefined, b: Filter | PlainMessage<Filter> | undefined): boolean {
    return proto3.util.equals(Filter, a, b);
  }
}

/**
 * @generated from message qdrant.Condition
 */
export class Condition extends Message<Condition> {
  /**
   * @generated from oneof qdrant.Condition.condition_one_of
   */
  conditionOneOf: {
    /**
     * @generated from field: qdrant.FieldCondition field = 1;
     */
    value: FieldCondition;
    case: "field";
  } | {
    /**
     * @generated from field: qdrant.IsEmptyCondition is_empty = 2;
     */
    value: IsEmptyCondition;
    case: "isEmpty";
  } | {
    /**
     * @generated from field: qdrant.HasIdCondition has_id = 3;
     */
    value: HasIdCondition;
    case: "hasId";
  } | {
    /**
     * @generated from field: qdrant.Filter filter = 4;
     */
    value: Filter;
    case: "filter";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "message", T: FieldCondition, oneof: "condition_one_of" },
    { no: 2, name: "is_empty", kind: "message", T: IsEmptyCondition, oneof: "condition_one_of" },
    { no: 3, name: "has_id", kind: "message", T: HasIdCondition, oneof: "condition_one_of" },
    { no: 4, name: "filter", kind: "message", T: Filter, oneof: "condition_one_of" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Condition {
    return new Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Condition {
    return new Condition().fromJsonString(jsonString, options);
  }

  static equals(a: Condition | PlainMessage<Condition> | undefined, b: Condition | PlainMessage<Condition> | undefined): boolean {
    return proto3.util.equals(Condition, a, b);
  }
}

/**
 * @generated from message qdrant.IsEmptyCondition
 */
export class IsEmptyCondition extends Message<IsEmptyCondition> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  constructor(data?: PartialMessage<IsEmptyCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.IsEmptyCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsEmptyCondition {
    return new IsEmptyCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsEmptyCondition {
    return new IsEmptyCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsEmptyCondition {
    return new IsEmptyCondition().fromJsonString(jsonString, options);
  }

  static equals(a: IsEmptyCondition | PlainMessage<IsEmptyCondition> | undefined, b: IsEmptyCondition | PlainMessage<IsEmptyCondition> | undefined): boolean {
    return proto3.util.equals(IsEmptyCondition, a, b);
  }
}

/**
 * @generated from message qdrant.HasIdCondition
 */
export class HasIdCondition extends Message<HasIdCondition> {
  /**
   * @generated from field: repeated qdrant.PointId has_id = 1;
   */
  hasId: PointId[] = [];

  constructor(data?: PartialMessage<HasIdCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.HasIdCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "has_id", kind: "message", T: PointId, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HasIdCondition {
    return new HasIdCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HasIdCondition {
    return new HasIdCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HasIdCondition {
    return new HasIdCondition().fromJsonString(jsonString, options);
  }

  static equals(a: HasIdCondition | PlainMessage<HasIdCondition> | undefined, b: HasIdCondition | PlainMessage<HasIdCondition> | undefined): boolean {
    return proto3.util.equals(HasIdCondition, a, b);
  }
}

/**
 * @generated from message qdrant.FieldCondition
 */
export class FieldCondition extends Message<FieldCondition> {
  /**
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Check if point has field with a given value
   *
   * @generated from field: qdrant.Match match = 2;
   */
  match?: Match;

  /**
   * Check if points value lies in a given range
   *
   * @generated from field: qdrant.Range range = 3;
   */
  range?: Range;

  /**
   * Check if points geo location lies in a given area
   *
   * @generated from field: qdrant.GeoBoundingBox geo_bounding_box = 4;
   */
  geoBoundingBox?: GeoBoundingBox;

  /**
   * Check if geo point is within a given radius
   *
   * @generated from field: qdrant.GeoRadius geo_radius = 5;
   */
  geoRadius?: GeoRadius;

  /**
   * Check number of values for a specific field
   *
   * @generated from field: qdrant.ValuesCount values_count = 6;
   */
  valuesCount?: ValuesCount;

  constructor(data?: PartialMessage<FieldCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.FieldCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "match", kind: "message", T: Match },
    { no: 3, name: "range", kind: "message", T: Range },
    { no: 4, name: "geo_bounding_box", kind: "message", T: GeoBoundingBox },
    { no: 5, name: "geo_radius", kind: "message", T: GeoRadius },
    { no: 6, name: "values_count", kind: "message", T: ValuesCount },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldCondition {
    return new FieldCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldCondition {
    return new FieldCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldCondition {
    return new FieldCondition().fromJsonString(jsonString, options);
  }

  static equals(a: FieldCondition | PlainMessage<FieldCondition> | undefined, b: FieldCondition | PlainMessage<FieldCondition> | undefined): boolean {
    return proto3.util.equals(FieldCondition, a, b);
  }
}

/**
 * @generated from message qdrant.Match
 */
export class Match extends Message<Match> {
  /**
   * @generated from oneof qdrant.Match.match_value
   */
  matchValue: {
    /**
     * Match string keyword
     *
     * @generated from field: string keyword = 1;
     */
    value: string;
    case: "keyword";
  } | {
    /**
     * Match integer
     *
     * @generated from field: int64 integer = 2;
     */
    value: bigint;
    case: "integer";
  } | {
    /**
     * Match boolean
     *
     * @generated from field: bool boolean = 3;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * Match text
     *
     * @generated from field: string text = 4;
     */
    value: string;
    case: "text";
  } | {
    /**
     * Match multiple keywords
     *
     * @generated from field: qdrant.RepeatedStrings keywords = 5;
     */
    value: RepeatedStrings;
    case: "keywords";
  } | {
    /**
     * Match multiple integers
     *
     * @generated from field: qdrant.RepeatedIntegers integers = 6;
     */
    value: RepeatedIntegers;
    case: "integers";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Match>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.Match";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keyword", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "match_value" },
    { no: 2, name: "integer", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "match_value" },
    { no: 3, name: "boolean", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "match_value" },
    { no: 4, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "match_value" },
    { no: 5, name: "keywords", kind: "message", T: RepeatedStrings, oneof: "match_value" },
    { no: 6, name: "integers", kind: "message", T: RepeatedIntegers, oneof: "match_value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Match {
    return new Match().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Match {
    return new Match().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Match {
    return new Match().fromJsonString(jsonString, options);
  }

  static equals(a: Match | PlainMessage<Match> | undefined, b: Match | PlainMessage<Match> | undefined): boolean {
    return proto3.util.equals(Match, a, b);
  }
}

/**
 * @generated from message qdrant.RepeatedStrings
 */
export class RepeatedStrings extends Message<RepeatedStrings> {
  /**
   * @generated from field: repeated string strings = 1;
   */
  strings: string[] = [];

  constructor(data?: PartialMessage<RepeatedStrings>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RepeatedStrings";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "strings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedStrings {
    return new RepeatedStrings().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedStrings {
    return new RepeatedStrings().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedStrings {
    return new RepeatedStrings().fromJsonString(jsonString, options);
  }

  static equals(a: RepeatedStrings | PlainMessage<RepeatedStrings> | undefined, b: RepeatedStrings | PlainMessage<RepeatedStrings> | undefined): boolean {
    return proto3.util.equals(RepeatedStrings, a, b);
  }
}

/**
 * @generated from message qdrant.RepeatedIntegers
 */
export class RepeatedIntegers extends Message<RepeatedIntegers> {
  /**
   * @generated from field: repeated int64 integers = 1;
   */
  integers: bigint[] = [];

  constructor(data?: PartialMessage<RepeatedIntegers>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RepeatedIntegers";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integers", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RepeatedIntegers {
    return new RepeatedIntegers().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RepeatedIntegers {
    return new RepeatedIntegers().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RepeatedIntegers {
    return new RepeatedIntegers().fromJsonString(jsonString, options);
  }

  static equals(a: RepeatedIntegers | PlainMessage<RepeatedIntegers> | undefined, b: RepeatedIntegers | PlainMessage<RepeatedIntegers> | undefined): boolean {
    return proto3.util.equals(RepeatedIntegers, a, b);
  }
}

/**
 * @generated from message qdrant.Range
 */
export class Range extends Message<Range> {
  /**
   * @generated from field: optional double lt = 1;
   */
  lt?: number;

  /**
   * @generated from field: optional double gt = 2;
   */
  gt?: number;

  /**
   * @generated from field: optional double gte = 3;
   */
  gte?: number;

  /**
   * @generated from field: optional double lte = 4;
   */
  lte?: number;

  constructor(data?: PartialMessage<Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "gt", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 3, name: "gte", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 4, name: "lte", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range {
    return new Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJsonString(jsonString, options);
  }

  static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean {
    return proto3.util.equals(Range, a, b);
  }
}

/**
 * @generated from message qdrant.GeoBoundingBox
 */
export class GeoBoundingBox extends Message<GeoBoundingBox> {
  /**
   * north-west corner
   *
   * @generated from field: qdrant.GeoPoint top_left = 1;
   */
  topLeft?: GeoPoint;

  /**
   * south-east corner
   *
   * @generated from field: qdrant.GeoPoint bottom_right = 2;
   */
  bottomRight?: GeoPoint;

  constructor(data?: PartialMessage<GeoBoundingBox>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.GeoBoundingBox";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "top_left", kind: "message", T: GeoPoint },
    { no: 2, name: "bottom_right", kind: "message", T: GeoPoint },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoBoundingBox {
    return new GeoBoundingBox().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoBoundingBox {
    return new GeoBoundingBox().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoBoundingBox {
    return new GeoBoundingBox().fromJsonString(jsonString, options);
  }

  static equals(a: GeoBoundingBox | PlainMessage<GeoBoundingBox> | undefined, b: GeoBoundingBox | PlainMessage<GeoBoundingBox> | undefined): boolean {
    return proto3.util.equals(GeoBoundingBox, a, b);
  }
}

/**
 * @generated from message qdrant.GeoRadius
 */
export class GeoRadius extends Message<GeoRadius> {
  /**
   * Center of the circle
   *
   * @generated from field: qdrant.GeoPoint center = 1;
   */
  center?: GeoPoint;

  /**
   * In meters
   *
   * @generated from field: float radius = 2;
   */
  radius = 0;

  constructor(data?: PartialMessage<GeoRadius>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.GeoRadius";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "center", kind: "message", T: GeoPoint },
    { no: 2, name: "radius", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoRadius {
    return new GeoRadius().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoRadius {
    return new GeoRadius().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoRadius {
    return new GeoRadius().fromJsonString(jsonString, options);
  }

  static equals(a: GeoRadius | PlainMessage<GeoRadius> | undefined, b: GeoRadius | PlainMessage<GeoRadius> | undefined): boolean {
    return proto3.util.equals(GeoRadius, a, b);
  }
}

/**
 * @generated from message qdrant.ValuesCount
 */
export class ValuesCount extends Message<ValuesCount> {
  /**
   * @generated from field: optional uint64 lt = 1;
   */
  lt?: bigint;

  /**
   * @generated from field: optional uint64 gt = 2;
   */
  gt?: bigint;

  /**
   * @generated from field: optional uint64 gte = 3;
   */
  gte?: bigint;

  /**
   * @generated from field: optional uint64 lte = 4;
   */
  lte?: bigint;

  constructor(data?: PartialMessage<ValuesCount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ValuesCount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lt", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "gt", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 3, name: "gte", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "lte", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValuesCount {
    return new ValuesCount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValuesCount {
    return new ValuesCount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValuesCount {
    return new ValuesCount().fromJsonString(jsonString, options);
  }

  static equals(a: ValuesCount | PlainMessage<ValuesCount> | undefined, b: ValuesCount | PlainMessage<ValuesCount> | undefined): boolean {
    return proto3.util.equals(ValuesCount, a, b);
  }
}

/**
 * @generated from message qdrant.PointsSelector
 */
export class PointsSelector extends Message<PointsSelector> {
  /**
   * @generated from oneof qdrant.PointsSelector.points_selector_one_of
   */
  pointsSelectorOneOf: {
    /**
     * @generated from field: qdrant.PointsIdsList points = 1;
     */
    value: PointsIdsList;
    case: "points";
  } | {
    /**
     * @generated from field: qdrant.Filter filter = 2;
     */
    value: Filter;
    case: "filter";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PointsSelector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PointsSelector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "points", kind: "message", T: PointsIdsList, oneof: "points_selector_one_of" },
    { no: 2, name: "filter", kind: "message", T: Filter, oneof: "points_selector_one_of" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsSelector {
    return new PointsSelector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsSelector {
    return new PointsSelector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsSelector {
    return new PointsSelector().fromJsonString(jsonString, options);
  }

  static equals(a: PointsSelector | PlainMessage<PointsSelector> | undefined, b: PointsSelector | PlainMessage<PointsSelector> | undefined): boolean {
    return proto3.util.equals(PointsSelector, a, b);
  }
}

/**
 * @generated from message qdrant.PointsIdsList
 */
export class PointsIdsList extends Message<PointsIdsList> {
  /**
   * @generated from field: repeated qdrant.PointId ids = 1;
   */
  ids: PointId[] = [];

  constructor(data?: PartialMessage<PointsIdsList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PointsIdsList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ids", kind: "message", T: PointId, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsIdsList {
    return new PointsIdsList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsIdsList {
    return new PointsIdsList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsIdsList {
    return new PointsIdsList().fromJsonString(jsonString, options);
  }

  static equals(a: PointsIdsList | PlainMessage<PointsIdsList> | undefined, b: PointsIdsList | PlainMessage<PointsIdsList> | undefined): boolean {
    return proto3.util.equals(PointsIdsList, a, b);
  }
}

/**
 * @generated from message qdrant.PointStruct
 */
export class PointStruct extends Message<PointStruct> {
  /**
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * @generated from field: map<string, qdrant.Value> payload = 3;
   */
  payload: { [key: string]: Value } = {};

  /**
   * @generated from field: optional qdrant.Vectors vectors = 4;
   */
  vectors?: Vectors;

  constructor(data?: PartialMessage<PointStruct>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PointStruct";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: PointId },
    { no: 3, name: "payload", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
    { no: 4, name: "vectors", kind: "message", T: Vectors, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointStruct {
    return new PointStruct().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointStruct {
    return new PointStruct().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointStruct {
    return new PointStruct().fromJsonString(jsonString, options);
  }

  static equals(a: PointStruct | PlainMessage<PointStruct> | undefined, b: PointStruct | PlainMessage<PointStruct> | undefined): boolean {
    return proto3.util.equals(PointStruct, a, b);
  }
}

/**
 * @generated from message qdrant.GeoPoint
 */
export class GeoPoint extends Message<GeoPoint> {
  /**
   * @generated from field: double lon = 1;
   */
  lon = 0;

  /**
   * @generated from field: double lat = 2;
   */
  lat = 0;

  constructor(data?: PartialMessage<GeoPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.GeoPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lon", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "lat", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GeoPoint {
    return new GeoPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GeoPoint {
    return new GeoPoint().fromJsonString(jsonString, options);
  }

  static equals(a: GeoPoint | PlainMessage<GeoPoint> | undefined, b: GeoPoint | PlainMessage<GeoPoint> | undefined): boolean {
    return proto3.util.equals(GeoPoint, a, b);
  }
}

