// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file collections.proto (package qdrant, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum qdrant.Distance
 */
export enum Distance {
  /**
   * @generated from enum value: UnknownDistance = 0;
   */
  UnknownDistance = 0,

  /**
   * @generated from enum value: Cosine = 1;
   */
  Cosine = 1,

  /**
   * @generated from enum value: Euclid = 2;
   */
  Euclid = 2,

  /**
   * @generated from enum value: Dot = 3;
   */
  Dot = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Distance)
proto3.util.setEnumType(Distance, "qdrant.Distance", [
  { no: 0, name: "UnknownDistance" },
  { no: 1, name: "Cosine" },
  { no: 2, name: "Euclid" },
  { no: 3, name: "Dot" },
]);

/**
 * @generated from enum qdrant.CollectionStatus
 */
export enum CollectionStatus {
  /**
   * @generated from enum value: UnknownCollectionStatus = 0;
   */
  UnknownCollectionStatus = 0,

  /**
   * All segments are ready
   *
   * @generated from enum value: Green = 1;
   */
  Green = 1,

  /**
   * Optimization in process
   *
   * @generated from enum value: Yellow = 2;
   */
  Yellow = 2,

  /**
   * Something went wrong
   *
   * @generated from enum value: Red = 3;
   */
  Red = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CollectionStatus)
proto3.util.setEnumType(CollectionStatus, "qdrant.CollectionStatus", [
  { no: 0, name: "UnknownCollectionStatus" },
  { no: 1, name: "Green" },
  { no: 2, name: "Yellow" },
  { no: 3, name: "Red" },
]);

/**
 * @generated from enum qdrant.PayloadSchemaType
 */
export enum PayloadSchemaType {
  /**
   * @generated from enum value: UnknownType = 0;
   */
  UnknownType = 0,

  /**
   * @generated from enum value: Keyword = 1;
   */
  Keyword = 1,

  /**
   * @generated from enum value: Integer = 2;
   */
  Integer = 2,

  /**
   * @generated from enum value: Float = 3;
   */
  Float = 3,

  /**
   * @generated from enum value: Geo = 4;
   */
  Geo = 4,

  /**
   * @generated from enum value: Text = 5;
   */
  Text = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(PayloadSchemaType)
proto3.util.setEnumType(PayloadSchemaType, "qdrant.PayloadSchemaType", [
  { no: 0, name: "UnknownType" },
  { no: 1, name: "Keyword" },
  { no: 2, name: "Integer" },
  { no: 3, name: "Float" },
  { no: 4, name: "Geo" },
  { no: 5, name: "Text" },
]);

/**
 * @generated from enum qdrant.QuantizationType
 */
export enum QuantizationType {
  /**
   * @generated from enum value: UnknownQuantization = 0;
   */
  UnknownQuantization = 0,

  /**
   * @generated from enum value: Int8 = 1;
   */
  Int8 = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(QuantizationType)
proto3.util.setEnumType(QuantizationType, "qdrant.QuantizationType", [
  { no: 0, name: "UnknownQuantization" },
  { no: 1, name: "Int8" },
]);

/**
 * @generated from enum qdrant.TokenizerType
 */
export enum TokenizerType {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: Prefix = 1;
   */
  Prefix = 1,

  /**
   * @generated from enum value: Whitespace = 2;
   */
  Whitespace = 2,

  /**
   * @generated from enum value: Word = 3;
   */
  Word = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TokenizerType)
proto3.util.setEnumType(TokenizerType, "qdrant.TokenizerType", [
  { no: 0, name: "Unknown" },
  { no: 1, name: "Prefix" },
  { no: 2, name: "Whitespace" },
  { no: 3, name: "Word" },
]);

/**
 * @generated from message qdrant.VectorParams
 */
export class VectorParams extends Message<VectorParams> {
  /**
   * Size of the vectors
   *
   * @generated from field: uint64 size = 1;
   */
  size = protoInt64.zero;

  /**
   * Distance function used for comparing vectors
   *
   * @generated from field: qdrant.Distance distance = 2;
   */
  distance = Distance.UnknownDistance;

  constructor(data?: PartialMessage<VectorParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.VectorParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "distance", kind: "enum", T: proto3.getEnumType(Distance) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorParams {
    return new VectorParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorParams {
    return new VectorParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorParams {
    return new VectorParams().fromJsonString(jsonString, options);
  }

  static equals(a: VectorParams | PlainMessage<VectorParams> | undefined, b: VectorParams | PlainMessage<VectorParams> | undefined): boolean {
    return proto3.util.equals(VectorParams, a, b);
  }
}

/**
 * @generated from message qdrant.VectorParamsMap
 */
export class VectorParamsMap extends Message<VectorParamsMap> {
  /**
   * @generated from field: map<string, qdrant.VectorParams> map = 1;
   */
  map: { [key: string]: VectorParams } = {};

  constructor(data?: PartialMessage<VectorParamsMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.VectorParamsMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: VectorParams} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorParamsMap {
    return new VectorParamsMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorParamsMap {
    return new VectorParamsMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorParamsMap {
    return new VectorParamsMap().fromJsonString(jsonString, options);
  }

  static equals(a: VectorParamsMap | PlainMessage<VectorParamsMap> | undefined, b: VectorParamsMap | PlainMessage<VectorParamsMap> | undefined): boolean {
    return proto3.util.equals(VectorParamsMap, a, b);
  }
}

/**
 * @generated from message qdrant.VectorsConfig
 */
export class VectorsConfig extends Message<VectorsConfig> {
  /**
   * @generated from oneof qdrant.VectorsConfig.config
   */
  config: {
    /**
     * @generated from field: qdrant.VectorParams params = 1;
     */
    value: VectorParams;
    case: "params";
  } | {
    /**
     * @generated from field: qdrant.VectorParamsMap params_map = 2;
     */
    value: VectorParamsMap;
    case: "paramsMap";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<VectorsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.VectorsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: VectorParams, oneof: "config" },
    { no: 2, name: "params_map", kind: "message", T: VectorParamsMap, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VectorsConfig {
    return new VectorsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VectorsConfig {
    return new VectorsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VectorsConfig {
    return new VectorsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: VectorsConfig | PlainMessage<VectorsConfig> | undefined, b: VectorsConfig | PlainMessage<VectorsConfig> | undefined): boolean {
    return proto3.util.equals(VectorsConfig, a, b);
  }
}

/**
 * @generated from message qdrant.GetCollectionInfoRequest
 */
export class GetCollectionInfoRequest extends Message<GetCollectionInfoRequest> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  constructor(data?: PartialMessage<GetCollectionInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.GetCollectionInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCollectionInfoRequest {
    return new GetCollectionInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCollectionInfoRequest {
    return new GetCollectionInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCollectionInfoRequest {
    return new GetCollectionInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCollectionInfoRequest | PlainMessage<GetCollectionInfoRequest> | undefined, b: GetCollectionInfoRequest | PlainMessage<GetCollectionInfoRequest> | undefined): boolean {
    return proto3.util.equals(GetCollectionInfoRequest, a, b);
  }
}

/**
 * @generated from message qdrant.ListCollectionsRequest
 */
export class ListCollectionsRequest extends Message<ListCollectionsRequest> {
  constructor(data?: PartialMessage<ListCollectionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ListCollectionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionsRequest {
    return new ListCollectionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionsRequest {
    return new ListCollectionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionsRequest {
    return new ListCollectionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListCollectionsRequest | PlainMessage<ListCollectionsRequest> | undefined, b: ListCollectionsRequest | PlainMessage<ListCollectionsRequest> | undefined): boolean {
    return proto3.util.equals(ListCollectionsRequest, a, b);
  }
}

/**
 * @generated from message qdrant.CollectionDescription
 */
export class CollectionDescription extends Message<CollectionDescription> {
  /**
   * Name of the collection
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<CollectionDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CollectionDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionDescription {
    return new CollectionDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionDescription {
    return new CollectionDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionDescription {
    return new CollectionDescription().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionDescription | PlainMessage<CollectionDescription> | undefined, b: CollectionDescription | PlainMessage<CollectionDescription> | undefined): boolean {
    return proto3.util.equals(CollectionDescription, a, b);
  }
}

/**
 * @generated from message qdrant.GetCollectionInfoResponse
 */
export class GetCollectionInfoResponse extends Message<GetCollectionInfoResponse> {
  /**
   * @generated from field: qdrant.CollectionInfo result = 1;
   */
  result?: CollectionInfo;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<GetCollectionInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.GetCollectionInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: CollectionInfo },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCollectionInfoResponse {
    return new GetCollectionInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCollectionInfoResponse {
    return new GetCollectionInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCollectionInfoResponse {
    return new GetCollectionInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetCollectionInfoResponse | PlainMessage<GetCollectionInfoResponse> | undefined, b: GetCollectionInfoResponse | PlainMessage<GetCollectionInfoResponse> | undefined): boolean {
    return proto3.util.equals(GetCollectionInfoResponse, a, b);
  }
}

/**
 * @generated from message qdrant.ListCollectionsResponse
 */
export class ListCollectionsResponse extends Message<ListCollectionsResponse> {
  /**
   * @generated from field: repeated qdrant.CollectionDescription collections = 1;
   */
  collections: CollectionDescription[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<ListCollectionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ListCollectionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collections", kind: "message", T: CollectionDescription, repeated: true },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionsResponse {
    return new ListCollectionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionsResponse {
    return new ListCollectionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionsResponse {
    return new ListCollectionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListCollectionsResponse | PlainMessage<ListCollectionsResponse> | undefined, b: ListCollectionsResponse | PlainMessage<ListCollectionsResponse> | undefined): boolean {
    return proto3.util.equals(ListCollectionsResponse, a, b);
  }
}

/**
 * @generated from message qdrant.OptimizerStatus
 */
export class OptimizerStatus extends Message<OptimizerStatus> {
  /**
   * @generated from field: bool ok = 1;
   */
  ok = false;

  /**
   * @generated from field: string error = 2;
   */
  error = "";

  constructor(data?: PartialMessage<OptimizerStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.OptimizerStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ok", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizerStatus {
    return new OptimizerStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizerStatus {
    return new OptimizerStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizerStatus {
    return new OptimizerStatus().fromJsonString(jsonString, options);
  }

  static equals(a: OptimizerStatus | PlainMessage<OptimizerStatus> | undefined, b: OptimizerStatus | PlainMessage<OptimizerStatus> | undefined): boolean {
    return proto3.util.equals(OptimizerStatus, a, b);
  }
}

/**
 * @generated from message qdrant.HnswConfigDiff
 */
export class HnswConfigDiff extends Message<HnswConfigDiff> {
  /**
   *
   * Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
   *
   * @generated from field: optional uint64 m = 1;
   */
  m?: bigint;

  /**
   *
   * Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build index.
   *
   * @generated from field: optional uint64 ef_construct = 2;
   */
  efConstruct?: bigint;

  /**
   *
   * Minimal size (in KiloBytes) of vectors for additional payload-based indexing.
   * If payload chunk is smaller than `full_scan_threshold` additional indexing won't be used -
   * in this case full-scan search should be preferred by query planner and additional indexing is not required.
   * Note: 1Kb = 1 vector of size 256
   *
   * @generated from field: optional uint64 full_scan_threshold = 3;
   */
  fullScanThreshold?: bigint;

  /**
   *
   * Number of parallel threads used for background index building. If 0 - auto selection.
   *
   * @generated from field: optional uint64 max_indexing_threads = 4;
   */
  maxIndexingThreads?: bigint;

  /**
   *
   * Store HNSW index on disk. If set to false, index will be stored in RAM.
   *
   * @generated from field: optional bool on_disk = 5;
   */
  onDisk?: boolean;

  /**
   *
   * Number of additional payload-aware links per node in the index graph. If not set - regular M parameter will be used.
   *
   * @generated from field: optional uint64 payload_m = 6;
   */
  payloadM?: bigint;

  constructor(data?: PartialMessage<HnswConfigDiff>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.HnswConfigDiff";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "m", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "ef_construct", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 3, name: "full_scan_threshold", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "max_indexing_threads", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 5, name: "on_disk", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "payload_m", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HnswConfigDiff {
    return new HnswConfigDiff().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HnswConfigDiff {
    return new HnswConfigDiff().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HnswConfigDiff {
    return new HnswConfigDiff().fromJsonString(jsonString, options);
  }

  static equals(a: HnswConfigDiff | PlainMessage<HnswConfigDiff> | undefined, b: HnswConfigDiff | PlainMessage<HnswConfigDiff> | undefined): boolean {
    return proto3.util.equals(HnswConfigDiff, a, b);
  }
}

/**
 * @generated from message qdrant.WalConfigDiff
 */
export class WalConfigDiff extends Message<WalConfigDiff> {
  /**
   * Size of a single WAL block file
   *
   * @generated from field: optional uint64 wal_capacity_mb = 1;
   */
  walCapacityMb?: bigint;

  /**
   * Number of segments to create in advance
   *
   * @generated from field: optional uint64 wal_segments_ahead = 2;
   */
  walSegmentsAhead?: bigint;

  constructor(data?: PartialMessage<WalConfigDiff>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.WalConfigDiff";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "wal_capacity_mb", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 2, name: "wal_segments_ahead", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WalConfigDiff {
    return new WalConfigDiff().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WalConfigDiff {
    return new WalConfigDiff().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WalConfigDiff {
    return new WalConfigDiff().fromJsonString(jsonString, options);
  }

  static equals(a: WalConfigDiff | PlainMessage<WalConfigDiff> | undefined, b: WalConfigDiff | PlainMessage<WalConfigDiff> | undefined): boolean {
    return proto3.util.equals(WalConfigDiff, a, b);
  }
}

/**
 * @generated from message qdrant.OptimizersConfigDiff
 */
export class OptimizersConfigDiff extends Message<OptimizersConfigDiff> {
  /**
   *
   * The minimal fraction of deleted vectors in a segment, required to perform segment optimization
   *
   * @generated from field: optional double deleted_threshold = 1;
   */
  deletedThreshold?: number;

  /**
   *
   * The minimal number of vectors in a segment, required to perform segment optimization
   *
   * @generated from field: optional uint64 vacuum_min_vector_number = 2;
   */
  vacuumMinVectorNumber?: bigint;

  /**
   *
   * Target amount of segments optimizer will try to keep.
   * Real amount of segments may vary depending on multiple parameters:
   *
   * - Amount of stored points.
   * - Current write RPS.
   *
   * It is recommended to select default number of segments as a factor of the number of search threads,
   * so that each segment would be handled evenly by one of the threads.
   *
   * @generated from field: optional uint64 default_segment_number = 3;
   */
  defaultSegmentNumber?: bigint;

  /**
   *
   * Do not create segments larger this size (in KiloBytes).
   * Large segments might require disproportionately long indexation times,
   * therefore it makes sense to limit the size of segments.
   *
   * If indexation speed have more priority for your - make this parameter lower.
   * If search speed is more important - make this parameter higher.
   * Note: 1Kb = 1 vector of size 256
   *
   * @generated from field: optional uint64 max_segment_size = 4;
   */
  maxSegmentSize?: bigint;

  /**
   *
   * Maximum size (in KiloBytes) of vectors to store in-memory per segment.
   * Segments larger than this threshold will be stored as read-only memmaped file.
   * To enable memmap storage, lower the threshold
   * Note: 1Kb = 1 vector of size 256
   *
   * @generated from field: optional uint64 memmap_threshold = 5;
   */
  memmapThreshold?: bigint;

  /**
   *
   * Maximum size (in KiloBytes) of vectors allowed for plain index.
   * Default value based on https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md
   * Note: 1Kb = 1 vector of size 256
   *
   * @generated from field: optional uint64 indexing_threshold = 6;
   */
  indexingThreshold?: bigint;

  /**
   *
   * Interval between forced flushes.
   *
   * @generated from field: optional uint64 flush_interval_sec = 7;
   */
  flushIntervalSec?: bigint;

  /**
   *
   * Max number of threads, which can be used for optimization. If 0 - `NUM_CPU - 1` will be used
   *
   * @generated from field: optional uint64 max_optimization_threads = 8;
   */
  maxOptimizationThreads?: bigint;

  constructor(data?: PartialMessage<OptimizersConfigDiff>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.OptimizersConfigDiff";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deleted_threshold", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, opt: true },
    { no: 2, name: "vacuum_min_vector_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 3, name: "default_segment_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "max_segment_size", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 5, name: "memmap_threshold", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 6, name: "indexing_threshold", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 7, name: "flush_interval_sec", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 8, name: "max_optimization_threads", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OptimizersConfigDiff {
    return new OptimizersConfigDiff().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OptimizersConfigDiff {
    return new OptimizersConfigDiff().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OptimizersConfigDiff {
    return new OptimizersConfigDiff().fromJsonString(jsonString, options);
  }

  static equals(a: OptimizersConfigDiff | PlainMessage<OptimizersConfigDiff> | undefined, b: OptimizersConfigDiff | PlainMessage<OptimizersConfigDiff> | undefined): boolean {
    return proto3.util.equals(OptimizersConfigDiff, a, b);
  }
}

/**
 * @generated from message qdrant.ScalarQuantization
 */
export class ScalarQuantization extends Message<ScalarQuantization> {
  /**
   * Type of quantization
   *
   * @generated from field: qdrant.QuantizationType type = 1;
   */
  type = QuantizationType.UnknownQuantization;

  /**
   * Number of bits to use for quantization
   *
   * @generated from field: optional float quantile = 2;
   */
  quantile?: number;

  /**
   * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
   *
   * @generated from field: optional bool always_ram = 3;
   */
  alwaysRam?: boolean;

  constructor(data?: PartialMessage<ScalarQuantization>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ScalarQuantization";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(QuantizationType) },
    { no: 2, name: "quantile", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
    { no: 3, name: "always_ram", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScalarQuantization {
    return new ScalarQuantization().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScalarQuantization {
    return new ScalarQuantization().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScalarQuantization {
    return new ScalarQuantization().fromJsonString(jsonString, options);
  }

  static equals(a: ScalarQuantization | PlainMessage<ScalarQuantization> | undefined, b: ScalarQuantization | PlainMessage<ScalarQuantization> | undefined): boolean {
    return proto3.util.equals(ScalarQuantization, a, b);
  }
}

/**
 * @generated from message qdrant.QuantizationConfig
 */
export class QuantizationConfig extends Message<QuantizationConfig> {
  /**
   * @generated from oneof qdrant.QuantizationConfig.quantization
   */
  quantization: {
    /**
     * @generated from field: qdrant.ScalarQuantization scalar = 1;
     */
    value: ScalarQuantization;
    case: "scalar";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<QuantizationConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.QuantizationConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scalar", kind: "message", T: ScalarQuantization, oneof: "quantization" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuantizationConfig {
    return new QuantizationConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuantizationConfig {
    return new QuantizationConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuantizationConfig {
    return new QuantizationConfig().fromJsonString(jsonString, options);
  }

  static equals(a: QuantizationConfig | PlainMessage<QuantizationConfig> | undefined, b: QuantizationConfig | PlainMessage<QuantizationConfig> | undefined): boolean {
    return proto3.util.equals(QuantizationConfig, a, b);
  }
}

/**
 * @generated from message qdrant.CreateCollection
 */
export class CreateCollection extends Message<CreateCollection> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Configuration of vector index
   *
   * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 4;
   */
  hnswConfig?: HnswConfigDiff;

  /**
   * Configuration of the Write-Ahead-Log
   *
   * @generated from field: optional qdrant.WalConfigDiff wal_config = 5;
   */
  walConfig?: WalConfigDiff;

  /**
   * Configuration of the optimizers
   *
   * @generated from field: optional qdrant.OptimizersConfigDiff optimizers_config = 6;
   */
  optimizersConfig?: OptimizersConfigDiff;

  /**
   * Number of shards in the collection, default = 1
   *
   * @generated from field: optional uint32 shard_number = 7;
   */
  shardNumber?: number;

  /**
   * If true - point's payload will not be stored in memory
   *
   * @generated from field: optional bool on_disk_payload = 8;
   */
  onDiskPayload?: boolean;

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 9;
   */
  timeout?: bigint;

  /**
   * Configuration for vectors
   *
   * @generated from field: optional qdrant.VectorsConfig vectors_config = 10;
   */
  vectorsConfig?: VectorsConfig;

  /**
   * Number of replicas of each shard that network tries to maintain, default = 1
   *
   * @generated from field: optional uint32 replication_factor = 11;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful, default = 1
   *
   * @generated from field: optional uint32 write_consistency_factor = 12;
   */
  writeConsistencyFactor?: number;

  /**
   * Specify name of the other collection to copy data from
   *
   * @generated from field: optional string init_from_collection = 13;
   */
  initFromCollection?: string;

  /**
   * @generated from field: optional qdrant.QuantizationConfig quantization_config = 14;
   */
  quantizationConfig?: QuantizationConfig;

  constructor(data?: PartialMessage<CreateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CreateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "hnsw_config", kind: "message", T: HnswConfigDiff, opt: true },
    { no: 5, name: "wal_config", kind: "message", T: WalConfigDiff, opt: true },
    { no: 6, name: "optimizers_config", kind: "message", T: OptimizersConfigDiff, opt: true },
    { no: 7, name: "shard_number", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 8, name: "on_disk_payload", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 9, name: "timeout", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 10, name: "vectors_config", kind: "message", T: VectorsConfig, opt: true },
    { no: 11, name: "replication_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 12, name: "write_consistency_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 13, name: "init_from_collection", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 14, name: "quantization_config", kind: "message", T: QuantizationConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateCollection {
    return new CreateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateCollection {
    return new CreateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateCollection {
    return new CreateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: CreateCollection | PlainMessage<CreateCollection> | undefined, b: CreateCollection | PlainMessage<CreateCollection> | undefined): boolean {
    return proto3.util.equals(CreateCollection, a, b);
  }
}

/**
 * @generated from message qdrant.UpdateCollection
 */
export class UpdateCollection extends Message<UpdateCollection> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * New configuration parameters for the collection
   *
   * @generated from field: optional qdrant.OptimizersConfigDiff optimizers_config = 2;
   */
  optimizersConfig?: OptimizersConfigDiff;

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 3;
   */
  timeout?: bigint;

  /**
   * New configuration parameters for the collection
   *
   * @generated from field: optional qdrant.CollectionParamsDiff params = 4;
   */
  params?: CollectionParamsDiff;

  constructor(data?: PartialMessage<UpdateCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.UpdateCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "optimizers_config", kind: "message", T: OptimizersConfigDiff, opt: true },
    { no: 3, name: "timeout", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "params", kind: "message", T: CollectionParamsDiff, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateCollection {
    return new UpdateCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateCollection {
    return new UpdateCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateCollection {
    return new UpdateCollection().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateCollection | PlainMessage<UpdateCollection> | undefined, b: UpdateCollection | PlainMessage<UpdateCollection> | undefined): boolean {
    return proto3.util.equals(UpdateCollection, a, b);
  }
}

/**
 * @generated from message qdrant.DeleteCollection
 */
export class DeleteCollection extends Message<DeleteCollection> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 2;
   */
  timeout?: bigint;

  constructor(data?: PartialMessage<DeleteCollection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.DeleteCollection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timeout", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCollection {
    return new DeleteCollection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCollection {
    return new DeleteCollection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCollection {
    return new DeleteCollection().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteCollection | PlainMessage<DeleteCollection> | undefined, b: DeleteCollection | PlainMessage<DeleteCollection> | undefined): boolean {
    return proto3.util.equals(DeleteCollection, a, b);
  }
}

/**
 * @generated from message qdrant.CollectionOperationResponse
 */
export class CollectionOperationResponse extends Message<CollectionOperationResponse> {
  /**
   * if operation made changes
   *
   * @generated from field: bool result = 1;
   */
  result = false;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<CollectionOperationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CollectionOperationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionOperationResponse {
    return new CollectionOperationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionOperationResponse {
    return new CollectionOperationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionOperationResponse {
    return new CollectionOperationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionOperationResponse | PlainMessage<CollectionOperationResponse> | undefined, b: CollectionOperationResponse | PlainMessage<CollectionOperationResponse> | undefined): boolean {
    return proto3.util.equals(CollectionOperationResponse, a, b);
  }
}

/**
 * @generated from message qdrant.CollectionParams
 */
export class CollectionParams extends Message<CollectionParams> {
  /**
   * Number of shards in collection
   *
   * @generated from field: uint32 shard_number = 3;
   */
  shardNumber = 0;

  /**
   * If true - point's payload will not be stored in memory
   *
   * @generated from field: bool on_disk_payload = 4;
   */
  onDiskPayload = false;

  /**
   * Configuration for vectors
   *
   * @generated from field: optional qdrant.VectorsConfig vectors_config = 5;
   */
  vectorsConfig?: VectorsConfig;

  /**
   * Number of replicas of each shard that network tries to maintain
   *
   * @generated from field: optional uint32 replication_factor = 6;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   *
   * @generated from field: optional uint32 write_consistency_factor = 7;
   */
  writeConsistencyFactor?: number;

  constructor(data?: PartialMessage<CollectionParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CollectionParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "shard_number", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "on_disk_payload", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "vectors_config", kind: "message", T: VectorsConfig, opt: true },
    { no: 6, name: "replication_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 7, name: "write_consistency_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionParams {
    return new CollectionParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionParams {
    return new CollectionParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionParams {
    return new CollectionParams().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionParams | PlainMessage<CollectionParams> | undefined, b: CollectionParams | PlainMessage<CollectionParams> | undefined): boolean {
    return proto3.util.equals(CollectionParams, a, b);
  }
}

/**
 * @generated from message qdrant.CollectionParamsDiff
 */
export class CollectionParamsDiff extends Message<CollectionParamsDiff> {
  /**
   * Number of replicas of each shard that network tries to maintain
   *
   * @generated from field: optional uint32 replication_factor = 1;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   *
   * @generated from field: optional uint32 write_consistency_factor = 2;
   */
  writeConsistencyFactor?: number;

  constructor(data?: PartialMessage<CollectionParamsDiff>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CollectionParamsDiff";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "replication_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "write_consistency_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionParamsDiff {
    return new CollectionParamsDiff().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionParamsDiff {
    return new CollectionParamsDiff().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionParamsDiff {
    return new CollectionParamsDiff().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionParamsDiff | PlainMessage<CollectionParamsDiff> | undefined, b: CollectionParamsDiff | PlainMessage<CollectionParamsDiff> | undefined): boolean {
    return proto3.util.equals(CollectionParamsDiff, a, b);
  }
}

/**
 * @generated from message qdrant.CollectionConfig
 */
export class CollectionConfig extends Message<CollectionConfig> {
  /**
   * Collection parameters
   *
   * @generated from field: qdrant.CollectionParams params = 1;
   */
  params?: CollectionParams;

  /**
   * Configuration of vector index
   *
   * @generated from field: qdrant.HnswConfigDiff hnsw_config = 2;
   */
  hnswConfig?: HnswConfigDiff;

  /**
   * Configuration of the optimizers
   *
   * @generated from field: qdrant.OptimizersConfigDiff optimizer_config = 3;
   */
  optimizerConfig?: OptimizersConfigDiff;

  /**
   * Configuration of the Write-Ahead-Log
   *
   * @generated from field: qdrant.WalConfigDiff wal_config = 4;
   */
  walConfig?: WalConfigDiff;

  /**
   * Configuration of the vector quantization
   *
   * @generated from field: optional qdrant.QuantizationConfig quantization_config = 5;
   */
  quantizationConfig?: QuantizationConfig;

  constructor(data?: PartialMessage<CollectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CollectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: CollectionParams },
    { no: 2, name: "hnsw_config", kind: "message", T: HnswConfigDiff },
    { no: 3, name: "optimizer_config", kind: "message", T: OptimizersConfigDiff },
    { no: 4, name: "wal_config", kind: "message", T: WalConfigDiff },
    { no: 5, name: "quantization_config", kind: "message", T: QuantizationConfig, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionConfig {
    return new CollectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionConfig {
    return new CollectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionConfig {
    return new CollectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionConfig | PlainMessage<CollectionConfig> | undefined, b: CollectionConfig | PlainMessage<CollectionConfig> | undefined): boolean {
    return proto3.util.equals(CollectionConfig, a, b);
  }
}

/**
 * @generated from message qdrant.TextIndexParams
 */
export class TextIndexParams extends Message<TextIndexParams> {
  /**
   * Tokenizer type
   *
   * @generated from field: qdrant.TokenizerType tokenizer = 1;
   */
  tokenizer = TokenizerType.Unknown;

  /**
   * If true - all tokens will be lowercased
   *
   * @generated from field: optional bool lowercase = 2;
   */
  lowercase?: boolean;

  /**
   * Minimal token length
   *
   * @generated from field: optional uint64 min_token_len = 3;
   */
  minTokenLen?: bigint;

  /**
   * Maximal token length
   *
   * @generated from field: optional uint64 max_token_len = 4;
   */
  maxTokenLen?: bigint;

  constructor(data?: PartialMessage<TextIndexParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.TextIndexParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tokenizer", kind: "enum", T: proto3.getEnumType(TokenizerType) },
    { no: 2, name: "lowercase", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 3, name: "min_token_len", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
    { no: 4, name: "max_token_len", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextIndexParams {
    return new TextIndexParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextIndexParams {
    return new TextIndexParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextIndexParams {
    return new TextIndexParams().fromJsonString(jsonString, options);
  }

  static equals(a: TextIndexParams | PlainMessage<TextIndexParams> | undefined, b: TextIndexParams | PlainMessage<TextIndexParams> | undefined): boolean {
    return proto3.util.equals(TextIndexParams, a, b);
  }
}

/**
 * @generated from message qdrant.PayloadIndexParams
 */
export class PayloadIndexParams extends Message<PayloadIndexParams> {
  /**
   * @generated from oneof qdrant.PayloadIndexParams.index_params
   */
  indexParams: {
    /**
     * Parameters for text index
     *
     * @generated from field: qdrant.TextIndexParams text_index_params = 1;
     */
    value: TextIndexParams;
    case: "textIndexParams";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PayloadIndexParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PayloadIndexParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text_index_params", kind: "message", T: TextIndexParams, oneof: "index_params" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadIndexParams {
    return new PayloadIndexParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadIndexParams {
    return new PayloadIndexParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadIndexParams {
    return new PayloadIndexParams().fromJsonString(jsonString, options);
  }

  static equals(a: PayloadIndexParams | PlainMessage<PayloadIndexParams> | undefined, b: PayloadIndexParams | PlainMessage<PayloadIndexParams> | undefined): boolean {
    return proto3.util.equals(PayloadIndexParams, a, b);
  }
}

/**
 * @generated from message qdrant.PayloadSchemaInfo
 */
export class PayloadSchemaInfo extends Message<PayloadSchemaInfo> {
  /**
   * Field data type
   *
   * @generated from field: qdrant.PayloadSchemaType data_type = 1;
   */
  dataType = PayloadSchemaType.UnknownType;

  /**
   * Field index parameters
   *
   * @generated from field: optional qdrant.PayloadIndexParams params = 2;
   */
  params?: PayloadIndexParams;

  /**
   * Number of points indexed within this field indexed
   *
   * @generated from field: optional uint64 points = 3;
   */
  points?: bigint;

  constructor(data?: PartialMessage<PayloadSchemaInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.PayloadSchemaInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_type", kind: "enum", T: proto3.getEnumType(PayloadSchemaType) },
    { no: 2, name: "params", kind: "message", T: PayloadIndexParams, opt: true },
    { no: 3, name: "points", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PayloadSchemaInfo {
    return new PayloadSchemaInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PayloadSchemaInfo {
    return new PayloadSchemaInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PayloadSchemaInfo {
    return new PayloadSchemaInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PayloadSchemaInfo | PlainMessage<PayloadSchemaInfo> | undefined, b: PayloadSchemaInfo | PlainMessage<PayloadSchemaInfo> | undefined): boolean {
    return proto3.util.equals(PayloadSchemaInfo, a, b);
  }
}

/**
 * @generated from message qdrant.CollectionInfo
 */
export class CollectionInfo extends Message<CollectionInfo> {
  /**
   * operating condition of the collection
   *
   * @generated from field: qdrant.CollectionStatus status = 1;
   */
  status = CollectionStatus.UnknownCollectionStatus;

  /**
   * status of collection optimizers
   *
   * @generated from field: qdrant.OptimizerStatus optimizer_status = 2;
   */
  optimizerStatus?: OptimizerStatus;

  /**
   * number of vectors in the collection
   *
   * @generated from field: uint64 vectors_count = 3;
   */
  vectorsCount = protoInt64.zero;

  /**
   * Number of independent segments
   *
   * @generated from field: uint64 segments_count = 4;
   */
  segmentsCount = protoInt64.zero;

  /**
   * Configuration
   *
   * @generated from field: qdrant.CollectionConfig config = 7;
   */
  config?: CollectionConfig;

  /**
   * Collection data types
   *
   * @generated from field: map<string, qdrant.PayloadSchemaInfo> payload_schema = 8;
   */
  payloadSchema: { [key: string]: PayloadSchemaInfo } = {};

  /**
   * number of points in the collection
   *
   * @generated from field: uint64 points_count = 9;
   */
  pointsCount = protoInt64.zero;

  /**
   * number of indexed vectors in the collection.
   *
   * @generated from field: optional uint64 indexed_vectors_count = 10;
   */
  indexedVectorsCount?: bigint;

  constructor(data?: PartialMessage<CollectionInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CollectionInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(CollectionStatus) },
    { no: 2, name: "optimizer_status", kind: "message", T: OptimizerStatus },
    { no: 3, name: "vectors_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "segments_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "config", kind: "message", T: CollectionConfig },
    { no: 8, name: "payload_schema", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: PayloadSchemaInfo} },
    { no: 9, name: "points_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 10, name: "indexed_vectors_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CollectionInfo {
    return new CollectionInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CollectionInfo {
    return new CollectionInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CollectionInfo {
    return new CollectionInfo().fromJsonString(jsonString, options);
  }

  static equals(a: CollectionInfo | PlainMessage<CollectionInfo> | undefined, b: CollectionInfo | PlainMessage<CollectionInfo> | undefined): boolean {
    return proto3.util.equals(CollectionInfo, a, b);
  }
}

/**
 * @generated from message qdrant.ChangeAliases
 */
export class ChangeAliases extends Message<ChangeAliases> {
  /**
   * List of actions
   *
   * @generated from field: repeated qdrant.AliasOperations actions = 1;
   */
  actions: AliasOperations[] = [];

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 2;
   */
  timeout?: bigint;

  constructor(data?: PartialMessage<ChangeAliases>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ChangeAliases";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actions", kind: "message", T: AliasOperations, repeated: true },
    { no: 2, name: "timeout", kind: "scalar", T: 4 /* ScalarType.UINT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeAliases {
    return new ChangeAliases().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeAliases {
    return new ChangeAliases().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeAliases {
    return new ChangeAliases().fromJsonString(jsonString, options);
  }

  static equals(a: ChangeAliases | PlainMessage<ChangeAliases> | undefined, b: ChangeAliases | PlainMessage<ChangeAliases> | undefined): boolean {
    return proto3.util.equals(ChangeAliases, a, b);
  }
}

/**
 * @generated from message qdrant.AliasOperations
 */
export class AliasOperations extends Message<AliasOperations> {
  /**
   * @generated from oneof qdrant.AliasOperations.action
   */
  action: {
    /**
     * @generated from field: qdrant.CreateAlias create_alias = 1;
     */
    value: CreateAlias;
    case: "createAlias";
  } | {
    /**
     * @generated from field: qdrant.RenameAlias rename_alias = 2;
     */
    value: RenameAlias;
    case: "renameAlias";
  } | {
    /**
     * @generated from field: qdrant.DeleteAlias delete_alias = 3;
     */
    value: DeleteAlias;
    case: "deleteAlias";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AliasOperations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.AliasOperations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "create_alias", kind: "message", T: CreateAlias, oneof: "action" },
    { no: 2, name: "rename_alias", kind: "message", T: RenameAlias, oneof: "action" },
    { no: 3, name: "delete_alias", kind: "message", T: DeleteAlias, oneof: "action" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasOperations {
    return new AliasOperations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasOperations {
    return new AliasOperations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasOperations {
    return new AliasOperations().fromJsonString(jsonString, options);
  }

  static equals(a: AliasOperations | PlainMessage<AliasOperations> | undefined, b: AliasOperations | PlainMessage<AliasOperations> | undefined): boolean {
    return proto3.util.equals(AliasOperations, a, b);
  }
}

/**
 * @generated from message qdrant.CreateAlias
 */
export class CreateAlias extends Message<CreateAlias> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  /**
   * New name of the alias
   *
   * @generated from field: string alias_name = 2;
   */
  aliasName = "";

  constructor(data?: PartialMessage<CreateAlias>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.CreateAlias";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "alias_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAlias {
    return new CreateAlias().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAlias {
    return new CreateAlias().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAlias {
    return new CreateAlias().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAlias | PlainMessage<CreateAlias> | undefined, b: CreateAlias | PlainMessage<CreateAlias> | undefined): boolean {
    return proto3.util.equals(CreateAlias, a, b);
  }
}

/**
 * @generated from message qdrant.RenameAlias
 */
export class RenameAlias extends Message<RenameAlias> {
  /**
   * Name of the alias to rename
   *
   * @generated from field: string old_alias_name = 1;
   */
  oldAliasName = "";

  /**
   * Name of the alias
   *
   * @generated from field: string new_alias_name = 2;
   */
  newAliasName = "";

  constructor(data?: PartialMessage<RenameAlias>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.RenameAlias";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "old_alias_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "new_alias_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RenameAlias {
    return new RenameAlias().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RenameAlias {
    return new RenameAlias().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RenameAlias {
    return new RenameAlias().fromJsonString(jsonString, options);
  }

  static equals(a: RenameAlias | PlainMessage<RenameAlias> | undefined, b: RenameAlias | PlainMessage<RenameAlias> | undefined): boolean {
    return proto3.util.equals(RenameAlias, a, b);
  }
}

/**
 * @generated from message qdrant.DeleteAlias
 */
export class DeleteAlias extends Message<DeleteAlias> {
  /**
   * Name of the alias
   *
   * @generated from field: string alias_name = 1;
   */
  aliasName = "";

  constructor(data?: PartialMessage<DeleteAlias>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.DeleteAlias";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alias_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAlias {
    return new DeleteAlias().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAlias {
    return new DeleteAlias().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAlias {
    return new DeleteAlias().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAlias | PlainMessage<DeleteAlias> | undefined, b: DeleteAlias | PlainMessage<DeleteAlias> | undefined): boolean {
    return proto3.util.equals(DeleteAlias, a, b);
  }
}

/**
 * @generated from message qdrant.ListAliasesRequest
 */
export class ListAliasesRequest extends Message<ListAliasesRequest> {
  constructor(data?: PartialMessage<ListAliasesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ListAliasesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAliasesRequest {
    return new ListAliasesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAliasesRequest {
    return new ListAliasesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAliasesRequest {
    return new ListAliasesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListAliasesRequest | PlainMessage<ListAliasesRequest> | undefined, b: ListAliasesRequest | PlainMessage<ListAliasesRequest> | undefined): boolean {
    return proto3.util.equals(ListAliasesRequest, a, b);
  }
}

/**
 * @generated from message qdrant.ListCollectionAliasesRequest
 */
export class ListCollectionAliasesRequest extends Message<ListCollectionAliasesRequest> {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName = "";

  constructor(data?: PartialMessage<ListCollectionAliasesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ListCollectionAliasesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionAliasesRequest {
    return new ListCollectionAliasesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionAliasesRequest {
    return new ListCollectionAliasesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionAliasesRequest {
    return new ListCollectionAliasesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListCollectionAliasesRequest | PlainMessage<ListCollectionAliasesRequest> | undefined, b: ListCollectionAliasesRequest | PlainMessage<ListCollectionAliasesRequest> | undefined): boolean {
    return proto3.util.equals(ListCollectionAliasesRequest, a, b);
  }
}

/**
 * @generated from message qdrant.AliasDescription
 */
export class AliasDescription extends Message<AliasDescription> {
  /**
   * Name of the alias
   *
   * @generated from field: string alias_name = 1;
   */
  aliasName = "";

  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 2;
   */
  collectionName = "";

  constructor(data?: PartialMessage<AliasDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.AliasDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alias_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AliasDescription {
    return new AliasDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AliasDescription {
    return new AliasDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AliasDescription {
    return new AliasDescription().fromJsonString(jsonString, options);
  }

  static equals(a: AliasDescription | PlainMessage<AliasDescription> | undefined, b: AliasDescription | PlainMessage<AliasDescription> | undefined): boolean {
    return proto3.util.equals(AliasDescription, a, b);
  }
}

/**
 * @generated from message qdrant.ListAliasesResponse
 */
export class ListAliasesResponse extends Message<ListAliasesResponse> {
  /**
   * @generated from field: repeated qdrant.AliasDescription aliases = 1;
   */
  aliases: AliasDescription[] = [];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time = 0;

  constructor(data?: PartialMessage<ListAliasesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "qdrant.ListAliasesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aliases", kind: "message", T: AliasDescription, repeated: true },
    { no: 2, name: "time", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListAliasesResponse {
    return new ListAliasesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListAliasesResponse {
    return new ListAliasesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListAliasesResponse {
    return new ListAliasesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListAliasesResponse | PlainMessage<ListAliasesResponse> | undefined, b: ListAliasesResponse | PlainMessage<ListAliasesResponse> | undefined): boolean {
    return proto3.util.equals(ListAliasesResponse, a, b);
  }
}

