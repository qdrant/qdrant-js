// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=js"
// @generated from file points.proto (package qdrant, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { PayloadIndexParams, ShardKey } from "./collections_pb.js";
import { file_collections } from "./collections_pb.js";
import type { Condition, Filter, GeoPoint, PointId } from "./common_pb.js";
import { file_common } from "./common_pb.js";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Value } from "./json_with_int_pb.js";
import { file_json_with_int } from "./json_with_int_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file points.proto.
 */
export const file_points: GenFile = /*@__PURE__*/
  fileDesc("Cgxwb2ludHMucHJvdG8SBnFkcmFudCI4Cg1Xcml0ZU9yZGVyaW5nEicKBHR5cGUYASABKA4yGS5xZHJhbnQuV3JpdGVPcmRlcmluZ1R5cGUiWQoPUmVhZENvbnNpc3RlbmN5EisKBHR5cGUYASABKA4yGy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5VHlwZUgAEhAKBmZhY3RvchgCIAEoBEgAQgcKBXZhbHVlIh0KDVNwYXJzZUluZGljZXMSDAoEZGF0YRgBIAMoDSKWAQoIRG9jdW1lbnQSDAoEdGV4dBgBIAEoCRINCgVtb2RlbBgDIAEoCRIuCgdvcHRpb25zGAQgAygLMh0ucWRyYW50LkRvY3VtZW50Lk9wdGlvbnNFbnRyeRo9CgxPcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEhwKBXZhbHVlGAIgASgLMg0ucWRyYW50LlZhbHVlOgI4ASKgAQoFSW1hZ2USHAoFaW1hZ2UYASABKAsyDS5xZHJhbnQuVmFsdWUSDQoFbW9kZWwYAiABKAkSKwoHb3B0aW9ucxgDIAMoCzIaLnFkcmFudC5JbWFnZS5PcHRpb25zRW50cnkaPQoMT3B0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRIcCgV2YWx1ZRgCIAEoCzINLnFkcmFudC5WYWx1ZToCOAEitQEKD0luZmVyZW5jZU9iamVjdBIdCgZvYmplY3QYASABKAsyDS5xZHJhbnQuVmFsdWUSDQoFbW9kZWwYAiABKAkSNQoHb3B0aW9ucxgDIAMoCzIkLnFkcmFudC5JbmZlcmVuY2VPYmplY3QuT3B0aW9uc0VudHJ5Gj0KDE9wdGlvbnNFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBIoMDCgZWZWN0b3ISEAoEZGF0YRgBIAMoAkICGAESLwoHaW5kaWNlcxgCIAEoCzIVLnFkcmFudC5TcGFyc2VJbmRpY2VzQgIYAUgBiAEBEh4KDXZlY3RvcnNfY291bnQYAyABKA1CAhgBSAKIAQESJAoFZGVuc2UYZSABKAsyEy5xZHJhbnQuRGVuc2VWZWN0b3JIABImCgZzcGFyc2UYZiABKAsyFC5xZHJhbnQuU3BhcnNlVmVjdG9ySAASLwoLbXVsdGlfZGVuc2UYZyABKAsyGC5xZHJhbnQuTXVsdGlEZW5zZVZlY3RvckgAEiQKCGRvY3VtZW50GGggASgLMhAucWRyYW50LkRvY3VtZW50SAASHgoFaW1hZ2UYaSABKAsyDS5xZHJhbnQuSW1hZ2VIABIpCgZvYmplY3QYaiABKAsyFy5xZHJhbnQuSW5mZXJlbmNlT2JqZWN0SABCCAoGdmVjdG9yQgoKCF9pbmRpY2VzQhAKDl92ZWN0b3JzX2NvdW50IpgCCgxWZWN0b3JPdXRwdXQSEAoEZGF0YRgBIAMoAkICGAESLwoHaW5kaWNlcxgCIAEoCzIVLnFkcmFudC5TcGFyc2VJbmRpY2VzQgIYAUgBiAEBEh4KDXZlY3RvcnNfY291bnQYAyABKA1CAhgBSAKIAQESJAoFZGVuc2UYZSABKAsyEy5xZHJhbnQuRGVuc2VWZWN0b3JIABImCgZzcGFyc2UYZiABKAsyFC5xZHJhbnQuU3BhcnNlVmVjdG9ySAASLwoLbXVsdGlfZGVuc2UYZyABKAsyGC5xZHJhbnQuTXVsdGlEZW5zZVZlY3RvckgAQggKBnZlY3RvckIKCghfaW5kaWNlc0IQCg5fdmVjdG9yc19jb3VudCIbCgtEZW5zZVZlY3RvchIMCgRkYXRhGAEgAygCIi8KDFNwYXJzZVZlY3RvchIOCgZ2YWx1ZXMYASADKAISDwoHaW5kaWNlcxgCIAMoDSI4ChBNdWx0aURlbnNlVmVjdG9yEiQKB3ZlY3RvcnMYASADKAsyEy5xZHJhbnQuRGVuc2VWZWN0b3IipwIKC1ZlY3RvcklucHV0Eh0KAmlkGAEgASgLMg8ucWRyYW50LlBvaW50SWRIABIkCgVkZW5zZRgCIAEoCzITLnFkcmFudC5EZW5zZVZlY3RvckgAEiYKBnNwYXJzZRgDIAEoCzIULnFkcmFudC5TcGFyc2VWZWN0b3JIABIvCgttdWx0aV9kZW5zZRgEIAEoCzIYLnFkcmFudC5NdWx0aURlbnNlVmVjdG9ySAASJAoIZG9jdW1lbnQYBSABKAsyEC5xZHJhbnQuRG9jdW1lbnRIABIeCgVpbWFnZRgGIAEoCzINLnFkcmFudC5JbWFnZUgAEikKBm9iamVjdBgHIAEoCzIXLnFkcmFudC5JbmZlcmVuY2VPYmplY3RIAEIJCgd2YXJpYW50Im4KEFNoYXJkS2V5U2VsZWN0b3ISJAoKc2hhcmRfa2V5cxgBIAMoCzIQLnFkcmFudC5TaGFyZEtleRInCghmYWxsYmFjaxgCIAEoCzIQLnFkcmFudC5TaGFyZEtleUgAiAEBQgsKCV9mYWxsYmFjayKzAgoMVXBzZXJ0UG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIRCgR3YWl0GAIgASgISACIAQESIwoGcG9pbnRzGAMgAygLMhMucWRyYW50LlBvaW50U3RydWN0EiwKCG9yZGVyaW5nGAQgASgLMhUucWRyYW50LldyaXRlT3JkZXJpbmdIAYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYBSABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgCiAEBEioKDXVwZGF0ZV9maWx0ZXIYBiABKAsyDi5xZHJhbnQuRmlsdGVySAOIAQFCBwoFX3dhaXRCCwoJX29yZGVyaW5nQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCEAoOX3VwZGF0ZV9maWx0ZXIi+AEKDERlbGV0ZVBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEiYKBnBvaW50cxgDIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvchIsCghvcmRlcmluZxgEIAEoCzIVLnFkcmFudC5Xcml0ZU9yZGVyaW5nSAGIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAUgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAogBAUIHCgVfd2FpdEILCglfb3JkZXJpbmdCFQoTX3NoYXJkX2tleV9zZWxlY3RvciKFAwoJR2V0UG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIcCgNpZHMYAiADKAsyDy5xZHJhbnQuUG9pbnRJZBIxCgx3aXRoX3BheWxvYWQYBCABKAsyGy5xZHJhbnQuV2l0aFBheWxvYWRTZWxlY3RvchI2Cgx3aXRoX3ZlY3RvcnMYBSABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgAiAEBEjYKEHJlYWRfY29uc2lzdGVuY3kYBiABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SAGIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAcgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAogBARIUCgd0aW1lb3V0GAggASgESAOIAQFCDwoNX3dpdGhfdmVjdG9yc0ITChFfcmVhZF9jb25zaXN0ZW5jeUIVChNfc2hhcmRfa2V5X3NlbGVjdG9yQgoKCF90aW1lb3V0SgQIAxAEIroCChJVcGRhdGVQb2ludFZlY3RvcnMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhEKBHdhaXQYAiABKAhIAIgBARIkCgZwb2ludHMYAyADKAsyFC5xZHJhbnQuUG9pbnRWZWN0b3JzEiwKCG9yZGVyaW5nGAQgASgLMhUucWRyYW50LldyaXRlT3JkZXJpbmdIAYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYBSABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgCiAEBEioKDXVwZGF0ZV9maWx0ZXIYBiABKAsyDi5xZHJhbnQuRmlsdGVySAOIAQFCBwoFX3dhaXRCCwoJX29yZGVyaW5nQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCEAoOX3VwZGF0ZV9maWx0ZXIiTQoMUG9pbnRWZWN0b3JzEhsKAmlkGAEgASgLMg8ucWRyYW50LlBvaW50SWQSIAoHdmVjdG9ycxgCIAEoCzIPLnFkcmFudC5WZWN0b3JzIrECChJEZWxldGVQb2ludFZlY3RvcnMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhEKBHdhaXQYAiABKAhIAIgBARIvCg9wb2ludHNfc2VsZWN0b3IYAyABKAsyFi5xZHJhbnQuUG9pbnRzU2VsZWN0b3ISKAoHdmVjdG9ycxgEIAEoCzIXLnFkcmFudC5WZWN0b3JzU2VsZWN0b3ISLAoIb3JkZXJpbmcYBSABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gBiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgGIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAKIAQFCBwoFX3dhaXRCCwoJX29yZGVyaW5nQhUKE19zaGFyZF9rZXlfc2VsZWN0b3IitQMKEFNldFBheWxvYWRQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhEKBHdhaXQYAiABKAhIAIgBARI2CgdwYXlsb2FkGAMgAygLMiUucWRyYW50LlNldFBheWxvYWRQb2ludHMuUGF5bG9hZEVudHJ5EjQKD3BvaW50c19zZWxlY3RvchgFIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvckgBiAEBEiwKCG9yZGVyaW5nGAYgASgLMhUucWRyYW50LldyaXRlT3JkZXJpbmdIAogBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYByABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgDiAEBEhAKA2tleRgIIAEoCUgEiAEBGj0KDFBheWxvYWRFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBQgcKBV93YWl0QhIKEF9wb2ludHNfc2VsZWN0b3JCCwoJX29yZGVyaW5nQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCBgoEX2tleUoECAQQBSK1AgoTRGVsZXRlUGF5bG9hZFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEgwKBGtleXMYAyADKAkSNAoPcG9pbnRzX3NlbGVjdG9yGAUgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9ySAGIAQESLAoIb3JkZXJpbmcYBiABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gCiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgHIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAOIAQFCBwoFX3dhaXRCEgoQX3BvaW50c19zZWxlY3RvckILCglfb3JkZXJpbmdCFQoTX3NoYXJkX2tleV9zZWxlY3RvckoECAQQBSL+AQoSQ2xlYXJQYXlsb2FkUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIRCgR3YWl0GAIgASgISACIAQESJgoGcG9pbnRzGAMgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9yEiwKCG9yZGVyaW5nGAQgASgLMhUucWRyYW50LldyaXRlT3JkZXJpbmdIAYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYBSABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgCiAEBQgcKBV93YWl0QgsKCV9vcmRlcmluZ0IVChNfc2hhcmRfa2V5X3NlbGVjdG9yIq8CChpDcmVhdGVGaWVsZEluZGV4Q29sbGVjdGlvbhIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEhIKCmZpZWxkX25hbWUYAyABKAkSKgoKZmllbGRfdHlwZRgEIAEoDjIRLnFkcmFudC5GaWVsZFR5cGVIAYgBARI7ChJmaWVsZF9pbmRleF9wYXJhbXMYBSABKAsyGi5xZHJhbnQuUGF5bG9hZEluZGV4UGFyYW1zSAKIAQESLAoIb3JkZXJpbmcYBiABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gDiAEBQgcKBV93YWl0Qg0KC19maWVsZF90eXBlQhUKE19maWVsZF9pbmRleF9wYXJhbXNCCwoJX29yZGVyaW5nIqABChpEZWxldGVGaWVsZEluZGV4Q29sbGVjdGlvbhIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEhIKCmZpZWxkX25hbWUYAyABKAkSLAoIb3JkZXJpbmcYBCABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gBiAEBQgcKBV93YWl0QgsKCV9vcmRlcmluZyIoChZQYXlsb2FkSW5jbHVkZVNlbGVjdG9yEg4KBmZpZWxkcxgBIAMoCSIoChZQYXlsb2FkRXhjbHVkZVNlbGVjdG9yEg4KBmZpZWxkcxgBIAMoCSKhAQoTV2l0aFBheWxvYWRTZWxlY3RvchIQCgZlbmFibGUYASABKAhIABIxCgdpbmNsdWRlGAIgASgLMh4ucWRyYW50LlBheWxvYWRJbmNsdWRlU2VsZWN0b3JIABIxCgdleGNsdWRlGAMgASgLMh4ucWRyYW50LlBheWxvYWRFeGNsdWRlU2VsZWN0b3JIAEISChBzZWxlY3Rvcl9vcHRpb25zIoIBCgxOYW1lZFZlY3RvcnMSMgoHdmVjdG9ycxgBIAMoCzIhLnFkcmFudC5OYW1lZFZlY3RvcnMuVmVjdG9yc0VudHJ5Gj4KDFZlY3RvcnNFbnRyeRILCgNrZXkYASABKAkSHQoFdmFsdWUYAiABKAsyDi5xZHJhbnQuVmVjdG9yOgI4ASKUAQoSTmFtZWRWZWN0b3JzT3V0cHV0EjgKB3ZlY3RvcnMYASADKAsyJy5xZHJhbnQuTmFtZWRWZWN0b3JzT3V0cHV0LlZlY3RvcnNFbnRyeRpECgxWZWN0b3JzRW50cnkSCwoDa2V5GAEgASgJEiMKBXZhbHVlGAIgASgLMhQucWRyYW50LlZlY3Rvck91dHB1dDoCOAEiZwoHVmVjdG9ycxIgCgZ2ZWN0b3IYASABKAsyDi5xZHJhbnQuVmVjdG9ySAASJwoHdmVjdG9ycxgCIAEoCzIULnFkcmFudC5OYW1lZFZlY3RvcnNIAEIRCg92ZWN0b3JzX29wdGlvbnMieQoNVmVjdG9yc091dHB1dBImCgZ2ZWN0b3IYASABKAsyFC5xZHJhbnQuVmVjdG9yT3V0cHV0SAASLQoHdmVjdG9ycxgCIAEoCzIaLnFkcmFudC5OYW1lZFZlY3RvcnNPdXRwdXRIAEIRCg92ZWN0b3JzX29wdGlvbnMiIAoPVmVjdG9yc1NlbGVjdG9yEg0KBW5hbWVzGAEgAygJImcKE1dpdGhWZWN0b3JzU2VsZWN0b3ISEAoGZW5hYmxlGAEgASgISAASKgoHaW5jbHVkZRgCIAEoCzIXLnFkcmFudC5WZWN0b3JzU2VsZWN0b3JIAEISChBzZWxlY3Rvcl9vcHRpb25zIogBChhRdWFudGl6YXRpb25TZWFyY2hQYXJhbXMSEwoGaWdub3JlGAEgASgISACIAQESFAoHcmVzY29yZRgCIAEoCEgBiAEBEhkKDG92ZXJzYW1wbGluZxgDIAEoAUgCiAEBQgkKB19pZ25vcmVCCgoIX3Jlc2NvcmVCDwoNX292ZXJzYW1wbGluZyJlChFBY29yblNlYXJjaFBhcmFtcxITCgZlbmFibGUYASABKAhIAIgBARIcCg9tYXhfc2VsZWN0aXZpdHkYAiABKAFIAYgBAUIJCgdfZW5hYmxlQhIKEF9tYXhfc2VsZWN0aXZpdHkigQIKDFNlYXJjaFBhcmFtcxIUCgdobnN3X2VmGAEgASgESACIAQESEgoFZXhhY3QYAiABKAhIAYgBARI7CgxxdWFudGl6YXRpb24YAyABKAsyIC5xZHJhbnQuUXVhbnRpemF0aW9uU2VhcmNoUGFyYW1zSAKIAQESGQoMaW5kZXhlZF9vbmx5GAQgASgISAOIAQESLQoFYWNvcm4YBSABKAsyGS5xZHJhbnQuQWNvcm5TZWFyY2hQYXJhbXNIBIgBAUIKCghfaG5zd19lZkIICgZfZXhhY3RCDwoNX3F1YW50aXphdGlvbkIPCg1faW5kZXhlZF9vbmx5QggKBl9hY29ybiKSBQoMU2VhcmNoUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIOCgZ2ZWN0b3IYAiADKAISHgoGZmlsdGVyGAMgASgLMg4ucWRyYW50LkZpbHRlchINCgVsaW1pdBgEIAEoBBIxCgx3aXRoX3BheWxvYWQYBiABKAsyGy5xZHJhbnQuV2l0aFBheWxvYWRTZWxlY3RvchIkCgZwYXJhbXMYByABKAsyFC5xZHJhbnQuU2VhcmNoUGFyYW1zEhwKD3Njb3JlX3RocmVzaG9sZBgIIAEoAkgAiAEBEhMKBm9mZnNldBgJIAEoBEgBiAEBEhgKC3ZlY3Rvcl9uYW1lGAogASgJSAKIAQESNgoMd2l0aF92ZWN0b3JzGAsgASgLMhsucWRyYW50LldpdGhWZWN0b3JzU2VsZWN0b3JIA4gBARI2ChByZWFkX2NvbnNpc3RlbmN5GAwgASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgEiAEBEhQKB3RpbWVvdXQYDSABKARIBYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYDiABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgGiAEBEjIKDnNwYXJzZV9pbmRpY2VzGA8gASgLMhUucWRyYW50LlNwYXJzZUluZGljZXNIB4gBAUISChBfc2NvcmVfdGhyZXNob2xkQgkKB19vZmZzZXRCDgoMX3ZlY3Rvcl9uYW1lQg8KDV93aXRoX3ZlY3RvcnNCEwoRX3JlYWRfY29uc2lzdGVuY3lCCgoIX3RpbWVvdXRCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIRCg9fc3BhcnNlX2luZGljZXNKBAgFEAYiyAEKEVNlYXJjaEJhdGNoUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIrCg1zZWFyY2hfcG9pbnRzGAIgAygLMhQucWRyYW50LlNlYXJjaFBvaW50cxI2ChByZWFkX2NvbnNpc3RlbmN5GAMgASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgAiAEBEhQKB3RpbWVvdXQYBCABKARIAYgBAUITChFfcmVhZF9jb25zaXN0ZW5jeUIKCghfdGltZW91dCKyAQoKV2l0aExvb2t1cBISCgpjb2xsZWN0aW9uGAEgASgJEjYKDHdpdGhfcGF5bG9hZBgCIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9ySACIAQESNgoMd2l0aF92ZWN0b3JzGAMgASgLMhsucWRyYW50LldpdGhWZWN0b3JzU2VsZWN0b3JIAYgBAUIPCg1fd2l0aF9wYXlsb2FkQg8KDV93aXRoX3ZlY3RvcnMi1QUKEVNlYXJjaFBvaW50R3JvdXBzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIOCgZ2ZWN0b3IYAiADKAISHgoGZmlsdGVyGAMgASgLMg4ucWRyYW50LkZpbHRlchINCgVsaW1pdBgEIAEoDRIxCgx3aXRoX3BheWxvYWQYBSABKAsyGy5xZHJhbnQuV2l0aFBheWxvYWRTZWxlY3RvchIkCgZwYXJhbXMYBiABKAsyFC5xZHJhbnQuU2VhcmNoUGFyYW1zEhwKD3Njb3JlX3RocmVzaG9sZBgHIAEoAkgAiAEBEhgKC3ZlY3Rvcl9uYW1lGAggASgJSAGIAQESNgoMd2l0aF92ZWN0b3JzGAkgASgLMhsucWRyYW50LldpdGhWZWN0b3JzU2VsZWN0b3JIAogBARIQCghncm91cF9ieRgKIAEoCRISCgpncm91cF9zaXplGAsgASgNEjYKEHJlYWRfY29uc2lzdGVuY3kYDCABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SAOIAQESLAoLd2l0aF9sb29rdXAYDSABKAsyEi5xZHJhbnQuV2l0aExvb2t1cEgEiAEBEhQKB3RpbWVvdXQYDiABKARIBYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYDyABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgGiAEBEjIKDnNwYXJzZV9pbmRpY2VzGBAgASgLMhUucWRyYW50LlNwYXJzZUluZGljZXNIB4gBAUISChBfc2NvcmVfdGhyZXNob2xkQg4KDF92ZWN0b3JfbmFtZUIPCg1fd2l0aF92ZWN0b3JzQhMKEV9yZWFkX2NvbnNpc3RlbmN5Qg4KDF93aXRoX2xvb2t1cEIKCghfdGltZW91dEIVChNfc2hhcmRfa2V5X3NlbGVjdG9yQhEKD19zcGFyc2VfaW5kaWNlcyJ9CglTdGFydEZyb20SDwoFZmxvYXQYASABKAFIABIRCgdpbnRlZ2VyGAIgASgDSAASLwoJdGltZXN0YW1wGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAEhIKCGRhdGV0aW1lGAQgASgJSABCBwoFdmFsdWUiigEKB09yZGVyQnkSCwoDa2V5GAEgASgJEikKCWRpcmVjdGlvbhgCIAEoDjIRLnFkcmFudC5EaXJlY3Rpb25IAIgBARIqCgpzdGFydF9mcm9tGAMgASgLMhEucWRyYW50LlN0YXJ0RnJvbUgBiAEBQgwKCl9kaXJlY3Rpb25CDQoLX3N0YXJ0X2Zyb20ijgQKDFNjcm9sbFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSHgoGZmlsdGVyGAIgASgLMg4ucWRyYW50LkZpbHRlchIkCgZvZmZzZXQYAyABKAsyDy5xZHJhbnQuUG9pbnRJZEgAiAEBEhIKBWxpbWl0GAQgASgNSAGIAQESMQoMd2l0aF9wYXlsb2FkGAYgASgLMhsucWRyYW50LldpdGhQYXlsb2FkU2VsZWN0b3ISNgoMd2l0aF92ZWN0b3JzGAcgASgLMhsucWRyYW50LldpdGhWZWN0b3JzU2VsZWN0b3JIAogBARI2ChByZWFkX2NvbnNpc3RlbmN5GAggASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgDiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgJIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySASIAQESJgoIb3JkZXJfYnkYCiABKAsyDy5xZHJhbnQuT3JkZXJCeUgFiAEBEhQKB3RpbWVvdXQYCyABKARIBogBAUIJCgdfb2Zmc2V0QggKBl9saW1pdEIPCg1fd2l0aF92ZWN0b3JzQhMKEV9yZWFkX2NvbnNpc3RlbmN5QhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCCwoJX29yZGVyX2J5QgoKCF90aW1lb3V0SgQIBRAGIqUBCg5Mb29rdXBMb2NhdGlvbhIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSGAoLdmVjdG9yX25hbWUYAiABKAlIAIgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYAyABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgBiAEBQg4KDF92ZWN0b3JfbmFtZUIVChNfc2hhcmRfa2V5X3NlbGVjdG9yIs0GCg9SZWNvbW1lbmRQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEiEKCHBvc2l0aXZlGAIgAygLMg8ucWRyYW50LlBvaW50SWQSIQoIbmVnYXRpdmUYAyADKAsyDy5xZHJhbnQuUG9pbnRJZBIeCgZmaWx0ZXIYBCABKAsyDi5xZHJhbnQuRmlsdGVyEg0KBWxpbWl0GAUgASgEEjEKDHdpdGhfcGF5bG9hZBgHIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9yEiQKBnBhcmFtcxgIIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXMSHAoPc2NvcmVfdGhyZXNob2xkGAkgASgCSACIAQESEwoGb2Zmc2V0GAogASgESAGIAQESEgoFdXNpbmcYCyABKAlIAogBARI2Cgx3aXRoX3ZlY3RvcnMYDCABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgDiAEBEjAKC2xvb2t1cF9mcm9tGA0gASgLMhYucWRyYW50Lkxvb2t1cExvY2F0aW9uSASIAQESNgoQcmVhZF9jb25zaXN0ZW5jeRgOIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIBYgBARIwCghzdHJhdGVneRgQIAEoDjIZLnFkcmFudC5SZWNvbW1lbmRTdHJhdGVneUgGiAEBEigKEHBvc2l0aXZlX3ZlY3RvcnMYESADKAsyDi5xZHJhbnQuVmVjdG9yEigKEG5lZ2F0aXZlX3ZlY3RvcnMYEiADKAsyDi5xZHJhbnQuVmVjdG9yEhQKB3RpbWVvdXQYEyABKARIB4gBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYFCABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgIiAEBQhIKEF9zY29yZV90aHJlc2hvbGRCCQoHX29mZnNldEIICgZfdXNpbmdCDwoNX3dpdGhfdmVjdG9yc0IOCgxfbG9va3VwX2Zyb21CEwoRX3JlYWRfY29uc2lzdGVuY3lCCwoJX3N0cmF0ZWd5QgoKCF90aW1lb3V0QhUKE19zaGFyZF9rZXlfc2VsZWN0b3JKBAgGEAci0QEKFFJlY29tbWVuZEJhdGNoUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIxChByZWNvbW1lbmRfcG9pbnRzGAIgAygLMhcucWRyYW50LlJlY29tbWVuZFBvaW50cxI2ChByZWFkX2NvbnNpc3RlbmN5GAMgASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgAiAEBEhQKB3RpbWVvdXQYBCABKARIAYgBAUITChFfcmVhZF9jb25zaXN0ZW5jeUIKCghfdGltZW91dCKQBwoUUmVjb21tZW5kUG9pbnRHcm91cHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEiEKCHBvc2l0aXZlGAIgAygLMg8ucWRyYW50LlBvaW50SWQSIQoIbmVnYXRpdmUYAyADKAsyDy5xZHJhbnQuUG9pbnRJZBIeCgZmaWx0ZXIYBCABKAsyDi5xZHJhbnQuRmlsdGVyEg0KBWxpbWl0GAUgASgNEjEKDHdpdGhfcGF5bG9hZBgGIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9yEiQKBnBhcmFtcxgHIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXMSHAoPc2NvcmVfdGhyZXNob2xkGAggASgCSACIAQESEgoFdXNpbmcYCSABKAlIAYgBARI2Cgx3aXRoX3ZlY3RvcnMYCiABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgCiAEBEjAKC2xvb2t1cF9mcm9tGAsgASgLMhYucWRyYW50Lkxvb2t1cExvY2F0aW9uSAOIAQESEAoIZ3JvdXBfYnkYDCABKAkSEgoKZ3JvdXBfc2l6ZRgNIAEoDRI2ChByZWFkX2NvbnNpc3RlbmN5GA4gASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgEiAEBEiwKC3dpdGhfbG9va3VwGA8gASgLMhIucWRyYW50LldpdGhMb29rdXBIBYgBARIwCghzdHJhdGVneRgRIAEoDjIZLnFkcmFudC5SZWNvbW1lbmRTdHJhdGVneUgGiAEBEigKEHBvc2l0aXZlX3ZlY3RvcnMYEiADKAsyDi5xZHJhbnQuVmVjdG9yEigKEG5lZ2F0aXZlX3ZlY3RvcnMYEyADKAsyDi5xZHJhbnQuVmVjdG9yEhQKB3RpbWVvdXQYFCABKARIB4gBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYFSABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgIiAEBQhIKEF9zY29yZV90aHJlc2hvbGRCCAoGX3VzaW5nQg8KDV93aXRoX3ZlY3RvcnNCDgoMX2xvb2t1cF9mcm9tQhMKEV9yZWFkX2NvbnNpc3RlbmN5Qg4KDF93aXRoX2xvb2t1cEILCglfc3RyYXRlZ3lCCgoIX3RpbWVvdXRCFQoTX3NoYXJkX2tleV9zZWxlY3RvciJBCgxUYXJnZXRWZWN0b3ISJwoGc2luZ2xlGAEgASgLMhUucWRyYW50LlZlY3RvckV4YW1wbGVIAEIICgZ0YXJnZXQiWwoNVmVjdG9yRXhhbXBsZRIdCgJpZBgBIAEoCzIPLnFkcmFudC5Qb2ludElkSAASIAoGdmVjdG9yGAIgASgLMg4ucWRyYW50LlZlY3RvckgAQgkKB2V4YW1wbGUiZgoSQ29udGV4dEV4YW1wbGVQYWlyEicKCHBvc2l0aXZlGAEgASgLMhUucWRyYW50LlZlY3RvckV4YW1wbGUSJwoIbmVnYXRpdmUYAiABKAsyFS5xZHJhbnQuVmVjdG9yRXhhbXBsZSKOBQoORGlzY292ZXJQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEiQKBnRhcmdldBgCIAEoCzIULnFkcmFudC5UYXJnZXRWZWN0b3ISKwoHY29udGV4dBgDIAMoCzIaLnFkcmFudC5Db250ZXh0RXhhbXBsZVBhaXISHgoGZmlsdGVyGAQgASgLMg4ucWRyYW50LkZpbHRlchINCgVsaW1pdBgFIAEoBBIxCgx3aXRoX3BheWxvYWQYBiABKAsyGy5xZHJhbnQuV2l0aFBheWxvYWRTZWxlY3RvchIkCgZwYXJhbXMYByABKAsyFC5xZHJhbnQuU2VhcmNoUGFyYW1zEhMKBm9mZnNldBgIIAEoBEgAiAEBEhIKBXVzaW5nGAkgASgJSAGIAQESNgoMd2l0aF92ZWN0b3JzGAogASgLMhsucWRyYW50LldpdGhWZWN0b3JzU2VsZWN0b3JIAogBARIwCgtsb29rdXBfZnJvbRgLIAEoCzIWLnFkcmFudC5Mb29rdXBMb2NhdGlvbkgDiAEBEjYKEHJlYWRfY29uc2lzdGVuY3kYDCABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SASIAQESFAoHdGltZW91dBgNIAEoBEgFiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgOIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAaIAQFCCQoHX29mZnNldEIICgZfdXNpbmdCDwoNX3dpdGhfdmVjdG9yc0IOCgxfbG9va3VwX2Zyb21CEwoRX3JlYWRfY29uc2lzdGVuY3lCCgoIX3RpbWVvdXRCFQoTX3NoYXJkX2tleV9zZWxlY3RvciLOAQoTRGlzY292ZXJCYXRjaFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSLwoPZGlzY292ZXJfcG9pbnRzGAIgAygLMhYucWRyYW50LkRpc2NvdmVyUG9pbnRzEjYKEHJlYWRfY29uc2lzdGVuY3kYAyABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SACIAQESFAoHdGltZW91dBgEIAEoBEgBiAEBQhMKEV9yZWFkX2NvbnNpc3RlbmN5QgoKCF90aW1lb3V0IqUCCgtDb3VudFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSHgoGZmlsdGVyGAIgASgLMg4ucWRyYW50LkZpbHRlchISCgVleGFjdBgDIAEoCEgAiAEBEjYKEHJlYWRfY29uc2lzdGVuY3kYBCABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SAGIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAUgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAogBARIUCgd0aW1lb3V0GAYgASgESAOIAQFCCAoGX2V4YWN0QhMKEV9yZWFkX2NvbnNpc3RlbmN5QhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCCgoIX3RpbWVvdXQinQEKDlJlY29tbWVuZElucHV0EiUKCHBvc2l0aXZlGAEgAygLMhMucWRyYW50LlZlY3RvcklucHV0EiUKCG5lZ2F0aXZlGAIgAygLMhMucWRyYW50LlZlY3RvcklucHV0EjAKCHN0cmF0ZWd5GAMgASgOMhkucWRyYW50LlJlY29tbWVuZFN0cmF0ZWd5SACIAQFCCwoJX3N0cmF0ZWd5ImAKEENvbnRleHRJbnB1dFBhaXISJQoIcG9zaXRpdmUYASABKAsyEy5xZHJhbnQuVmVjdG9ySW5wdXQSJQoIbmVnYXRpdmUYAiABKAsyEy5xZHJhbnQuVmVjdG9ySW5wdXQiWwoNRGlzY292ZXJJbnB1dBIjCgZ0YXJnZXQYASABKAsyEy5xZHJhbnQuVmVjdG9ySW5wdXQSJQoHY29udGV4dBgCIAEoCzIULnFkcmFudC5Db250ZXh0SW5wdXQiNwoMQ29udGV4dElucHV0EicKBXBhaXJzGAEgAygLMhgucWRyYW50LkNvbnRleHRJbnB1dFBhaXIiogEKB0Zvcm11bGESJgoKZXhwcmVzc2lvbhgBIAEoCzISLnFkcmFudC5FeHByZXNzaW9uEi8KCGRlZmF1bHRzGAIgAygLMh0ucWRyYW50LkZvcm11bGEuRGVmYXVsdHNFbnRyeRo+Cg1EZWZhdWx0c0VudHJ5EgsKA2tleRgBIAEoCRIcCgV2YWx1ZRgCIAEoCzINLnFkcmFudC5WYWx1ZToCOAEizAUKCkV4cHJlc3Npb24SEgoIY29uc3RhbnQYASABKAJIABISCgh2YXJpYWJsZRgCIAEoCUgAEiYKCWNvbmRpdGlvbhgDIAEoCzIRLnFkcmFudC5Db25kaXRpb25IABIrCgxnZW9fZGlzdGFuY2UYBCABKAsyEy5xZHJhbnQuR2VvRGlzdGFuY2VIABISCghkYXRldGltZRgFIAEoCUgAEhYKDGRhdGV0aW1lX2tleRgGIAEoCUgAEiYKBG11bHQYByABKAsyFi5xZHJhbnQuTXVsdEV4cHJlc3Npb25IABIkCgNzdW0YCCABKAsyFS5xZHJhbnQuU3VtRXhwcmVzc2lvbkgAEiQKA2RpdhgJIAEoCzIVLnFkcmFudC5EaXZFeHByZXNzaW9uSAASIQoDbmVnGAogASgLMhIucWRyYW50LkV4cHJlc3Npb25IABIhCgNhYnMYCyABKAsyEi5xZHJhbnQuRXhwcmVzc2lvbkgAEiIKBHNxcnQYDCABKAsyEi5xZHJhbnQuRXhwcmVzc2lvbkgAEiQKA3BvdxgNIAEoCzIVLnFkcmFudC5Qb3dFeHByZXNzaW9uSAASIQoDZXhwGA4gASgLMhIucWRyYW50LkV4cHJlc3Npb25IABIjCgVsb2cxMBgPIAEoCzISLnFkcmFudC5FeHByZXNzaW9uSAASIAoCbG4YECABKAsyEi5xZHJhbnQuRXhwcmVzc2lvbkgAEjIKCWV4cF9kZWNheRgRIAEoCzIdLnFkcmFudC5EZWNheVBhcmFtc0V4cHJlc3Npb25IABI0CgtnYXVzc19kZWNheRgSIAEoCzIdLnFkcmFudC5EZWNheVBhcmFtc0V4cHJlc3Npb25IABIyCglsaW5fZGVjYXkYEyABKAsyHS5xZHJhbnQuRGVjYXlQYXJhbXNFeHByZXNzaW9uSABCCQoHdmFyaWFudCI7CgtHZW9EaXN0YW5jZRIgCgZvcmlnaW4YASABKAsyEC5xZHJhbnQuR2VvUG9pbnQSCgoCdG8YAiABKAkiMgoOTXVsdEV4cHJlc3Npb24SIAoEbXVsdBgBIAMoCzISLnFkcmFudC5FeHByZXNzaW9uIjAKDVN1bUV4cHJlc3Npb24SHwoDc3VtGAEgAygLMhIucWRyYW50LkV4cHJlc3Npb24ihgEKDURpdkV4cHJlc3Npb24SIAoEbGVmdBgBIAEoCzISLnFkcmFudC5FeHByZXNzaW9uEiEKBXJpZ2h0GAIgASgLMhIucWRyYW50LkV4cHJlc3Npb24SHAoPYnlfemVyb19kZWZhdWx0GAMgASgCSACIAQFCEgoQX2J5X3plcm9fZGVmYXVsdCJXCg1Qb3dFeHByZXNzaW9uEiAKBGJhc2UYASABKAsyEi5xZHJhbnQuRXhwcmVzc2lvbhIkCghleHBvbmVudBgCIAEoCzISLnFkcmFudC5FeHByZXNzaW9uIqwBChVEZWNheVBhcmFtc0V4cHJlc3Npb24SHQoBeBgBIAEoCzISLnFkcmFudC5FeHByZXNzaW9uEicKBnRhcmdldBgCIAEoCzISLnFkcmFudC5FeHByZXNzaW9uSACIAQESEgoFc2NhbGUYAyABKAJIAYgBARIVCghtaWRwb2ludBgEIAEoAkgCiAEBQgkKB190YXJnZXRCCAoGX3NjYWxlQgsKCV9taWRwb2ludCJVChNOZWFyZXN0SW5wdXRXaXRoTW1yEiQKB25lYXJlc3QYASABKAsyEy5xZHJhbnQuVmVjdG9ySW5wdXQSGAoDbW1yGAIgASgLMgsucWRyYW50Lk1tciJfCgNNbXISFgoJZGl2ZXJzaXR5GAIgASgCSACIAQESHQoQY2FuZGlkYXRlc19saW1pdBgDIAEoDUgBiAEBQgwKCl9kaXZlcnNpdHlCEwoRX2NhbmRpZGF0ZXNfbGltaXQiGwoDUnJmEg4KAWsYASABKA1IAIgBAUIECgJfayKdAwoFUXVlcnkSJgoHbmVhcmVzdBgBIAEoCzITLnFkcmFudC5WZWN0b3JJbnB1dEgAEisKCXJlY29tbWVuZBgCIAEoCzIWLnFkcmFudC5SZWNvbW1lbmRJbnB1dEgAEikKCGRpc2NvdmVyGAMgASgLMhUucWRyYW50LkRpc2NvdmVySW5wdXRIABInCgdjb250ZXh0GAQgASgLMhQucWRyYW50LkNvbnRleHRJbnB1dEgAEiMKCG9yZGVyX2J5GAUgASgLMg8ucWRyYW50Lk9yZGVyQnlIABIgCgZmdXNpb24YBiABKA4yDi5xZHJhbnQuRnVzaW9uSAASIAoGc2FtcGxlGAcgASgOMg4ucWRyYW50LlNhbXBsZUgAEiIKB2Zvcm11bGEYCCABKAsyDy5xZHJhbnQuRm9ybXVsYUgAEjcKEG5lYXJlc3Rfd2l0aF9tbXIYCSABKAsyGy5xZHJhbnQuTmVhcmVzdElucHV0V2l0aE1tckgAEhoKA3JyZhgKIAEoCzILLnFkcmFudC5ScmZIAEIJCgd2YXJpYW50IvsCCg1QcmVmZXRjaFF1ZXJ5EicKCHByZWZldGNoGAEgAygLMhUucWRyYW50LlByZWZldGNoUXVlcnkSIQoFcXVlcnkYAiABKAsyDS5xZHJhbnQuUXVlcnlIAIgBARISCgV1c2luZxgDIAEoCUgBiAEBEiMKBmZpbHRlchgEIAEoCzIOLnFkcmFudC5GaWx0ZXJIAogBARIpCgZwYXJhbXMYBSABKAsyFC5xZHJhbnQuU2VhcmNoUGFyYW1zSAOIAQESHAoPc2NvcmVfdGhyZXNob2xkGAYgASgCSASIAQESEgoFbGltaXQYByABKARIBYgBARIwCgtsb29rdXBfZnJvbRgIIAEoCzIWLnFkcmFudC5Mb29rdXBMb2NhdGlvbkgGiAEBQggKBl9xdWVyeUIICgZfdXNpbmdCCQoHX2ZpbHRlckIJCgdfcGFyYW1zQhIKEF9zY29yZV90aHJlc2hvbGRCCAoGX2xpbWl0Qg4KDF9sb29rdXBfZnJvbSKFBgoLUXVlcnlQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEicKCHByZWZldGNoGAIgAygLMhUucWRyYW50LlByZWZldGNoUXVlcnkSIQoFcXVlcnkYAyABKAsyDS5xZHJhbnQuUXVlcnlIAIgBARISCgV1c2luZxgEIAEoCUgBiAEBEiMKBmZpbHRlchgFIAEoCzIOLnFkcmFudC5GaWx0ZXJIAogBARIpCgZwYXJhbXMYBiABKAsyFC5xZHJhbnQuU2VhcmNoUGFyYW1zSAOIAQESHAoPc2NvcmVfdGhyZXNob2xkGAcgASgCSASIAQESEgoFbGltaXQYCCABKARIBYgBARITCgZvZmZzZXQYCSABKARIBogBARI2Cgx3aXRoX3ZlY3RvcnMYCiABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgHiAEBEjYKDHdpdGhfcGF5bG9hZBgLIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9ySAiIAQESNgoQcmVhZF9jb25zaXN0ZW5jeRgMIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lICYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYDSABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgKiAEBEjAKC2xvb2t1cF9mcm9tGA4gASgLMhYucWRyYW50Lkxvb2t1cExvY2F0aW9uSAuIAQESFAoHdGltZW91dBgPIAEoBEgMiAEBQggKBl9xdWVyeUIICgZfdXNpbmdCCQoHX2ZpbHRlckIJCgdfcGFyYW1zQhIKEF9zY29yZV90aHJlc2hvbGRCCAoGX2xpbWl0QgkKB19vZmZzZXRCDwoNX3dpdGhfdmVjdG9yc0IPCg1fd2l0aF9wYXlsb2FkQhMKEV9yZWFkX2NvbnNpc3RlbmN5QhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCDgoMX2xvb2t1cF9mcm9tQgoKCF90aW1lb3V0IsUBChBRdWVyeUJhdGNoUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIpCgxxdWVyeV9wb2ludHMYAiADKAsyEy5xZHJhbnQuUXVlcnlQb2ludHMSNgoQcmVhZF9jb25zaXN0ZW5jeRgDIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIAIgBARIUCgd0aW1lb3V0GAQgASgESAGIAQFCEwoRX3JlYWRfY29uc2lzdGVuY3lCCgoIX3RpbWVvdXQizAYKEFF1ZXJ5UG9pbnRHcm91cHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEicKCHByZWZldGNoGAIgAygLMhUucWRyYW50LlByZWZldGNoUXVlcnkSIQoFcXVlcnkYAyABKAsyDS5xZHJhbnQuUXVlcnlIAIgBARISCgV1c2luZxgEIAEoCUgBiAEBEiMKBmZpbHRlchgFIAEoCzIOLnFkcmFudC5GaWx0ZXJIAogBARIpCgZwYXJhbXMYBiABKAsyFC5xZHJhbnQuU2VhcmNoUGFyYW1zSAOIAQESHAoPc2NvcmVfdGhyZXNob2xkGAcgASgCSASIAQESMQoMd2l0aF9wYXlsb2FkGAggASgLMhsucWRyYW50LldpdGhQYXlsb2FkU2VsZWN0b3ISNgoMd2l0aF92ZWN0b3JzGAkgASgLMhsucWRyYW50LldpdGhWZWN0b3JzU2VsZWN0b3JIBYgBARIwCgtsb29rdXBfZnJvbRgKIAEoCzIWLnFkcmFudC5Mb29rdXBMb2NhdGlvbkgGiAEBEhIKBWxpbWl0GAsgASgESAeIAQESFwoKZ3JvdXBfc2l6ZRgMIAEoBEgIiAEBEhAKCGdyb3VwX2J5GA0gASgJEjYKEHJlYWRfY29uc2lzdGVuY3kYDiABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SAmIAQESLAoLd2l0aF9sb29rdXAYDyABKAsyEi5xZHJhbnQuV2l0aExvb2t1cEgKiAEBEhQKB3RpbWVvdXQYECABKARIC4gBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYESABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgMiAEBQggKBl9xdWVyeUIICgZfdXNpbmdCCQoHX2ZpbHRlckIJCgdfcGFyYW1zQhIKEF9zY29yZV90aHJlc2hvbGRCDwoNX3dpdGhfdmVjdG9yc0IOCgxfbG9va3VwX2Zyb21CCAoGX2xpbWl0Qg0KC19ncm91cF9zaXplQhMKEV9yZWFkX2NvbnNpc3RlbmN5Qg4KDF93aXRoX2xvb2t1cEIKCghfdGltZW91dEIVChNfc2hhcmRfa2V5X3NlbGVjdG9yIuACCgtGYWNldENvdW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSCwoDa2V5GAIgASgJEiMKBmZpbHRlchgDIAEoCzIOLnFkcmFudC5GaWx0ZXJIAIgBARISCgVsaW1pdBgEIAEoBEgBiAEBEhIKBWV4YWN0GAUgASgISAKIAQESFAoHdGltZW91dBgGIAEoBEgDiAEBEjYKEHJlYWRfY29uc2lzdGVuY3kYByABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SASIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAggASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIBYgBAUIJCgdfZmlsdGVyQggKBl9saW1pdEIICgZfZXhhY3RCCgoIX3RpbWVvdXRCEwoRX3JlYWRfY29uc2lzdGVuY3lCFQoTX3NoYXJkX2tleV9zZWxlY3RvciJeCgpGYWNldFZhbHVlEhYKDHN0cmluZ192YWx1ZRgBIAEoCUgAEhcKDWludGVnZXJfdmFsdWUYAiABKANIABIUCgpib29sX3ZhbHVlGAMgASgISABCCQoHdmFyaWFudCI8CghGYWNldEhpdBIhCgV2YWx1ZRgBIAEoCzISLnFkcmFudC5GYWNldFZhbHVlEg0KBWNvdW50GAIgASgEIvoCChJTZWFyY2hNYXRyaXhQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEiMKBmZpbHRlchgCIAEoCzIOLnFkcmFudC5GaWx0ZXJIAIgBARITCgZzYW1wbGUYAyABKARIAYgBARISCgVsaW1pdBgEIAEoBEgCiAEBEhIKBXVzaW5nGAUgASgJSAOIAQESFAoHdGltZW91dBgGIAEoBEgEiAEBEjYKEHJlYWRfY29uc2lzdGVuY3kYByABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SAWIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAggASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIBogBAUIJCgdfZmlsdGVyQgkKB19zYW1wbGVCCAoGX2xpbWl0QggKBl91c2luZ0IKCghfdGltZW91dEITChFfcmVhZF9jb25zaXN0ZW5jeUIVChNfc2hhcmRfa2V5X3NlbGVjdG9yIjwKEVNlYXJjaE1hdHJpeFBhaXJzEicKBXBhaXJzGAEgAygLMhgucWRyYW50LlNlYXJjaE1hdHJpeFBhaXIiWQoQU2VhcmNoTWF0cml4UGFpchIaCgFhGAEgASgLMg8ucWRyYW50LlBvaW50SWQSGgoBYhgCIAEoCzIPLnFkcmFudC5Qb2ludElkEg0KBXNjb3JlGAMgASgCIm0KE1NlYXJjaE1hdHJpeE9mZnNldHMSEwoLb2Zmc2V0c19yb3cYASADKAQSEwoLb2Zmc2V0c19jb2wYAiADKAQSDgoGc2NvcmVzGAMgAygCEhwKA2lkcxgEIAMoCzIPLnFkcmFudC5Qb2ludElkIpETChVQb2ludHNVcGRhdGVPcGVyYXRpb24SPwoGdXBzZXJ0GAEgASgLMi0ucWRyYW50LlBvaW50c1VwZGF0ZU9wZXJhdGlvbi5Qb2ludFN0cnVjdExpc3RIABI3ChFkZWxldGVfZGVwcmVjYXRlZBgCIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvckICGAFIABI/CgtzZXRfcGF5bG9hZBgDIAEoCzIoLnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uU2V0UGF5bG9hZEgAEksKEW92ZXJ3cml0ZV9wYXlsb2FkGAQgASgLMi4ucWRyYW50LlBvaW50c1VwZGF0ZU9wZXJhdGlvbi5PdmVyd3JpdGVQYXlsb2FkSAASRQoOZGVsZXRlX3BheWxvYWQYBSABKAsyKy5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uLkRlbGV0ZVBheWxvYWRIABI+ChhjbGVhcl9wYXlsb2FkX2RlcHJlY2F0ZWQYBiABKAsyFi5xZHJhbnQuUG9pbnRzU2VsZWN0b3JCAhgBSAASRQoOdXBkYXRlX3ZlY3RvcnMYByABKAsyKy5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uLlVwZGF0ZVZlY3RvcnNIABJFCg5kZWxldGVfdmVjdG9ycxgIIAEoCzIrLnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uRGVsZXRlVmVjdG9yc0gAEkMKDWRlbGV0ZV9wb2ludHMYCSABKAsyKi5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uLkRlbGV0ZVBvaW50c0gAEkMKDWNsZWFyX3BheWxvYWQYCiABKAsyKi5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uLkNsZWFyUGF5bG9hZEgAGsYBCg9Qb2ludFN0cnVjdExpc3QSIwoGcG9pbnRzGAEgAygLMhMucWRyYW50LlBvaW50U3RydWN0EjkKEnNoYXJkX2tleV9zZWxlY3RvchgCIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySACIAQESKgoNdXBkYXRlX2ZpbHRlchgDIAEoCzIOLnFkcmFudC5GaWx0ZXJIAYgBAUIVChNfc2hhcmRfa2V5X3NlbGVjdG9yQhAKDl91cGRhdGVfZmlsdGVyGskCCgpTZXRQYXlsb2FkEkYKB3BheWxvYWQYASADKAsyNS5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uLlNldFBheWxvYWQuUGF5bG9hZEVudHJ5EjQKD3BvaW50c19zZWxlY3RvchgCIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvckgAiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgDIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAGIAQESEAoDa2V5GAQgASgJSAKIAQEaPQoMUGF5bG9hZEVudHJ5EgsKA2tleRgBIAEoCRIcCgV2YWx1ZRgCIAEoCzINLnFkcmFudC5WYWx1ZToCOAFCEgoQX3BvaW50c19zZWxlY3RvckIVChNfc2hhcmRfa2V5X3NlbGVjdG9yQgYKBF9rZXka1QIKEE92ZXJ3cml0ZVBheWxvYWQSTAoHcGF5bG9hZBgBIAMoCzI7LnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uT3ZlcndyaXRlUGF5bG9hZC5QYXlsb2FkRW50cnkSNAoPcG9pbnRzX3NlbGVjdG9yGAIgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9ySACIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAMgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAYgBARIQCgNrZXkYBCABKAlIAogBARo9CgxQYXlsb2FkRW50cnkSCwoDa2V5GAEgASgJEhwKBXZhbHVlGAIgASgLMg0ucWRyYW50LlZhbHVlOgI4AUISChBfcG9pbnRzX3NlbGVjdG9yQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCBgoEX2tleRq5AQoNRGVsZXRlUGF5bG9hZBIMCgRrZXlzGAEgAygJEjQKD3BvaW50c19zZWxlY3RvchgCIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvckgAiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgDIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAGIAQFCEgoQX3BvaW50c19zZWxlY3RvckIVChNfc2hhcmRfa2V5X3NlbGVjdG9yGsUBCg1VcGRhdGVWZWN0b3JzEiQKBnBvaW50cxgBIAMoCzIULnFkcmFudC5Qb2ludFZlY3RvcnMSOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAIgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAIgBARIqCg11cGRhdGVfZmlsdGVyGAMgASgLMg4ucWRyYW50LkZpbHRlckgBiAEBQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCEAoOX3VwZGF0ZV9maWx0ZXIavAEKDURlbGV0ZVZlY3RvcnMSLwoPcG9pbnRzX3NlbGVjdG9yGAEgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9yEigKB3ZlY3RvcnMYAiABKAsyFy5xZHJhbnQuVmVjdG9yc1NlbGVjdG9yEjkKEnNoYXJkX2tleV9zZWxlY3RvchgDIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySACIAQFCFQoTX3NoYXJkX2tleV9zZWxlY3RvchqIAQoMRGVsZXRlUG9pbnRzEiYKBnBvaW50cxgBIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvchI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYAiABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgAiAEBQhUKE19zaGFyZF9rZXlfc2VsZWN0b3IaiAEKDENsZWFyUGF5bG9hZBImCgZwb2ludHMYASABKAsyFi5xZHJhbnQuUG9pbnRzU2VsZWN0b3ISOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAIgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAIgBAUIVChNfc2hhcmRfa2V5X3NlbGVjdG9yQgsKCW9wZXJhdGlvbiK2AQoRVXBkYXRlQmF0Y2hQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhEKBHdhaXQYAiABKAhIAIgBARIxCgpvcGVyYXRpb25zGAMgAygLMh0ucWRyYW50LlBvaW50c1VwZGF0ZU9wZXJhdGlvbhIsCghvcmRlcmluZxgEIAEoCzIVLnFkcmFudC5Xcml0ZU9yZGVyaW5nSAGIAQFCBwoFX3dhaXRCCwoJX29yZGVyaW5nInoKF1BvaW50c09wZXJhdGlvblJlc3BvbnNlEiQKBnJlc3VsdBgBIAEoCzIULnFkcmFudC5VcGRhdGVSZXN1bHQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJgCgxVcGRhdGVSZXN1bHQSGQoMb3BlcmF0aW9uX2lkGAEgASgESACIAQESJAoGc3RhdHVzGAIgASgOMhQucWRyYW50LlVwZGF0ZVN0YXR1c0IPCg1fb3BlcmF0aW9uX2lkIjcKCk9yZGVyVmFsdWUSDQoDaW50GAEgASgDSAASDwoFZmxvYXQYAiABKAFIAEIJCgd2YXJpYW50IvECCgtTY29yZWRQb2ludBIbCgJpZBgBIAEoCzIPLnFkcmFudC5Qb2ludElkEjEKB3BheWxvYWQYAiADKAsyIC5xZHJhbnQuU2NvcmVkUG9pbnQuUGF5bG9hZEVudHJ5Eg0KBXNjb3JlGAMgASgCEg8KB3ZlcnNpb24YBSABKAQSKwoHdmVjdG9ycxgGIAEoCzIVLnFkcmFudC5WZWN0b3JzT3V0cHV0SACIAQESKAoJc2hhcmRfa2V5GAcgASgLMhAucWRyYW50LlNoYXJkS2V5SAGIAQESLAoLb3JkZXJfdmFsdWUYCCABKAsyEi5xZHJhbnQuT3JkZXJWYWx1ZUgCiAEBGj0KDFBheWxvYWRFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBQgoKCF92ZWN0b3JzQgwKCl9zaGFyZF9rZXlCDgoMX29yZGVyX3ZhbHVlSgQIBBAFIlwKB0dyb3VwSWQSGAoOdW5zaWduZWRfdmFsdWUYASABKARIABIXCg1pbnRlZ2VyX3ZhbHVlGAIgASgDSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSABCBgoEa2luZCJ0CgpQb2ludEdyb3VwEhsKAmlkGAEgASgLMg8ucWRyYW50Lkdyb3VwSWQSIQoEaGl0cxgCIAMoCzITLnFkcmFudC5TY29yZWRQb2ludBImCgZsb29rdXAYAyABKAsyFi5xZHJhbnQuUmV0cmlldmVkUG9pbnQiMgoMR3JvdXBzUmVzdWx0EiIKBmdyb3VwcxgBIAMoCzISLnFkcmFudC5Qb2ludEdyb3VwInAKDlNlYXJjaFJlc3BvbnNlEiMKBnJlc3VsdBgBIAMoCzITLnFkcmFudC5TY29yZWRQb2ludBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlIm8KDVF1ZXJ5UmVzcG9uc2USIwoGcmVzdWx0GAEgAygLMhMucWRyYW50LlNjb3JlZFBvaW50EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UidAoSUXVlcnlCYXRjaFJlc3BvbnNlEiMKBnJlc3VsdBgBIAMoCzITLnFkcmFudC5CYXRjaFJlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlInYKE1F1ZXJ5R3JvdXBzUmVzcG9uc2USJAoGcmVzdWx0GAEgASgLMhQucWRyYW50Lkdyb3Vwc1Jlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlIjIKC0JhdGNoUmVzdWx0EiMKBnJlc3VsdBgBIAMoCzITLnFkcmFudC5TY29yZWRQb2ludCJ1ChNTZWFyY2hCYXRjaFJlc3BvbnNlEiMKBnJlc3VsdBgBIAMoCzITLnFkcmFudC5CYXRjaFJlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlIncKFFNlYXJjaEdyb3Vwc1Jlc3BvbnNlEiQKBnJlc3VsdBgBIAEoCzIULnFkcmFudC5Hcm91cHNSZXN1bHQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJvCg1Db3VudFJlc3BvbnNlEiMKBnJlc3VsdBgBIAEoCzITLnFkcmFudC5Db3VudFJlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlIrgBCg5TY3JvbGxSZXNwb25zZRIuChBuZXh0X3BhZ2Vfb2Zmc2V0GAEgASgLMg8ucWRyYW50LlBvaW50SWRIAIgBARImCgZyZXN1bHQYAiADKAsyFi5xZHJhbnQuUmV0cmlldmVkUG9pbnQSDAoEdGltZRgDIAEoARIhCgV1c2FnZRgEIAEoCzINLnFkcmFudC5Vc2FnZUgBiAEBQhMKEV9uZXh0X3BhZ2Vfb2Zmc2V0QggKBl91c2FnZSIcCgtDb3VudFJlc3VsdBINCgVjb3VudBgBIAEoBCLXAgoOUmV0cmlldmVkUG9pbnQSGwoCaWQYASABKAsyDy5xZHJhbnQuUG9pbnRJZBI0CgdwYXlsb2FkGAIgAygLMiMucWRyYW50LlJldHJpZXZlZFBvaW50LlBheWxvYWRFbnRyeRIrCgd2ZWN0b3JzGAQgASgLMhUucWRyYW50LlZlY3RvcnNPdXRwdXRIAIgBARIoCglzaGFyZF9rZXkYBSABKAsyEC5xZHJhbnQuU2hhcmRLZXlIAYgBARIsCgtvcmRlcl92YWx1ZRgGIAEoCzISLnFkcmFudC5PcmRlclZhbHVlSAKIAQEaPQoMUGF5bG9hZEVudHJ5EgsKA2tleRgBIAEoCRIcCgV2YWx1ZRgCIAEoCzINLnFkcmFudC5WYWx1ZToCOAFCCgoIX3ZlY3RvcnNCDAoKX3NoYXJkX2tleUIOCgxfb3JkZXJfdmFsdWVKBAgDEAQicAoLR2V0UmVzcG9uc2USJgoGcmVzdWx0GAEgAygLMhYucWRyYW50LlJldHJpZXZlZFBvaW50EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UicwoRUmVjb21tZW5kUmVzcG9uc2USIwoGcmVzdWx0GAEgAygLMhMucWRyYW50LlNjb3JlZFBvaW50EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UieAoWUmVjb21tZW5kQmF0Y2hSZXNwb25zZRIjCgZyZXN1bHQYASADKAsyEy5xZHJhbnQuQmF0Y2hSZXN1bHQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJyChBEaXNjb3ZlclJlc3BvbnNlEiMKBnJlc3VsdBgBIAMoCzITLnFkcmFudC5TY29yZWRQb2ludBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlIncKFURpc2NvdmVyQmF0Y2hSZXNwb25zZRIjCgZyZXN1bHQYASADKAsyEy5xZHJhbnQuQmF0Y2hSZXN1bHQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJ6ChdSZWNvbW1lbmRHcm91cHNSZXNwb25zZRIkCgZyZXN1bHQYASABKAsyFC5xZHJhbnQuR3JvdXBzUmVzdWx0EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UidgoTVXBkYXRlQmF0Y2hSZXNwb25zZRIkCgZyZXN1bHQYASADKAsyFC5xZHJhbnQuVXBkYXRlUmVzdWx0EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UiagoNRmFjZXRSZXNwb25zZRIeCgRoaXRzGAEgAygLMhAucWRyYW50LkZhY2V0SGl0EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UigQEKGVNlYXJjaE1hdHJpeFBhaXJzUmVzcG9uc2USKQoGcmVzdWx0GAEgASgLMhkucWRyYW50LlNlYXJjaE1hdHJpeFBhaXJzEgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UihQEKG1NlYXJjaE1hdHJpeE9mZnNldHNSZXNwb25zZRIrCgZyZXN1bHQYASABKAsyGy5xZHJhbnQuU2VhcmNoTWF0cml4T2Zmc2V0cxIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlInUKDlBvaW50c1NlbGVjdG9yEicKBnBvaW50cxgBIAEoCzIVLnFkcmFudC5Qb2ludHNJZHNMaXN0SAASIAoGZmlsdGVyGAIgASgLMg4ucWRyYW50LkZpbHRlckgAQhgKFnBvaW50c19zZWxlY3Rvcl9vbmVfb2YiLQoNUG9pbnRzSWRzTGlzdBIcCgNpZHMYASADKAsyDy5xZHJhbnQuUG9pbnRJZCLVAQoLUG9pbnRTdHJ1Y3QSGwoCaWQYASABKAsyDy5xZHJhbnQuUG9pbnRJZBIxCgdwYXlsb2FkGAMgAygLMiAucWRyYW50LlBvaW50U3RydWN0LlBheWxvYWRFbnRyeRIlCgd2ZWN0b3JzGAQgASgLMg8ucWRyYW50LlZlY3RvcnNIAIgBARo9CgxQYXlsb2FkRW50cnkSCwoDa2V5GAEgASgJEhwKBXZhbHVlGAIgASgLMg0ucWRyYW50LlZhbHVlOgI4AUIKCghfdmVjdG9yc0oECAIQAyKAAQoFVXNhZ2USLAoIaGFyZHdhcmUYASABKAsyFS5xZHJhbnQuSGFyZHdhcmVVc2FnZUgAiAEBEi4KCWluZmVyZW5jZRgCIAEoCzIWLnFkcmFudC5JbmZlcmVuY2VVc2FnZUgBiAEBQgsKCV9oYXJkd2FyZUIMCgpfaW5mZXJlbmNlIocBCg5JbmZlcmVuY2VVc2FnZRIyCgZtb2RlbHMYASADKAsyIi5xZHJhbnQuSW5mZXJlbmNlVXNhZ2UuTW9kZWxzRW50cnkaQQoLTW9kZWxzRW50cnkSCwoDa2V5GAEgASgJEiEKBXZhbHVlGAIgASgLMhIucWRyYW50Lk1vZGVsVXNhZ2U6AjgBIhwKCk1vZGVsVXNhZ2USDgoGdG9rZW5zGAEgASgEIr8BCg1IYXJkd2FyZVVzYWdlEgsKA2NwdRgBIAEoBBIXCg9wYXlsb2FkX2lvX3JlYWQYAiABKAQSGAoQcGF5bG9hZF9pb193cml0ZRgDIAEoBBIdChVwYXlsb2FkX2luZGV4X2lvX3JlYWQYBCABKAQSHgoWcGF5bG9hZF9pbmRleF9pb193cml0ZRgFIAEoBBIWCg52ZWN0b3JfaW9fcmVhZBgGIAEoBBIXCg92ZWN0b3JfaW9fd3JpdGUYByABKAQqNQoRV3JpdGVPcmRlcmluZ1R5cGUSCAoEV2VhaxAAEgoKBk1lZGl1bRABEgoKBlN0cm9uZxACKjgKE1JlYWRDb25zaXN0ZW5jeVR5cGUSBwoDQWxsEAASDAoITWFqb3JpdHkQARIKCgZRdW9ydW0QAiqtAQoJRmllbGRUeXBlEhQKEEZpZWxkVHlwZUtleXdvcmQQABIUChBGaWVsZFR5cGVJbnRlZ2VyEAESEgoORmllbGRUeXBlRmxvYXQQAhIQCgxGaWVsZFR5cGVHZW8QAxIRCg1GaWVsZFR5cGVUZXh0EAQSEQoNRmllbGRUeXBlQm9vbBAFEhUKEUZpZWxkVHlwZURhdGV0aW1lEAYSEQoNRmllbGRUeXBlVXVpZBAHKh4KCURpcmVjdGlvbhIHCgNBc2MQABIICgREZXNjEAEqRAoRUmVjb21tZW5kU3RyYXRlZ3kSEQoNQXZlcmFnZVZlY3RvchAAEg0KCUJlc3RTY29yZRABEg0KCVN1bVNjb3JlcxACKhsKBkZ1c2lvbhIHCgNSUkYQABIICgREQlNGEAEqFAoGU2FtcGxlEgoKBlJhbmRvbRAAKlsKDFVwZGF0ZVN0YXR1cxIXChNVbmtub3duVXBkYXRlU3RhdHVzEAASEAoMQWNrbm93bGVkZ2VkEAESDQoJQ29tcGxldGVkEAISEQoNQ2xvY2tSZWplY3RlZBADQhWqAhJRZHJhbnQuQ2xpZW50LkdycGNiBnByb3RvMw", [file_collections, file_common, file_google_protobuf_timestamp, file_json_with_int]);

/**
 * @generated from message qdrant.WriteOrdering
 */
export type WriteOrdering = Message<"qdrant.WriteOrdering"> & {
  /**
   * Write ordering guarantees
   *
   * @generated from field: qdrant.WriteOrderingType type = 1;
   */
  type: WriteOrderingType;
};

/**
 * Describes the message qdrant.WriteOrdering.
 * Use `create(WriteOrderingSchema)` to create a new message.
 */
export const WriteOrderingSchema: GenMessage<WriteOrdering> = /*@__PURE__*/
  messageDesc(file_points, 0);

/**
 * @generated from message qdrant.ReadConsistency
 */
export type ReadConsistency = Message<"qdrant.ReadConsistency"> & {
  /**
   * @generated from oneof qdrant.ReadConsistency.value
   */
  value: {
    /**
     * Common read consistency configurations
     *
     * @generated from field: qdrant.ReadConsistencyType type = 1;
     */
    value: ReadConsistencyType;
    case: "type";
  } | {
    /**
     * Send request to a specified number of nodes, and return points which are present on all of them
     *
     * @generated from field: uint64 factor = 2;
     */
    value: bigint;
    case: "factor";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.ReadConsistency.
 * Use `create(ReadConsistencySchema)` to create a new message.
 */
export const ReadConsistencySchema: GenMessage<ReadConsistency> = /*@__PURE__*/
  messageDesc(file_points, 1);

/**
 * @generated from message qdrant.SparseIndices
 */
export type SparseIndices = Message<"qdrant.SparseIndices"> & {
  /**
   * @generated from field: repeated uint32 data = 1;
   */
  data: number[];
};

/**
 * Describes the message qdrant.SparseIndices.
 * Use `create(SparseIndicesSchema)` to create a new message.
 */
export const SparseIndicesSchema: GenMessage<SparseIndices> = /*@__PURE__*/
  messageDesc(file_points, 2);

/**
 * @generated from message qdrant.Document
 */
export type Document = Message<"qdrant.Document"> & {
  /**
   * Text of the document
   *
   * @generated from field: string text = 1;
   */
  text: string;

  /**
   * Model name
   *
   * @generated from field: string model = 3;
   */
  model: string;

  /**
   * Model options
   *
   * @generated from field: map<string, qdrant.Value> options = 4;
   */
  options: { [key: string]: Value };
};

/**
 * Describes the message qdrant.Document.
 * Use `create(DocumentSchema)` to create a new message.
 */
export const DocumentSchema: GenMessage<Document> = /*@__PURE__*/
  messageDesc(file_points, 3);

/**
 * @generated from message qdrant.Image
 */
export type Image = Message<"qdrant.Image"> & {
  /**
   * Image data, either base64 encoded or URL
   *
   * @generated from field: qdrant.Value image = 1;
   */
  image?: Value;

  /**
   * Model name
   *
   * @generated from field: string model = 2;
   */
  model: string;

  /**
   * Model options
   *
   * @generated from field: map<string, qdrant.Value> options = 3;
   */
  options: { [key: string]: Value };
};

/**
 * Describes the message qdrant.Image.
 * Use `create(ImageSchema)` to create a new message.
 */
export const ImageSchema: GenMessage<Image> = /*@__PURE__*/
  messageDesc(file_points, 4);

/**
 * @generated from message qdrant.InferenceObject
 */
export type InferenceObject = Message<"qdrant.InferenceObject"> & {
  /**
   * Object to infer
   *
   * @generated from field: qdrant.Value object = 1;
   */
  object?: Value;

  /**
   * Model name
   *
   * @generated from field: string model = 2;
   */
  model: string;

  /**
   * Model options
   *
   * @generated from field: map<string, qdrant.Value> options = 3;
   */
  options: { [key: string]: Value };
};

/**
 * Describes the message qdrant.InferenceObject.
 * Use `create(InferenceObjectSchema)` to create a new message.
 */
export const InferenceObjectSchema: GenMessage<InferenceObject> = /*@__PURE__*/
  messageDesc(file_points, 5);

/**
 * @generated from message qdrant.Vector
 */
export type Vector = Message<"qdrant.Vector"> & {
  /**
   * Vector data (flatten for multi vectors), deprecated
   *
   * @generated from field: repeated float data = 1 [deprecated = true];
   * @deprecated
   */
  data: number[];

  /**
   * Sparse indices for sparse vectors, deprecated
   *
   * @generated from field: optional qdrant.SparseIndices indices = 2 [deprecated = true];
   * @deprecated
   */
  indices?: SparseIndices;

  /**
   * Number of vectors per multi vector, deprecated
   *
   * @generated from field: optional uint32 vectors_count = 3 [deprecated = true];
   * @deprecated
   */
  vectorsCount?: number;

  /**
   * @generated from oneof qdrant.Vector.vector
   */
  vector: {
    /**
     * Dense vector
     *
     * @generated from field: qdrant.DenseVector dense = 101;
     */
    value: DenseVector;
    case: "dense";
  } | {
    /**
     * Sparse vector
     *
     * @generated from field: qdrant.SparseVector sparse = 102;
     */
    value: SparseVector;
    case: "sparse";
  } | {
    /**
     * Multi dense vector
     *
     * @generated from field: qdrant.MultiDenseVector multi_dense = 103;
     */
    value: MultiDenseVector;
    case: "multiDense";
  } | {
    /**
     * @generated from field: qdrant.Document document = 104;
     */
    value: Document;
    case: "document";
  } | {
    /**
     * @generated from field: qdrant.Image image = 105;
     */
    value: Image;
    case: "image";
  } | {
    /**
     * @generated from field: qdrant.InferenceObject object = 106;
     */
    value: InferenceObject;
    case: "object";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Vector.
 * Use `create(VectorSchema)` to create a new message.
 */
export const VectorSchema: GenMessage<Vector> = /*@__PURE__*/
  messageDesc(file_points, 6);

/**
 * @generated from message qdrant.VectorOutput
 */
export type VectorOutput = Message<"qdrant.VectorOutput"> & {
  /**
   * Vector data (flatten for multi vectors), deprecated
   *
   * @generated from field: repeated float data = 1 [deprecated = true];
   * @deprecated
   */
  data: number[];

  /**
   * Sparse indices for sparse vectors, deprecated
   *
   * @generated from field: optional qdrant.SparseIndices indices = 2 [deprecated = true];
   * @deprecated
   */
  indices?: SparseIndices;

  /**
   * Number of vectors per multi vector, deprecated
   *
   * @generated from field: optional uint32 vectors_count = 3 [deprecated = true];
   * @deprecated
   */
  vectorsCount?: number;

  /**
   * @generated from oneof qdrant.VectorOutput.vector
   */
  vector: {
    /**
     * Dense vector
     *
     * @generated from field: qdrant.DenseVector dense = 101;
     */
    value: DenseVector;
    case: "dense";
  } | {
    /**
     * Sparse vector
     *
     * @generated from field: qdrant.SparseVector sparse = 102;
     */
    value: SparseVector;
    case: "sparse";
  } | {
    /**
     * Multi dense vector
     *
     * @generated from field: qdrant.MultiDenseVector multi_dense = 103;
     */
    value: MultiDenseVector;
    case: "multiDense";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorOutput.
 * Use `create(VectorOutputSchema)` to create a new message.
 */
export const VectorOutputSchema: GenMessage<VectorOutput> = /*@__PURE__*/
  messageDesc(file_points, 7);

/**
 * @generated from message qdrant.DenseVector
 */
export type DenseVector = Message<"qdrant.DenseVector"> & {
  /**
   * @generated from field: repeated float data = 1;
   */
  data: number[];
};

/**
 * Describes the message qdrant.DenseVector.
 * Use `create(DenseVectorSchema)` to create a new message.
 */
export const DenseVectorSchema: GenMessage<DenseVector> = /*@__PURE__*/
  messageDesc(file_points, 8);

/**
 * @generated from message qdrant.SparseVector
 */
export type SparseVector = Message<"qdrant.SparseVector"> & {
  /**
   * @generated from field: repeated float values = 1;
   */
  values: number[];

  /**
   * @generated from field: repeated uint32 indices = 2;
   */
  indices: number[];
};

/**
 * Describes the message qdrant.SparseVector.
 * Use `create(SparseVectorSchema)` to create a new message.
 */
export const SparseVectorSchema: GenMessage<SparseVector> = /*@__PURE__*/
  messageDesc(file_points, 9);

/**
 * @generated from message qdrant.MultiDenseVector
 */
export type MultiDenseVector = Message<"qdrant.MultiDenseVector"> & {
  /**
   * @generated from field: repeated qdrant.DenseVector vectors = 1;
   */
  vectors: DenseVector[];
};

/**
 * Describes the message qdrant.MultiDenseVector.
 * Use `create(MultiDenseVectorSchema)` to create a new message.
 */
export const MultiDenseVectorSchema: GenMessage<MultiDenseVector> = /*@__PURE__*/
  messageDesc(file_points, 10);

/**
 * Vector type to be used in queries. Ids will be substituted with their corresponding vectors from the collection.
 *
 * @generated from message qdrant.VectorInput
 */
export type VectorInput = Message<"qdrant.VectorInput"> & {
  /**
   * @generated from oneof qdrant.VectorInput.variant
   */
  variant: {
    /**
     * @generated from field: qdrant.PointId id = 1;
     */
    value: PointId;
    case: "id";
  } | {
    /**
     * @generated from field: qdrant.DenseVector dense = 2;
     */
    value: DenseVector;
    case: "dense";
  } | {
    /**
     * @generated from field: qdrant.SparseVector sparse = 3;
     */
    value: SparseVector;
    case: "sparse";
  } | {
    /**
     * @generated from field: qdrant.MultiDenseVector multi_dense = 4;
     */
    value: MultiDenseVector;
    case: "multiDense";
  } | {
    /**
     * @generated from field: qdrant.Document document = 5;
     */
    value: Document;
    case: "document";
  } | {
    /**
     * @generated from field: qdrant.Image image = 6;
     */
    value: Image;
    case: "image";
  } | {
    /**
     * @generated from field: qdrant.InferenceObject object = 7;
     */
    value: InferenceObject;
    case: "object";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorInput.
 * Use `create(VectorInputSchema)` to create a new message.
 */
export const VectorInputSchema: GenMessage<VectorInput> = /*@__PURE__*/
  messageDesc(file_points, 11);

/**
 * @generated from message qdrant.ShardKeySelector
 */
export type ShardKeySelector = Message<"qdrant.ShardKeySelector"> & {
  /**
   * List of shard keys which should be used in the request
   *
   * @generated from field: repeated qdrant.ShardKey shard_keys = 1;
   */
  shardKeys: ShardKey[];

  /**
   * @generated from field: optional qdrant.ShardKey fallback = 2;
   */
  fallback?: ShardKey;
};

/**
 * Describes the message qdrant.ShardKeySelector.
 * Use `create(ShardKeySelectorSchema)` to create a new message.
 */
export const ShardKeySelectorSchema: GenMessage<ShardKeySelector> = /*@__PURE__*/
  messageDesc(file_points, 12);

/**
 * @generated from message qdrant.UpsertPoints
 */
export type UpsertPoints = Message<"qdrant.UpsertPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * @generated from field: repeated qdrant.PointStruct points = 3;
   */
  points: PointStruct[];

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated, others will be inserted
   *
   * @generated from field: optional qdrant.Filter update_filter = 6;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.UpsertPoints.
 * Use `create(UpsertPointsSchema)` to create a new message.
 */
export const UpsertPointsSchema: GenMessage<UpsertPoints> = /*@__PURE__*/
  messageDesc(file_points, 13);

/**
 * @generated from message qdrant.DeletePoints
 */
export type DeletePoints = Message<"qdrant.DeletePoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 3;
   */
  points?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DeletePoints.
 * Use `create(DeletePointsSchema)` to create a new message.
 */
export const DeletePointsSchema: GenMessage<DeletePoints> = /*@__PURE__*/
  messageDesc(file_points, 14);

/**
 * @generated from message qdrant.GetPoints
 */
export type GetPoints = Message<"qdrant.GetPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * List of points to retrieve
   *
   * @generated from field: repeated qdrant.PointId ids = 2;
   */
  ids: PointId[];

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 4;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 5;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 6;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 8;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.GetPoints.
 * Use `create(GetPointsSchema)` to create a new message.
 */
export const GetPointsSchema: GenMessage<GetPoints> = /*@__PURE__*/
  messageDesc(file_points, 15);

/**
 * @generated from message qdrant.UpdatePointVectors
 */
export type UpdatePointVectors = Message<"qdrant.UpdatePointVectors"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * List of points and vectors to update
   *
   * @generated from field: repeated qdrant.PointVectors points = 3;
   */
  points: PointVectors[];

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated
   *
   * @generated from field: optional qdrant.Filter update_filter = 6;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.UpdatePointVectors.
 * Use `create(UpdatePointVectorsSchema)` to create a new message.
 */
export const UpdatePointVectorsSchema: GenMessage<UpdatePointVectors> = /*@__PURE__*/
  messageDesc(file_points, 16);

/**
 * @generated from message qdrant.PointVectors
 */
export type PointVectors = Message<"qdrant.PointVectors"> & {
  /**
   * ID to update vectors for
   *
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * Named vectors to update, leave others intact
   *
   * @generated from field: qdrant.Vectors vectors = 2;
   */
  vectors?: Vectors;
};

/**
 * Describes the message qdrant.PointVectors.
 * Use `create(PointVectorsSchema)` to create a new message.
 */
export const PointVectorsSchema: GenMessage<PointVectors> = /*@__PURE__*/
  messageDesc(file_points, 17);

/**
 * @generated from message qdrant.DeletePointVectors
 */
export type DeletePointVectors = Message<"qdrant.DeletePointVectors"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points_selector = 3;
   */
  pointsSelector?: PointsSelector;

  /**
   * List of vector names to delete
   *
   * @generated from field: qdrant.VectorsSelector vectors = 4;
   */
  vectors?: VectorsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 5;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 6;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DeletePointVectors.
 * Use `create(DeletePointVectorsSchema)` to create a new message.
 */
export const DeletePointVectorsSchema: GenMessage<DeletePointVectors> = /*@__PURE__*/
  messageDesc(file_points, 18);

/**
 * @generated from message qdrant.SetPayloadPoints
 */
export type SetPayloadPoints = Message<"qdrant.SetPayloadPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * New payload values
   *
   * @generated from field: map<string, qdrant.Value> payload = 3;
   */
  payload: { [key: string]: Value };

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 5;
   */
  pointsSelector?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Option for indicate property of payload
   *
   * @generated from field: optional string key = 8;
   */
  key?: string;
};

/**
 * Describes the message qdrant.SetPayloadPoints.
 * Use `create(SetPayloadPointsSchema)` to create a new message.
 */
export const SetPayloadPointsSchema: GenMessage<SetPayloadPoints> = /*@__PURE__*/
  messageDesc(file_points, 19);

/**
 * @generated from message qdrant.DeletePayloadPoints
 */
export type DeletePayloadPoints = Message<"qdrant.DeletePayloadPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * List of keys to delete
   *
   * @generated from field: repeated string keys = 3;
   */
  keys: string[];

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 5;
   */
  pointsSelector?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DeletePayloadPoints.
 * Use `create(DeletePayloadPointsSchema)` to create a new message.
 */
export const DeletePayloadPointsSchema: GenMessage<DeletePayloadPoints> = /*@__PURE__*/
  messageDesc(file_points, 20);

/**
 * @generated from message qdrant.ClearPayloadPoints
 */
export type ClearPayloadPoints = Message<"qdrant.ClearPayloadPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 3;
   */
  points?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.ClearPayloadPoints.
 * Use `create(ClearPayloadPointsSchema)` to create a new message.
 */
export const ClearPayloadPointsSchema: GenMessage<ClearPayloadPoints> = /*@__PURE__*/
  messageDesc(file_points, 21);

/**
 * @generated from message qdrant.CreateFieldIndexCollection
 */
export type CreateFieldIndexCollection = Message<"qdrant.CreateFieldIndexCollection"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Field name to index
   *
   * @generated from field: string field_name = 3;
   */
  fieldName: string;

  /**
   * Field type.
   *
   * @generated from field: optional qdrant.FieldType field_type = 4;
   */
  fieldType?: FieldType;

  /**
   * Payload index params.
   *
   * @generated from field: optional qdrant.PayloadIndexParams field_index_params = 5;
   */
  fieldIndexParams?: PayloadIndexParams;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;
};

/**
 * Describes the message qdrant.CreateFieldIndexCollection.
 * Use `create(CreateFieldIndexCollectionSchema)` to create a new message.
 */
export const CreateFieldIndexCollectionSchema: GenMessage<CreateFieldIndexCollection> = /*@__PURE__*/
  messageDesc(file_points, 22);

/**
 * @generated from message qdrant.DeleteFieldIndexCollection
 */
export type DeleteFieldIndexCollection = Message<"qdrant.DeleteFieldIndexCollection"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Field name to delete
   *
   * @generated from field: string field_name = 3;
   */
  fieldName: string;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;
};

/**
 * Describes the message qdrant.DeleteFieldIndexCollection.
 * Use `create(DeleteFieldIndexCollectionSchema)` to create a new message.
 */
export const DeleteFieldIndexCollectionSchema: GenMessage<DeleteFieldIndexCollection> = /*@__PURE__*/
  messageDesc(file_points, 23);

/**
 * @generated from message qdrant.PayloadIncludeSelector
 */
export type PayloadIncludeSelector = Message<"qdrant.PayloadIncludeSelector"> & {
  /**
   * List of payload keys to include into result
   *
   * @generated from field: repeated string fields = 1;
   */
  fields: string[];
};

/**
 * Describes the message qdrant.PayloadIncludeSelector.
 * Use `create(PayloadIncludeSelectorSchema)` to create a new message.
 */
export const PayloadIncludeSelectorSchema: GenMessage<PayloadIncludeSelector> = /*@__PURE__*/
  messageDesc(file_points, 24);

/**
 * @generated from message qdrant.PayloadExcludeSelector
 */
export type PayloadExcludeSelector = Message<"qdrant.PayloadExcludeSelector"> & {
  /**
   * List of payload keys to exclude from the result
   *
   * @generated from field: repeated string fields = 1;
   */
  fields: string[];
};

/**
 * Describes the message qdrant.PayloadExcludeSelector.
 * Use `create(PayloadExcludeSelectorSchema)` to create a new message.
 */
export const PayloadExcludeSelectorSchema: GenMessage<PayloadExcludeSelector> = /*@__PURE__*/
  messageDesc(file_points, 25);

/**
 * @generated from message qdrant.WithPayloadSelector
 */
export type WithPayloadSelector = Message<"qdrant.WithPayloadSelector"> & {
  /**
   * @generated from oneof qdrant.WithPayloadSelector.selector_options
   */
  selectorOptions: {
    /**
     * If `true` - return all payload, if `false` - none
     *
     * @generated from field: bool enable = 1;
     */
    value: boolean;
    case: "enable";
  } | {
    /**
     * @generated from field: qdrant.PayloadIncludeSelector include = 2;
     */
    value: PayloadIncludeSelector;
    case: "include";
  } | {
    /**
     * @generated from field: qdrant.PayloadExcludeSelector exclude = 3;
     */
    value: PayloadExcludeSelector;
    case: "exclude";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.WithPayloadSelector.
 * Use `create(WithPayloadSelectorSchema)` to create a new message.
 */
export const WithPayloadSelectorSchema: GenMessage<WithPayloadSelector> = /*@__PURE__*/
  messageDesc(file_points, 26);

/**
 * @generated from message qdrant.NamedVectors
 */
export type NamedVectors = Message<"qdrant.NamedVectors"> & {
  /**
   * @generated from field: map<string, qdrant.Vector> vectors = 1;
   */
  vectors: { [key: string]: Vector };
};

/**
 * Describes the message qdrant.NamedVectors.
 * Use `create(NamedVectorsSchema)` to create a new message.
 */
export const NamedVectorsSchema: GenMessage<NamedVectors> = /*@__PURE__*/
  messageDesc(file_points, 27);

/**
 * @generated from message qdrant.NamedVectorsOutput
 */
export type NamedVectorsOutput = Message<"qdrant.NamedVectorsOutput"> & {
  /**
   * @generated from field: map<string, qdrant.VectorOutput> vectors = 1;
   */
  vectors: { [key: string]: VectorOutput };
};

/**
 * Describes the message qdrant.NamedVectorsOutput.
 * Use `create(NamedVectorsOutputSchema)` to create a new message.
 */
export const NamedVectorsOutputSchema: GenMessage<NamedVectorsOutput> = /*@__PURE__*/
  messageDesc(file_points, 28);

/**
 * @generated from message qdrant.Vectors
 */
export type Vectors = Message<"qdrant.Vectors"> & {
  /**
   * @generated from oneof qdrant.Vectors.vectors_options
   */
  vectorsOptions: {
    /**
     * @generated from field: qdrant.Vector vector = 1;
     */
    value: Vector;
    case: "vector";
  } | {
    /**
     * @generated from field: qdrant.NamedVectors vectors = 2;
     */
    value: NamedVectors;
    case: "vectors";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Vectors.
 * Use `create(VectorsSchema)` to create a new message.
 */
export const VectorsSchema: GenMessage<Vectors> = /*@__PURE__*/
  messageDesc(file_points, 29);

/**
 * @generated from message qdrant.VectorsOutput
 */
export type VectorsOutput = Message<"qdrant.VectorsOutput"> & {
  /**
   * @generated from oneof qdrant.VectorsOutput.vectors_options
   */
  vectorsOptions: {
    /**
     * @generated from field: qdrant.VectorOutput vector = 1;
     */
    value: VectorOutput;
    case: "vector";
  } | {
    /**
     * @generated from field: qdrant.NamedVectorsOutput vectors = 2;
     */
    value: NamedVectorsOutput;
    case: "vectors";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorsOutput.
 * Use `create(VectorsOutputSchema)` to create a new message.
 */
export const VectorsOutputSchema: GenMessage<VectorsOutput> = /*@__PURE__*/
  messageDesc(file_points, 30);

/**
 * @generated from message qdrant.VectorsSelector
 */
export type VectorsSelector = Message<"qdrant.VectorsSelector"> & {
  /**
   * List of vectors to include into result
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * Describes the message qdrant.VectorsSelector.
 * Use `create(VectorsSelectorSchema)` to create a new message.
 */
export const VectorsSelectorSchema: GenMessage<VectorsSelector> = /*@__PURE__*/
  messageDesc(file_points, 31);

/**
 * @generated from message qdrant.WithVectorsSelector
 */
export type WithVectorsSelector = Message<"qdrant.WithVectorsSelector"> & {
  /**
   * @generated from oneof qdrant.WithVectorsSelector.selector_options
   */
  selectorOptions: {
    /**
     * If `true` - return all vectors, if `false` - none
     *
     * @generated from field: bool enable = 1;
     */
    value: boolean;
    case: "enable";
  } | {
    /**
     * List of payload keys to include into result
     *
     * @generated from field: qdrant.VectorsSelector include = 2;
     */
    value: VectorsSelector;
    case: "include";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.WithVectorsSelector.
 * Use `create(WithVectorsSelectorSchema)` to create a new message.
 */
export const WithVectorsSelectorSchema: GenMessage<WithVectorsSelector> = /*@__PURE__*/
  messageDesc(file_points, 32);

/**
 * @generated from message qdrant.QuantizationSearchParams
 */
export type QuantizationSearchParams = Message<"qdrant.QuantizationSearchParams"> & {
  /**
   *
   * If set to true, search will ignore quantized vector data
   *
   * @generated from field: optional bool ignore = 1;
   */
  ignore?: boolean;

  /**
   *
   * If true, use original vectors to re-score top-k results. If ignored, qdrant decides automatically does rescore enabled or not.
   *
   * @generated from field: optional bool rescore = 2;
   */
  rescore?: boolean;

  /**
   *
   * Oversampling factor for quantization.
   *
   * Defines how many extra vectors should be pre-selected using quantized index,
   * and then re-scored using original vectors.
   *
   * For example, if `oversampling` is 2.4 and `limit` is 100, then 240 vectors will be pre-selected using quantized index,
   * and then top-100 will be returned after re-scoring.
   *
   * @generated from field: optional double oversampling = 3;
   */
  oversampling?: number;
};

/**
 * Describes the message qdrant.QuantizationSearchParams.
 * Use `create(QuantizationSearchParamsSchema)` to create a new message.
 */
export const QuantizationSearchParamsSchema: GenMessage<QuantizationSearchParams> = /*@__PURE__*/
  messageDesc(file_points, 33);

/**
 * @generated from message qdrant.AcornSearchParams
 */
export type AcornSearchParams = Message<"qdrant.AcornSearchParams"> & {
  /**
   *
   * If true, then ACORN may be used for the HNSW search based on filters
   * selectivity.
   *
   * Improves search recall for searches with multiple low-selectivity
   * payload filters, at cost of performance.
   *
   * @generated from field: optional bool enable = 1;
   */
  enable?: boolean;

  /**
   *
   * Maximum selectivity of filters to enable ACORN.
   *
   * If estimated filters selectivity is higher than this value,
   * ACORN will not be used. Selectivity is estimated as:
   * `estimated number of points satisfying the filters / total number of points`.
   *
   * 0.0 for never, 1.0 for always. Default is 0.4.
   *
   * @generated from field: optional double max_selectivity = 2;
   */
  maxSelectivity?: number;
};

/**
 * Describes the message qdrant.AcornSearchParams.
 * Use `create(AcornSearchParamsSchema)` to create a new message.
 */
export const AcornSearchParamsSchema: GenMessage<AcornSearchParams> = /*@__PURE__*/
  messageDesc(file_points, 34);

/**
 * @generated from message qdrant.SearchParams
 */
export type SearchParams = Message<"qdrant.SearchParams"> & {
  /**
   *
   * Params relevant to HNSW index. Size of the beam in a beam-search.
   * Larger the value - more accurate the result, more time required for search.
   *
   * @generated from field: optional uint64 hnsw_ef = 1;
   */
  hnswEf?: bigint;

  /**
   *
   * Search without approximation. If set to true, search may run long but with exact results.
   *
   * @generated from field: optional bool exact = 2;
   */
  exact?: boolean;

  /**
   *
   * If set to true, search will ignore quantized vector data
   *
   * @generated from field: optional qdrant.QuantizationSearchParams quantization = 3;
   */
  quantization?: QuantizationSearchParams;

  /**
   *
   * If enabled, the engine will only perform search among indexed or small segments.
   * Using this option prevents slow searches in case of delayed index, but does not
   * guarantee that all uploaded vectors will be included in search results
   *
   * @generated from field: optional bool indexed_only = 4;
   */
  indexedOnly?: boolean;

  /**
   *
   * ACORN search params
   *
   * @generated from field: optional qdrant.AcornSearchParams acorn = 5;
   */
  acorn?: AcornSearchParams;
};

/**
 * Describes the message qdrant.SearchParams.
 * Use `create(SearchParamsSchema)` to create a new message.
 */
export const SearchParamsSchema: GenMessage<SearchParams> = /*@__PURE__*/
  messageDesc(file_points, 35);

/**
 * @generated from message qdrant.SearchPoints
 */
export type SearchPoints = Message<"qdrant.SearchPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * vector
   *
   * @generated from field: repeated float vector = 2;
   */
  vector: number[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 4;
   */
  limit: bigint;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 7;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 8;
   */
  scoreThreshold?: number;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 9;
   */
  offset?: bigint;

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 10;
   */
  vectorName?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 11;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 13;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 14;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * @generated from field: optional qdrant.SparseIndices sparse_indices = 15;
   */
  sparseIndices?: SparseIndices;
};

/**
 * Describes the message qdrant.SearchPoints.
 * Use `create(SearchPointsSchema)` to create a new message.
 */
export const SearchPointsSchema: GenMessage<SearchPoints> = /*@__PURE__*/
  messageDesc(file_points, 36);

/**
 * @generated from message qdrant.SearchBatchPoints
 */
export type SearchBatchPoints = Message<"qdrant.SearchBatchPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.SearchPoints search_points = 2;
   */
  searchPoints: SearchPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.SearchBatchPoints.
 * Use `create(SearchBatchPointsSchema)` to create a new message.
 */
export const SearchBatchPointsSchema: GenMessage<SearchBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 37);

/**
 * @generated from message qdrant.WithLookup
 */
export type WithLookup = Message<"qdrant.WithLookup"> & {
  /**
   * Name of the collection to use for points lookup
   *
   * @generated from field: string collection = 1;
   */
  collection: string;

  /**
   * Options for specifying which payload to include (or not)
   *
   * @generated from field: optional qdrant.WithPayloadSelector with_payload = 2;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include (or not)
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 3;
   */
  withVectors?: WithVectorsSelector;
};

/**
 * Describes the message qdrant.WithLookup.
 * Use `create(WithLookupSchema)` to create a new message.
 */
export const WithLookupSchema: GenMessage<WithLookup> = /*@__PURE__*/
  messageDesc(file_points, 38);

/**
 * @generated from message qdrant.SearchPointGroups
 */
export type SearchPointGroups = Message<"qdrant.SearchPointGroups"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Vector to compare against
   *
   * @generated from field: repeated float vector = 2;
   */
  vector: number[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint32 limit = 4;
   */
  limit: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 5;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 6;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 7;
   */
  scoreThreshold?: number;

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 8;
   */
  vectorName?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 9;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
   *
   * @generated from field: string group_by = 10;
   */
  groupBy: string;

  /**
   * Maximum amount of points to return per group
   *
   * @generated from field: uint32 group_size = 11;
   */
  groupSize: number;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * Options for specifying how to use the group id to lookup points in another collection
   *
   * @generated from field: optional qdrant.WithLookup with_lookup = 13;
   */
  withLookup?: WithLookup;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 14;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 15;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * @generated from field: optional qdrant.SparseIndices sparse_indices = 16;
   */
  sparseIndices?: SparseIndices;
};

/**
 * Describes the message qdrant.SearchPointGroups.
 * Use `create(SearchPointGroupsSchema)` to create a new message.
 */
export const SearchPointGroupsSchema: GenMessage<SearchPointGroups> = /*@__PURE__*/
  messageDesc(file_points, 39);

/**
 * @generated from message qdrant.StartFrom
 */
export type StartFrom = Message<"qdrant.StartFrom"> & {
  /**
   * @generated from oneof qdrant.StartFrom.value
   */
  value: {
    /**
     * @generated from field: double float = 1;
     */
    value: number;
    case: "float";
  } | {
    /**
     * @generated from field: int64 integer = 2;
     */
    value: bigint;
    case: "integer";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp timestamp = 3;
     */
    value: Timestamp;
    case: "timestamp";
  } | {
    /**
     * @generated from field: string datetime = 4;
     */
    value: string;
    case: "datetime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.StartFrom.
 * Use `create(StartFromSchema)` to create a new message.
 */
export const StartFromSchema: GenMessage<StartFrom> = /*@__PURE__*/
  messageDesc(file_points, 40);

/**
 * @generated from message qdrant.OrderBy
 */
export type OrderBy = Message<"qdrant.OrderBy"> & {
  /**
   * Payload key to order by
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Ascending or descending order
   *
   * @generated from field: optional qdrant.Direction direction = 2;
   */
  direction?: Direction;

  /**
   * Start from this value
   *
   * @generated from field: optional qdrant.StartFrom start_from = 3;
   */
  startFrom?: StartFrom;
};

/**
 * Describes the message qdrant.OrderBy.
 * Use `create(OrderBySchema)` to create a new message.
 */
export const OrderBySchema: GenMessage<OrderBy> = /*@__PURE__*/
  messageDesc(file_points, 41);

/**
 * @generated from message qdrant.ScrollPoints
 */
export type ScrollPoints = Message<"qdrant.ScrollPoints"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * Start with this ID
   *
   * @generated from field: optional qdrant.PointId offset = 3;
   */
  offset?: PointId;

  /**
   * Max number of result
   *
   * @generated from field: optional uint32 limit = 4;
   */
  limit?: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 7;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 8;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 9;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Order the records by a payload field
   *
   * @generated from field: optional qdrant.OrderBy order_by = 10;
   */
  orderBy?: OrderBy;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 11;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.ScrollPoints.
 * Use `create(ScrollPointsSchema)` to create a new message.
 */
export const ScrollPointsSchema: GenMessage<ScrollPoints> = /*@__PURE__*/
  messageDesc(file_points, 42);

/**
 * @generated from message qdrant.LookupLocation
 */
export type LookupLocation = Message<"qdrant.LookupLocation"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 2;
   */
  vectorName?: string;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.LookupLocation.
 * Use `create(LookupLocationSchema)` to create a new message.
 */
export const LookupLocationSchema: GenMessage<LookupLocation> = /*@__PURE__*/
  messageDesc(file_points, 43);

/**
 * @generated from message qdrant.RecommendPoints
 */
export type RecommendPoints = Message<"qdrant.RecommendPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Look for vectors closest to the vectors from these points
   *
   * @generated from field: repeated qdrant.PointId positive = 2;
   */
  positive: PointId[];

  /**
   * Try to avoid vectors like the vector from these points
   *
   * @generated from field: repeated qdrant.PointId negative = 3;
   */
  negative: PointId[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 5;
   */
  limit: bigint;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 7;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 8;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 9;
   */
  scoreThreshold?: number;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 10;
   */
  offset?: bigint;

  /**
   * Define which vector to use for recommendation, if not specified - default vector
   *
   * @generated from field: optional string using = 11;
   */
  using?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 12;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Name of the collection to use for points lookup, if not specified - use current collection
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 13;
   */
  lookupFrom?: LookupLocation;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
   */
  readConsistency?: ReadConsistency;

  /**
   * How to use the example vectors to find the results
   *
   * @generated from field: optional qdrant.RecommendStrategy strategy = 16;
   */
  strategy?: RecommendStrategy;

  /**
   * Look for vectors closest to those
   *
   * @generated from field: repeated qdrant.Vector positive_vectors = 17;
   */
  positiveVectors: Vector[];

  /**
   * Try to avoid vectors like this
   *
   * @generated from field: repeated qdrant.Vector negative_vectors = 18;
   */
  negativeVectors: Vector[];

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 19;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 20;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.RecommendPoints.
 * Use `create(RecommendPointsSchema)` to create a new message.
 */
export const RecommendPointsSchema: GenMessage<RecommendPoints> = /*@__PURE__*/
  messageDesc(file_points, 44);

/**
 * @generated from message qdrant.RecommendBatchPoints
 */
export type RecommendBatchPoints = Message<"qdrant.RecommendBatchPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.RecommendPoints recommend_points = 2;
   */
  recommendPoints: RecommendPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.RecommendBatchPoints.
 * Use `create(RecommendBatchPointsSchema)` to create a new message.
 */
export const RecommendBatchPointsSchema: GenMessage<RecommendBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 45);

/**
 * @generated from message qdrant.RecommendPointGroups
 */
export type RecommendPointGroups = Message<"qdrant.RecommendPointGroups"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Look for vectors closest to the vectors from these points
   *
   * @generated from field: repeated qdrant.PointId positive = 2;
   */
  positive: PointId[];

  /**
   * Try to avoid vectors like the vector from these points
   *
   * @generated from field: repeated qdrant.PointId negative = 3;
   */
  negative: PointId[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Max number of groups in result
   *
   * @generated from field: uint32 limit = 5;
   */
  limit: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 7;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 8;
   */
  scoreThreshold?: number;

  /**
   * Define which vector to use for recommendation, if not specified - default vector
   *
   * @generated from field: optional string using = 9;
   */
  using?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Name of the collection to use for points lookup, if not specified - use current collection
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 11;
   */
  lookupFrom?: LookupLocation;

  /**
   * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
   *
   * @generated from field: string group_by = 12;
   */
  groupBy: string;

  /**
   * Maximum amount of points to return per group
   *
   * @generated from field: uint32 group_size = 13;
   */
  groupSize: number;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
   */
  readConsistency?: ReadConsistency;

  /**
   * Options for specifying how to use the group id to lookup points in another collection
   *
   * @generated from field: optional qdrant.WithLookup with_lookup = 15;
   */
  withLookup?: WithLookup;

  /**
   * How to use the example vectors to find the results
   *
   * @generated from field: optional qdrant.RecommendStrategy strategy = 17;
   */
  strategy?: RecommendStrategy;

  /**
   * Look for vectors closest to those
   *
   * @generated from field: repeated qdrant.Vector positive_vectors = 18;
   */
  positiveVectors: Vector[];

  /**
   * Try to avoid vectors like this
   *
   * @generated from field: repeated qdrant.Vector negative_vectors = 19;
   */
  negativeVectors: Vector[];

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 20;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 21;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.RecommendPointGroups.
 * Use `create(RecommendPointGroupsSchema)` to create a new message.
 */
export const RecommendPointGroupsSchema: GenMessage<RecommendPointGroups> = /*@__PURE__*/
  messageDesc(file_points, 46);

/**
 * @generated from message qdrant.TargetVector
 */
export type TargetVector = Message<"qdrant.TargetVector"> & {
  /**
   * @generated from oneof qdrant.TargetVector.target
   */
  target: {
    /**
     * @generated from field: qdrant.VectorExample single = 1;
     */
    value: VectorExample;
    case: "single";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.TargetVector.
 * Use `create(TargetVectorSchema)` to create a new message.
 */
export const TargetVectorSchema: GenMessage<TargetVector> = /*@__PURE__*/
  messageDesc(file_points, 47);

/**
 * @generated from message qdrant.VectorExample
 */
export type VectorExample = Message<"qdrant.VectorExample"> & {
  /**
   * @generated from oneof qdrant.VectorExample.example
   */
  example: {
    /**
     * @generated from field: qdrant.PointId id = 1;
     */
    value: PointId;
    case: "id";
  } | {
    /**
     * @generated from field: qdrant.Vector vector = 2;
     */
    value: Vector;
    case: "vector";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorExample.
 * Use `create(VectorExampleSchema)` to create a new message.
 */
export const VectorExampleSchema: GenMessage<VectorExample> = /*@__PURE__*/
  messageDesc(file_points, 48);

/**
 * @generated from message qdrant.ContextExamplePair
 */
export type ContextExamplePair = Message<"qdrant.ContextExamplePair"> & {
  /**
   * @generated from field: qdrant.VectorExample positive = 1;
   */
  positive?: VectorExample;

  /**
   * @generated from field: qdrant.VectorExample negative = 2;
   */
  negative?: VectorExample;
};

/**
 * Describes the message qdrant.ContextExamplePair.
 * Use `create(ContextExamplePairSchema)` to create a new message.
 */
export const ContextExamplePairSchema: GenMessage<ContextExamplePair> = /*@__PURE__*/
  messageDesc(file_points, 49);

/**
 * @generated from message qdrant.DiscoverPoints
 */
export type DiscoverPoints = Message<"qdrant.DiscoverPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Use this as the primary search objective
   *
   * @generated from field: qdrant.TargetVector target = 2;
   */
  target?: TargetVector;

  /**
   * Search will be constrained by these pairs of examples
   *
   * @generated from field: repeated qdrant.ContextExamplePair context = 3;
   */
  context: ContextExamplePair[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 5;
   */
  limit: bigint;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 7;
   */
  params?: SearchParams;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 8;
   */
  offset?: bigint;

  /**
   * Define which vector to use for recommendation, if not specified - default vector
   *
   * @generated from field: optional string using = 9;
   */
  using?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Name of the collection to use for points lookup, if not specified - use current collection
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 11;
   */
  lookupFrom?: LookupLocation;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 13;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 14;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DiscoverPoints.
 * Use `create(DiscoverPointsSchema)` to create a new message.
 */
export const DiscoverPointsSchema: GenMessage<DiscoverPoints> = /*@__PURE__*/
  messageDesc(file_points, 50);

/**
 * @generated from message qdrant.DiscoverBatchPoints
 */
export type DiscoverBatchPoints = Message<"qdrant.DiscoverBatchPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.DiscoverPoints discover_points = 2;
   */
  discoverPoints: DiscoverPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.DiscoverBatchPoints.
 * Use `create(DiscoverBatchPointsSchema)` to create a new message.
 */
export const DiscoverBatchPointsSchema: GenMessage<DiscoverBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 51);

/**
 * @generated from message qdrant.CountPoints
 */
export type CountPoints = Message<"qdrant.CountPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * If `true` - return exact count, if `false` - return approximate count
   *
   * @generated from field: optional bool exact = 3;
   */
  exact?: boolean;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 4;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 6;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.CountPoints.
 * Use `create(CountPointsSchema)` to create a new message.
 */
export const CountPointsSchema: GenMessage<CountPoints> = /*@__PURE__*/
  messageDesc(file_points, 52);

/**
 * @generated from message qdrant.RecommendInput
 */
export type RecommendInput = Message<"qdrant.RecommendInput"> & {
  /**
   * Look for vectors closest to the vectors from these points
   *
   * @generated from field: repeated qdrant.VectorInput positive = 1;
   */
  positive: VectorInput[];

  /**
   * Try to avoid vectors like the vector from these points
   *
   * @generated from field: repeated qdrant.VectorInput negative = 2;
   */
  negative: VectorInput[];

  /**
   * How to use the provided vectors to find the results
   *
   * @generated from field: optional qdrant.RecommendStrategy strategy = 3;
   */
  strategy?: RecommendStrategy;
};

/**
 * Describes the message qdrant.RecommendInput.
 * Use `create(RecommendInputSchema)` to create a new message.
 */
export const RecommendInputSchema: GenMessage<RecommendInput> = /*@__PURE__*/
  messageDesc(file_points, 53);

/**
 * @generated from message qdrant.ContextInputPair
 */
export type ContextInputPair = Message<"qdrant.ContextInputPair"> & {
  /**
   * A positive vector
   *
   * @generated from field: qdrant.VectorInput positive = 1;
   */
  positive?: VectorInput;

  /**
   * Repel from this vector
   *
   * @generated from field: qdrant.VectorInput negative = 2;
   */
  negative?: VectorInput;
};

/**
 * Describes the message qdrant.ContextInputPair.
 * Use `create(ContextInputPairSchema)` to create a new message.
 */
export const ContextInputPairSchema: GenMessage<ContextInputPair> = /*@__PURE__*/
  messageDesc(file_points, 54);

/**
 * @generated from message qdrant.DiscoverInput
 */
export type DiscoverInput = Message<"qdrant.DiscoverInput"> & {
  /**
   * Use this as the primary search objective
   *
   * @generated from field: qdrant.VectorInput target = 1;
   */
  target?: VectorInput;

  /**
   * Search space will be constrained by these pairs of vectors
   *
   * @generated from field: qdrant.ContextInput context = 2;
   */
  context?: ContextInput;
};

/**
 * Describes the message qdrant.DiscoverInput.
 * Use `create(DiscoverInputSchema)` to create a new message.
 */
export const DiscoverInputSchema: GenMessage<DiscoverInput> = /*@__PURE__*/
  messageDesc(file_points, 55);

/**
 * @generated from message qdrant.ContextInput
 */
export type ContextInput = Message<"qdrant.ContextInput"> & {
  /**
   * Search space will be constrained by these pairs of vectors
   *
   * @generated from field: repeated qdrant.ContextInputPair pairs = 1;
   */
  pairs: ContextInputPair[];
};

/**
 * Describes the message qdrant.ContextInput.
 * Use `create(ContextInputSchema)` to create a new message.
 */
export const ContextInputSchema: GenMessage<ContextInput> = /*@__PURE__*/
  messageDesc(file_points, 56);

/**
 * @generated from message qdrant.Formula
 */
export type Formula = Message<"qdrant.Formula"> & {
  /**
   * @generated from field: qdrant.Expression expression = 1;
   */
  expression?: Expression;

  /**
   * @generated from field: map<string, qdrant.Value> defaults = 2;
   */
  defaults: { [key: string]: Value };
};

/**
 * Describes the message qdrant.Formula.
 * Use `create(FormulaSchema)` to create a new message.
 */
export const FormulaSchema: GenMessage<Formula> = /*@__PURE__*/
  messageDesc(file_points, 57);

/**
 * @generated from message qdrant.Expression
 */
export type Expression = Message<"qdrant.Expression"> & {
  /**
   * @generated from oneof qdrant.Expression.variant
   */
  variant: {
    /**
     * @generated from field: float constant = 1;
     */
    value: number;
    case: "constant";
  } | {
    /**
     * Payload key or reference to score.
     *
     * @generated from field: string variable = 2;
     */
    value: string;
    case: "variable";
  } | {
    /**
     * Payload condition. If true, becomes 1.0; otherwise 0.0
     *
     * @generated from field: qdrant.Condition condition = 3;
     */
    value: Condition;
    case: "condition";
  } | {
    /**
     * Geographic distance in meters
     *
     * @generated from field: qdrant.GeoDistance geo_distance = 4;
     */
    value: GeoDistance;
    case: "geoDistance";
  } | {
    /**
     * Date-time constant
     *
     * @generated from field: string datetime = 5;
     */
    value: string;
    case: "datetime";
  } | {
    /**
     * Payload key with date-time values
     *
     * @generated from field: string datetime_key = 6;
     */
    value: string;
    case: "datetimeKey";
  } | {
    /**
     * Multiply
     *
     * @generated from field: qdrant.MultExpression mult = 7;
     */
    value: MultExpression;
    case: "mult";
  } | {
    /**
     * Sum
     *
     * @generated from field: qdrant.SumExpression sum = 8;
     */
    value: SumExpression;
    case: "sum";
  } | {
    /**
     * Divide
     *
     * @generated from field: qdrant.DivExpression div = 9;
     */
    value: DivExpression;
    case: "div";
  } | {
    /**
     * Negate
     *
     * @generated from field: qdrant.Expression neg = 10;
     */
    value: Expression;
    case: "neg";
  } | {
    /**
     * Absolute value
     *
     * @generated from field: qdrant.Expression abs = 11;
     */
    value: Expression;
    case: "abs";
  } | {
    /**
     * Square root
     *
     * @generated from field: qdrant.Expression sqrt = 12;
     */
    value: Expression;
    case: "sqrt";
  } | {
    /**
     * Power
     *
     * @generated from field: qdrant.PowExpression pow = 13;
     */
    value: PowExpression;
    case: "pow";
  } | {
    /**
     * Exponential
     *
     * @generated from field: qdrant.Expression exp = 14;
     */
    value: Expression;
    case: "exp";
  } | {
    /**
     * Logarithm
     *
     * @generated from field: qdrant.Expression log10 = 15;
     */
    value: Expression;
    case: "log10";
  } | {
    /**
     * Natural logarithm
     *
     * @generated from field: qdrant.Expression ln = 16;
     */
    value: Expression;
    case: "ln";
  } | {
    /**
     * Exponential decay
     *
     * @generated from field: qdrant.DecayParamsExpression exp_decay = 17;
     */
    value: DecayParamsExpression;
    case: "expDecay";
  } | {
    /**
     * Gaussian decay
     *
     * @generated from field: qdrant.DecayParamsExpression gauss_decay = 18;
     */
    value: DecayParamsExpression;
    case: "gaussDecay";
  } | {
    /**
     * Linear decay
     *
     * @generated from field: qdrant.DecayParamsExpression lin_decay = 19;
     */
    value: DecayParamsExpression;
    case: "linDecay";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Expression.
 * Use `create(ExpressionSchema)` to create a new message.
 */
export const ExpressionSchema: GenMessage<Expression> = /*@__PURE__*/
  messageDesc(file_points, 58);

/**
 * @generated from message qdrant.GeoDistance
 */
export type GeoDistance = Message<"qdrant.GeoDistance"> & {
  /**
   * @generated from field: qdrant.GeoPoint origin = 1;
   */
  origin?: GeoPoint;

  /**
   * @generated from field: string to = 2;
   */
  to: string;
};

/**
 * Describes the message qdrant.GeoDistance.
 * Use `create(GeoDistanceSchema)` to create a new message.
 */
export const GeoDistanceSchema: GenMessage<GeoDistance> = /*@__PURE__*/
  messageDesc(file_points, 59);

/**
 * @generated from message qdrant.MultExpression
 */
export type MultExpression = Message<"qdrant.MultExpression"> & {
  /**
   * @generated from field: repeated qdrant.Expression mult = 1;
   */
  mult: Expression[];
};

/**
 * Describes the message qdrant.MultExpression.
 * Use `create(MultExpressionSchema)` to create a new message.
 */
export const MultExpressionSchema: GenMessage<MultExpression> = /*@__PURE__*/
  messageDesc(file_points, 60);

/**
 * @generated from message qdrant.SumExpression
 */
export type SumExpression = Message<"qdrant.SumExpression"> & {
  /**
   * @generated from field: repeated qdrant.Expression sum = 1;
   */
  sum: Expression[];
};

/**
 * Describes the message qdrant.SumExpression.
 * Use `create(SumExpressionSchema)` to create a new message.
 */
export const SumExpressionSchema: GenMessage<SumExpression> = /*@__PURE__*/
  messageDesc(file_points, 61);

/**
 * @generated from message qdrant.DivExpression
 */
export type DivExpression = Message<"qdrant.DivExpression"> & {
  /**
   * @generated from field: qdrant.Expression left = 1;
   */
  left?: Expression;

  /**
   * @generated from field: qdrant.Expression right = 2;
   */
  right?: Expression;

  /**
   * @generated from field: optional float by_zero_default = 3;
   */
  byZeroDefault?: number;
};

/**
 * Describes the message qdrant.DivExpression.
 * Use `create(DivExpressionSchema)` to create a new message.
 */
export const DivExpressionSchema: GenMessage<DivExpression> = /*@__PURE__*/
  messageDesc(file_points, 62);

/**
 * @generated from message qdrant.PowExpression
 */
export type PowExpression = Message<"qdrant.PowExpression"> & {
  /**
   * @generated from field: qdrant.Expression base = 1;
   */
  base?: Expression;

  /**
   * @generated from field: qdrant.Expression exponent = 2;
   */
  exponent?: Expression;
};

/**
 * Describes the message qdrant.PowExpression.
 * Use `create(PowExpressionSchema)` to create a new message.
 */
export const PowExpressionSchema: GenMessage<PowExpression> = /*@__PURE__*/
  messageDesc(file_points, 63);

/**
 * @generated from message qdrant.DecayParamsExpression
 */
export type DecayParamsExpression = Message<"qdrant.DecayParamsExpression"> & {
  /**
   * The variable to decay
   *
   * @generated from field: qdrant.Expression x = 1;
   */
  x?: Expression;

  /**
   * The target value to start decaying from. Defaults to 0.
   *
   * @generated from field: optional qdrant.Expression target = 2;
   */
  target?: Expression;

  /**
   * The scale factor of the decay, in terms of `x`. Defaults to 1.0. Must be a non-zero positive number.
   *
   * @generated from field: optional float scale = 3;
   */
  scale?: number;

  /**
   * The midpoint of the decay. Should be between 0 and 1. Defaults to 0.5. Output will be this value when `|x - target| == scale`.
   *
   * @generated from field: optional float midpoint = 4;
   */
  midpoint?: number;
};

/**
 * Describes the message qdrant.DecayParamsExpression.
 * Use `create(DecayParamsExpressionSchema)` to create a new message.
 */
export const DecayParamsExpressionSchema: GenMessage<DecayParamsExpression> = /*@__PURE__*/
  messageDesc(file_points, 64);

/**
 * @generated from message qdrant.NearestInputWithMmr
 */
export type NearestInputWithMmr = Message<"qdrant.NearestInputWithMmr"> & {
  /**
   * The vector to search for nearest neighbors.
   *
   * @generated from field: qdrant.VectorInput nearest = 1;
   */
  nearest?: VectorInput;

  /**
   * Perform MMR (Maximal Marginal Relevance) reranking after search,
   * using the same vector in this query to calculate relevance.
   *
   * @generated from field: qdrant.Mmr mmr = 2;
   */
  mmr?: Mmr;
};

/**
 * Describes the message qdrant.NearestInputWithMmr.
 * Use `create(NearestInputWithMmrSchema)` to create a new message.
 */
export const NearestInputWithMmrSchema: GenMessage<NearestInputWithMmr> = /*@__PURE__*/
  messageDesc(file_points, 65);

/**
 * Maximal Marginal Relevance (MMR) algorithm for re-ranking the points.
 *
 * @generated from message qdrant.Mmr
 */
export type Mmr = Message<"qdrant.Mmr"> & {
  /**
   * Tunable parameter for the MMR algorithm.
   * Determines the balance between diversity and relevance.
   *
   * A higher value favors diversity (dissimilarity to selected results),
   * while a lower value favors relevance (similarity to the query vector).
   *
   * Must be in the range [0, 1].
   * Default value is 0.5.
   *
   * @generated from field: optional float diversity = 2;
   */
  diversity?: number;

  /**
   * The maximum number of candidates to consider for re-ranking.
   *
   * If not specified, the `limit` value is used.
   *
   * @generated from field: optional uint32 candidates_limit = 3;
   */
  candidatesLimit?: number;
};

/**
 * Describes the message qdrant.Mmr.
 * Use `create(MmrSchema)` to create a new message.
 */
export const MmrSchema: GenMessage<Mmr> = /*@__PURE__*/
  messageDesc(file_points, 66);

/**
 * Parameterized reciprocal rank fusion
 *
 * @generated from message qdrant.Rrf
 */
export type Rrf = Message<"qdrant.Rrf"> & {
  /**
   * K parameter for reciprocal rank fusion
   *
   * @generated from field: optional uint32 k = 1;
   */
  k?: number;
};

/**
 * Describes the message qdrant.Rrf.
 * Use `create(RrfSchema)` to create a new message.
 */
export const RrfSchema: GenMessage<Rrf> = /*@__PURE__*/
  messageDesc(file_points, 67);

/**
 * @generated from message qdrant.Query
 */
export type Query = Message<"qdrant.Query"> & {
  /**
   * @generated from oneof qdrant.Query.variant
   */
  variant: {
    /**
     * Find the nearest neighbors to this vector.
     *
     * @generated from field: qdrant.VectorInput nearest = 1;
     */
    value: VectorInput;
    case: "nearest";
  } | {
    /**
     * Use multiple positive and negative vectors to find the results.
     *
     * @generated from field: qdrant.RecommendInput recommend = 2;
     */
    value: RecommendInput;
    case: "recommend";
  } | {
    /**
     * Search for nearest points, but constrain the search space with context
     *
     * @generated from field: qdrant.DiscoverInput discover = 3;
     */
    value: DiscoverInput;
    case: "discover";
  } | {
    /**
     * Return points that live in positive areas.
     *
     * @generated from field: qdrant.ContextInput context = 4;
     */
    value: ContextInput;
    case: "context";
  } | {
    /**
     * Order the points by a payload field.
     *
     * @generated from field: qdrant.OrderBy order_by = 5;
     */
    value: OrderBy;
    case: "orderBy";
  } | {
    /**
     * Fuse the results of multiple prefetches.
     *
     * @generated from field: qdrant.Fusion fusion = 6;
     */
    value: Fusion;
    case: "fusion";
  } | {
    /**
     * Sample points from the collection.
     *
     * @generated from field: qdrant.Sample sample = 7;
     */
    value: Sample;
    case: "sample";
  } | {
    /**
     * Score boosting via an arbitrary formula
     *
     * @generated from field: qdrant.Formula formula = 8;
     */
    value: Formula;
    case: "formula";
  } | {
    /**
     * Search nearest neighbors, but re-rank based on the Maximal Marginal Relevance algorithm.
     *
     * @generated from field: qdrant.NearestInputWithMmr nearest_with_mmr = 9;
     */
    value: NearestInputWithMmr;
    case: "nearestWithMmr";
  } | {
    /**
     * Parameterized reciprocal rank fusion
     *
     * @generated from field: qdrant.Rrf rrf = 10;
     */
    value: Rrf;
    case: "rrf";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Query.
 * Use `create(QuerySchema)` to create a new message.
 */
export const QuerySchema: GenMessage<Query> = /*@__PURE__*/
  messageDesc(file_points, 68);

/**
 * @generated from message qdrant.PrefetchQuery
 */
export type PrefetchQuery = Message<"qdrant.PrefetchQuery"> & {
  /**
   * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
   *
   * @generated from field: repeated qdrant.PrefetchQuery prefetch = 1;
   */
  prefetch: PrefetchQuery[];

  /**
   * Query to perform. If missing, returns points ordered by their IDs.
   *
   * @generated from field: optional qdrant.Query query = 2;
   */
  query?: Query;

  /**
   * Define which vector to use for querying. If missing, the default vector is is used.
   *
   * @generated from field: optional string using = 3;
   */
  using?: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Search params for when there is no prefetch.
   *
   * @generated from field: optional qdrant.SearchParams params = 5;
   */
  params?: SearchParams;

  /**
   * Return points with scores better than this threshold.
   *
   * @generated from field: optional float score_threshold = 6;
   */
  scoreThreshold?: number;

  /**
   * Max number of points. Default is 10
   *
   * @generated from field: optional uint64 limit = 7;
   */
  limit?: bigint;

  /**
   * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 8;
   */
  lookupFrom?: LookupLocation;
};

/**
 * Describes the message qdrant.PrefetchQuery.
 * Use `create(PrefetchQuerySchema)` to create a new message.
 */
export const PrefetchQuerySchema: GenMessage<PrefetchQuery> = /*@__PURE__*/
  messageDesc(file_points, 69);

/**
 * @generated from message qdrant.QueryPoints
 */
export type QueryPoints = Message<"qdrant.QueryPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
   *
   * @generated from field: repeated qdrant.PrefetchQuery prefetch = 2;
   */
  prefetch: PrefetchQuery[];

  /**
   * Query to perform. If missing, returns points ordered by their IDs.
   *
   * @generated from field: optional qdrant.Query query = 3;
   */
  query?: Query;

  /**
   * Define which vector to use for querying. If missing, the default vector is used.
   *
   * @generated from field: optional string using = 4;
   */
  using?: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 5;
   */
  filter?: Filter;

  /**
   * Search params for when there is no prefetch.
   *
   * @generated from field: optional qdrant.SearchParams params = 6;
   */
  params?: SearchParams;

  /**
   * Return points with scores better than this threshold.
   *
   * @generated from field: optional float score_threshold = 7;
   */
  scoreThreshold?: number;

  /**
   * Max number of points. Default is 10.
   *
   * @generated from field: optional uint64 limit = 8;
   */
  limit?: bigint;

  /**
   * Offset of the result. Skip this many points. Default is 0.
   *
   * @generated from field: optional uint64 offset = 9;
   */
  offset?: bigint;

  /**
   * Options for specifying which vectors to include into the response.
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying which payload to include or not.
   *
   * @generated from field: optional qdrant.WithPayloadSelector with_payload = 11;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying read consistency guarantees.
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards.
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 13;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 14;
   */
  lookupFrom?: LookupLocation;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 15;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.QueryPoints.
 * Use `create(QueryPointsSchema)` to create a new message.
 */
export const QueryPointsSchema: GenMessage<QueryPoints> = /*@__PURE__*/
  messageDesc(file_points, 70);

/**
 * @generated from message qdrant.QueryBatchPoints
 */
export type QueryBatchPoints = Message<"qdrant.QueryBatchPoints"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.QueryPoints query_points = 2;
   */
  queryPoints: QueryPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.QueryBatchPoints.
 * Use `create(QueryBatchPointsSchema)` to create a new message.
 */
export const QueryBatchPointsSchema: GenMessage<QueryBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 71);

/**
 * @generated from message qdrant.QueryPointGroups
 */
export type QueryPointGroups = Message<"qdrant.QueryPointGroups"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
   *
   * @generated from field: repeated qdrant.PrefetchQuery prefetch = 2;
   */
  prefetch: PrefetchQuery[];

  /**
   * Query to perform. If missing, returns points ordered by their IDs.
   *
   * @generated from field: optional qdrant.Query query = 3;
   */
  query?: Query;

  /**
   * Define which vector to use for querying. If missing, the default vector is used.
   *
   * @generated from field: optional string using = 4;
   */
  using?: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 5;
   */
  filter?: Filter;

  /**
   * Search params for when there is no prefetch.
   *
   * @generated from field: optional qdrant.SearchParams params = 6;
   */
  params?: SearchParams;

  /**
   * Return points with scores better than this threshold.
   *
   * @generated from field: optional float score_threshold = 7;
   */
  scoreThreshold?: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 8;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 9;
   */
  withVectors?: WithVectorsSelector;

  /**
   * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 10;
   */
  lookupFrom?: LookupLocation;

  /**
   * Max number of points. Default is 3.
   *
   * @generated from field: optional uint64 limit = 11;
   */
  limit?: bigint;

  /**
   * Maximum amount of points to return per group. Default to 10.
   *
   * @generated from field: optional uint64 group_size = 12;
   */
  groupSize?: bigint;

  /**
   * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
   *
   * @generated from field: string group_by = 13;
   */
  groupBy: string;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
   */
  readConsistency?: ReadConsistency;

  /**
   * Options for specifying how to use the group id to lookup points in another collection
   *
   * @generated from field: optional qdrant.WithLookup with_lookup = 15;
   */
  withLookup?: WithLookup;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 16;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 17;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.QueryPointGroups.
 * Use `create(QueryPointGroupsSchema)` to create a new message.
 */
export const QueryPointGroupsSchema: GenMessage<QueryPointGroups> = /*@__PURE__*/
  messageDesc(file_points, 72);

/**
 * @generated from message qdrant.FacetCounts
 */
export type FacetCounts = Message<"qdrant.FacetCounts"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Payload key of the facet
   *
   * @generated from field: string key = 2;
   */
  key: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * Max number of facets. Default is 10.
   *
   * @generated from field: optional uint64 limit = 4;
   */
  limit?: bigint;

  /**
   * If true, return exact counts, slower but useful for debugging purposes. Default is false.
   *
   * @generated from field: optional bool exact = 5;
   */
  exact?: boolean;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 6;
   */
  timeout?: bigint;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 7;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 8;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.FacetCounts.
 * Use `create(FacetCountsSchema)` to create a new message.
 */
export const FacetCountsSchema: GenMessage<FacetCounts> = /*@__PURE__*/
  messageDesc(file_points, 73);

/**
 * @generated from message qdrant.FacetValue
 */
export type FacetValue = Message<"qdrant.FacetValue"> & {
  /**
   * @generated from oneof qdrant.FacetValue.variant
   */
  variant: {
    /**
     * String value from the facet
     *
     * @generated from field: string string_value = 1;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * Integer value from the facet
     *
     * @generated from field: int64 integer_value = 2;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * Boolean value from the facet
     *
     * @generated from field: bool bool_value = 3;
     */
    value: boolean;
    case: "boolValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.FacetValue.
 * Use `create(FacetValueSchema)` to create a new message.
 */
export const FacetValueSchema: GenMessage<FacetValue> = /*@__PURE__*/
  messageDesc(file_points, 74);

/**
 * @generated from message qdrant.FacetHit
 */
export type FacetHit = Message<"qdrant.FacetHit"> & {
  /**
   * Value from the facet
   *
   * @generated from field: qdrant.FacetValue value = 1;
   */
  value?: FacetValue;

  /**
   * Number of points with this value
   *
   * @generated from field: uint64 count = 2;
   */
  count: bigint;
};

/**
 * Describes the message qdrant.FacetHit.
 * Use `create(FacetHitSchema)` to create a new message.
 */
export const FacetHitSchema: GenMessage<FacetHit> = /*@__PURE__*/
  messageDesc(file_points, 75);

/**
 * @generated from message qdrant.SearchMatrixPoints
 */
export type SearchMatrixPoints = Message<"qdrant.SearchMatrixPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * How many points to select and search within. Default is 10.
   *
   * @generated from field: optional uint64 sample = 3;
   */
  sample?: bigint;

  /**
   * How many neighbours per sample to find. Default is 3.
   *
   * @generated from field: optional uint64 limit = 4;
   */
  limit?: bigint;

  /**
   * Define which vector to use for querying. If missing, the default vector is is used.
   *
   * @generated from field: optional string using = 5;
   */
  using?: string;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 6;
   */
  timeout?: bigint;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 7;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 8;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.SearchMatrixPoints.
 * Use `create(SearchMatrixPointsSchema)` to create a new message.
 */
export const SearchMatrixPointsSchema: GenMessage<SearchMatrixPoints> = /*@__PURE__*/
  messageDesc(file_points, 76);

/**
 * @generated from message qdrant.SearchMatrixPairs
 */
export type SearchMatrixPairs = Message<"qdrant.SearchMatrixPairs"> & {
  /**
   * List of pairs of points with scores
   *
   * @generated from field: repeated qdrant.SearchMatrixPair pairs = 1;
   */
  pairs: SearchMatrixPair[];
};

/**
 * Describes the message qdrant.SearchMatrixPairs.
 * Use `create(SearchMatrixPairsSchema)` to create a new message.
 */
export const SearchMatrixPairsSchema: GenMessage<SearchMatrixPairs> = /*@__PURE__*/
  messageDesc(file_points, 77);

/**
 * @generated from message qdrant.SearchMatrixPair
 */
export type SearchMatrixPair = Message<"qdrant.SearchMatrixPair"> & {
  /**
   * first id of the pair
   *
   * @generated from field: qdrant.PointId a = 1;
   */
  a?: PointId;

  /**
   * second id of the pair
   *
   * @generated from field: qdrant.PointId b = 2;
   */
  b?: PointId;

  /**
   * score of the pair
   *
   * @generated from field: float score = 3;
   */
  score: number;
};

/**
 * Describes the message qdrant.SearchMatrixPair.
 * Use `create(SearchMatrixPairSchema)` to create a new message.
 */
export const SearchMatrixPairSchema: GenMessage<SearchMatrixPair> = /*@__PURE__*/
  messageDesc(file_points, 78);

/**
 * @generated from message qdrant.SearchMatrixOffsets
 */
export type SearchMatrixOffsets = Message<"qdrant.SearchMatrixOffsets"> & {
  /**
   * Row indices of the matrix
   *
   * @generated from field: repeated uint64 offsets_row = 1;
   */
  offsetsRow: bigint[];

  /**
   * Column indices of the matrix
   *
   * @generated from field: repeated uint64 offsets_col = 2;
   */
  offsetsCol: bigint[];

  /**
   * Scores associated with matrix coordinates
   *
   * @generated from field: repeated float scores = 3;
   */
  scores: number[];

  /**
   * Ids of the points in order
   *
   * @generated from field: repeated qdrant.PointId ids = 4;
   */
  ids: PointId[];
};

/**
 * Describes the message qdrant.SearchMatrixOffsets.
 * Use `create(SearchMatrixOffsetsSchema)` to create a new message.
 */
export const SearchMatrixOffsetsSchema: GenMessage<SearchMatrixOffsets> = /*@__PURE__*/
  messageDesc(file_points, 79);

/**
 * @generated from message qdrant.PointsUpdateOperation
 */
export type PointsUpdateOperation = Message<"qdrant.PointsUpdateOperation"> & {
  /**
   * @generated from oneof qdrant.PointsUpdateOperation.operation
   */
  operation: {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.PointStructList upsert = 1;
     */
    value: PointsUpdateOperation_PointStructList;
    case: "upsert";
  } | {
    /**
     * @generated from field: qdrant.PointsSelector delete_deprecated = 2 [deprecated = true];
     * @deprecated
     */
    value: PointsSelector;
    case: "deleteDeprecated";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.SetPayload set_payload = 3;
     */
    value: PointsUpdateOperation_SetPayload;
    case: "setPayload";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.OverwritePayload overwrite_payload = 4;
     */
    value: PointsUpdateOperation_OverwritePayload;
    case: "overwritePayload";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.DeletePayload delete_payload = 5;
     */
    value: PointsUpdateOperation_DeletePayload;
    case: "deletePayload";
  } | {
    /**
     * @generated from field: qdrant.PointsSelector clear_payload_deprecated = 6 [deprecated = true];
     * @deprecated
     */
    value: PointsSelector;
    case: "clearPayloadDeprecated";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.UpdateVectors update_vectors = 7;
     */
    value: PointsUpdateOperation_UpdateVectors;
    case: "updateVectors";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.DeleteVectors delete_vectors = 8;
     */
    value: PointsUpdateOperation_DeleteVectors;
    case: "deleteVectors";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.DeletePoints delete_points = 9;
     */
    value: PointsUpdateOperation_DeletePoints;
    case: "deletePoints";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.ClearPayload clear_payload = 10;
     */
    value: PointsUpdateOperation_ClearPayload;
    case: "clearPayload";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.PointsUpdateOperation.
 * Use `create(PointsUpdateOperationSchema)` to create a new message.
 */
export const PointsUpdateOperationSchema: GenMessage<PointsUpdateOperation> = /*@__PURE__*/
  messageDesc(file_points, 80);

/**
 * @generated from message qdrant.PointsUpdateOperation.PointStructList
 */
export type PointsUpdateOperation_PointStructList = Message<"qdrant.PointsUpdateOperation.PointStructList"> & {
  /**
   * @generated from field: repeated qdrant.PointStruct points = 1;
   */
  points: PointStruct[];

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated, others will be inserted
   *
   * @generated from field: optional qdrant.Filter update_filter = 3;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.PointStructList.
 * Use `create(PointsUpdateOperation_PointStructListSchema)` to create a new message.
 */
export const PointsUpdateOperation_PointStructListSchema: GenMessage<PointsUpdateOperation_PointStructList> = /*@__PURE__*/
  messageDesc(file_points, 80, 0);

/**
 * @generated from message qdrant.PointsUpdateOperation.SetPayload
 */
export type PointsUpdateOperation_SetPayload = Message<"qdrant.PointsUpdateOperation.SetPayload"> & {
  /**
   * @generated from field: map<string, qdrant.Value> payload = 1;
   */
  payload: { [key: string]: Value };

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 2;
   */
  pointsSelector?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Option for indicate property of payload
   *
   * @generated from field: optional string key = 4;
   */
  key?: string;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.SetPayload.
 * Use `create(PointsUpdateOperation_SetPayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_SetPayloadSchema: GenMessage<PointsUpdateOperation_SetPayload> = /*@__PURE__*/
  messageDesc(file_points, 80, 1);

/**
 * @generated from message qdrant.PointsUpdateOperation.OverwritePayload
 */
export type PointsUpdateOperation_OverwritePayload = Message<"qdrant.PointsUpdateOperation.OverwritePayload"> & {
  /**
   * @generated from field: map<string, qdrant.Value> payload = 1;
   */
  payload: { [key: string]: Value };

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 2;
   */
  pointsSelector?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Option for indicate property of payload
   *
   * @generated from field: optional string key = 4;
   */
  key?: string;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.OverwritePayload.
 * Use `create(PointsUpdateOperation_OverwritePayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_OverwritePayloadSchema: GenMessage<PointsUpdateOperation_OverwritePayload> = /*@__PURE__*/
  messageDesc(file_points, 80, 2);

/**
 * @generated from message qdrant.PointsUpdateOperation.DeletePayload
 */
export type PointsUpdateOperation_DeletePayload = Message<"qdrant.PointsUpdateOperation.DeletePayload"> & {
  /**
   * @generated from field: repeated string keys = 1;
   */
  keys: string[];

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 2;
   */
  pointsSelector?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.DeletePayload.
 * Use `create(PointsUpdateOperation_DeletePayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_DeletePayloadSchema: GenMessage<PointsUpdateOperation_DeletePayload> = /*@__PURE__*/
  messageDesc(file_points, 80, 3);

/**
 * @generated from message qdrant.PointsUpdateOperation.UpdateVectors
 */
export type PointsUpdateOperation_UpdateVectors = Message<"qdrant.PointsUpdateOperation.UpdateVectors"> & {
  /**
   * List of points and vectors to update
   *
   * @generated from field: repeated qdrant.PointVectors points = 1;
   */
  points: PointVectors[];

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated
   *
   * @generated from field: optional qdrant.Filter update_filter = 3;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.UpdateVectors.
 * Use `create(PointsUpdateOperation_UpdateVectorsSchema)` to create a new message.
 */
export const PointsUpdateOperation_UpdateVectorsSchema: GenMessage<PointsUpdateOperation_UpdateVectors> = /*@__PURE__*/
  messageDesc(file_points, 80, 4);

/**
 * @generated from message qdrant.PointsUpdateOperation.DeleteVectors
 */
export type PointsUpdateOperation_DeleteVectors = Message<"qdrant.PointsUpdateOperation.DeleteVectors"> & {
  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points_selector = 1;
   */
  pointsSelector?: PointsSelector;

  /**
   * List of vector names to delete
   *
   * @generated from field: qdrant.VectorsSelector vectors = 2;
   */
  vectors?: VectorsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.DeleteVectors.
 * Use `create(PointsUpdateOperation_DeleteVectorsSchema)` to create a new message.
 */
export const PointsUpdateOperation_DeleteVectorsSchema: GenMessage<PointsUpdateOperation_DeleteVectors> = /*@__PURE__*/
  messageDesc(file_points, 80, 5);

/**
 * @generated from message qdrant.PointsUpdateOperation.DeletePoints
 */
export type PointsUpdateOperation_DeletePoints = Message<"qdrant.PointsUpdateOperation.DeletePoints"> & {
  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 1;
   */
  points?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.DeletePoints.
 * Use `create(PointsUpdateOperation_DeletePointsSchema)` to create a new message.
 */
export const PointsUpdateOperation_DeletePointsSchema: GenMessage<PointsUpdateOperation_DeletePoints> = /*@__PURE__*/
  messageDesc(file_points, 80, 6);

/**
 * @generated from message qdrant.PointsUpdateOperation.ClearPayload
 */
export type PointsUpdateOperation_ClearPayload = Message<"qdrant.PointsUpdateOperation.ClearPayload"> & {
  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 1;
   */
  points?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.ClearPayload.
 * Use `create(PointsUpdateOperation_ClearPayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_ClearPayloadSchema: GenMessage<PointsUpdateOperation_ClearPayload> = /*@__PURE__*/
  messageDesc(file_points, 80, 7);

/**
 * @generated from message qdrant.UpdateBatchPoints
 */
export type UpdateBatchPoints = Message<"qdrant.UpdateBatchPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * @generated from field: repeated qdrant.PointsUpdateOperation operations = 3;
   */
  operations: PointsUpdateOperation[];

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;
};

/**
 * Describes the message qdrant.UpdateBatchPoints.
 * Use `create(UpdateBatchPointsSchema)` to create a new message.
 */
export const UpdateBatchPointsSchema: GenMessage<UpdateBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 81);

/**
 * @generated from message qdrant.PointsOperationResponse
 */
export type PointsOperationResponse = Message<"qdrant.PointsOperationResponse"> & {
  /**
   * @generated from field: qdrant.UpdateResult result = 1;
   */
  result?: UpdateResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.PointsOperationResponse.
 * Use `create(PointsOperationResponseSchema)` to create a new message.
 */
export const PointsOperationResponseSchema: GenMessage<PointsOperationResponse> = /*@__PURE__*/
  messageDesc(file_points, 82);

/**
 * @generated from message qdrant.UpdateResult
 */
export type UpdateResult = Message<"qdrant.UpdateResult"> & {
  /**
   * Number of operation
   *
   * @generated from field: optional uint64 operation_id = 1;
   */
  operationId?: bigint;

  /**
   * Operation status
   *
   * @generated from field: qdrant.UpdateStatus status = 2;
   */
  status: UpdateStatus;
};

/**
 * Describes the message qdrant.UpdateResult.
 * Use `create(UpdateResultSchema)` to create a new message.
 */
export const UpdateResultSchema: GenMessage<UpdateResult> = /*@__PURE__*/
  messageDesc(file_points, 83);

/**
 * @generated from message qdrant.OrderValue
 */
export type OrderValue = Message<"qdrant.OrderValue"> & {
  /**
   * @generated from oneof qdrant.OrderValue.variant
   */
  variant: {
    /**
     * @generated from field: int64 int = 1;
     */
    value: bigint;
    case: "int";
  } | {
    /**
     * @generated from field: double float = 2;
     */
    value: number;
    case: "float";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.OrderValue.
 * Use `create(OrderValueSchema)` to create a new message.
 */
export const OrderValueSchema: GenMessage<OrderValue> = /*@__PURE__*/
  messageDesc(file_points, 84);

/**
 * @generated from message qdrant.ScoredPoint
 */
export type ScoredPoint = Message<"qdrant.ScoredPoint"> & {
  /**
   * Point id
   *
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * Payload
   *
   * @generated from field: map<string, qdrant.Value> payload = 2;
   */
  payload: { [key: string]: Value };

  /**
   * Similarity score
   *
   * @generated from field: float score = 3;
   */
  score: number;

  /**
   * Last update operation applied to this point
   *
   * @generated from field: uint64 version = 5;
   */
  version: bigint;

  /**
   * Vectors to search
   *
   * @generated from field: optional qdrant.VectorsOutput vectors = 6;
   */
  vectors?: VectorsOutput;

  /**
   * Shard key
   *
   * @generated from field: optional qdrant.ShardKey shard_key = 7;
   */
  shardKey?: ShardKey;

  /**
   * Order by value
   *
   * @generated from field: optional qdrant.OrderValue order_value = 8;
   */
  orderValue?: OrderValue;
};

/**
 * Describes the message qdrant.ScoredPoint.
 * Use `create(ScoredPointSchema)` to create a new message.
 */
export const ScoredPointSchema: GenMessage<ScoredPoint> = /*@__PURE__*/
  messageDesc(file_points, 85);

/**
 * @generated from message qdrant.GroupId
 */
export type GroupId = Message<"qdrant.GroupId"> & {
  /**
   * @generated from oneof qdrant.GroupId.kind
   */
  kind: {
    /**
     * Represents a double value.
     *
     * @generated from field: uint64 unsigned_value = 1;
     */
    value: bigint;
    case: "unsignedValue";
  } | {
    /**
     * Represents an integer value
     *
     * @generated from field: int64 integer_value = 2;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * Represents a string value.
     *
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.GroupId.
 * Use `create(GroupIdSchema)` to create a new message.
 */
export const GroupIdSchema: GenMessage<GroupId> = /*@__PURE__*/
  messageDesc(file_points, 86);

/**
 * @generated from message qdrant.PointGroup
 */
export type PointGroup = Message<"qdrant.PointGroup"> & {
  /**
   * Group id
   *
   * @generated from field: qdrant.GroupId id = 1;
   */
  id?: GroupId;

  /**
   * Points in the group
   *
   * @generated from field: repeated qdrant.ScoredPoint hits = 2;
   */
  hits: ScoredPoint[];

  /**
   * Point(s) from the lookup collection that matches the group id
   *
   * @generated from field: qdrant.RetrievedPoint lookup = 3;
   */
  lookup?: RetrievedPoint;
};

/**
 * Describes the message qdrant.PointGroup.
 * Use `create(PointGroupSchema)` to create a new message.
 */
export const PointGroupSchema: GenMessage<PointGroup> = /*@__PURE__*/
  messageDesc(file_points, 87);

/**
 * @generated from message qdrant.GroupsResult
 */
export type GroupsResult = Message<"qdrant.GroupsResult"> & {
  /**
   * Groups
   *
   * @generated from field: repeated qdrant.PointGroup groups = 1;
   */
  groups: PointGroup[];
};

/**
 * Describes the message qdrant.GroupsResult.
 * Use `create(GroupsResultSchema)` to create a new message.
 */
export const GroupsResultSchema: GenMessage<GroupsResult> = /*@__PURE__*/
  messageDesc(file_points, 88);

/**
 * @generated from message qdrant.SearchResponse
 */
export type SearchResponse = Message<"qdrant.SearchResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchResponse.
 * Use `create(SearchResponseSchema)` to create a new message.
 */
export const SearchResponseSchema: GenMessage<SearchResponse> = /*@__PURE__*/
  messageDesc(file_points, 89);

/**
 * @generated from message qdrant.QueryResponse
 */
export type QueryResponse = Message<"qdrant.QueryResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.QueryResponse.
 * Use `create(QueryResponseSchema)` to create a new message.
 */
export const QueryResponseSchema: GenMessage<QueryResponse> = /*@__PURE__*/
  messageDesc(file_points, 90);

/**
 * @generated from message qdrant.QueryBatchResponse
 */
export type QueryBatchResponse = Message<"qdrant.QueryBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.QueryBatchResponse.
 * Use `create(QueryBatchResponseSchema)` to create a new message.
 */
export const QueryBatchResponseSchema: GenMessage<QueryBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 91);

/**
 * @generated from message qdrant.QueryGroupsResponse
 */
export type QueryGroupsResponse = Message<"qdrant.QueryGroupsResponse"> & {
  /**
   * @generated from field: qdrant.GroupsResult result = 1;
   */
  result?: GroupsResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.QueryGroupsResponse.
 * Use `create(QueryGroupsResponseSchema)` to create a new message.
 */
export const QueryGroupsResponseSchema: GenMessage<QueryGroupsResponse> = /*@__PURE__*/
  messageDesc(file_points, 92);

/**
 * @generated from message qdrant.BatchResult
 */
export type BatchResult = Message<"qdrant.BatchResult"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];
};

/**
 * Describes the message qdrant.BatchResult.
 * Use `create(BatchResultSchema)` to create a new message.
 */
export const BatchResultSchema: GenMessage<BatchResult> = /*@__PURE__*/
  messageDesc(file_points, 93);

/**
 * @generated from message qdrant.SearchBatchResponse
 */
export type SearchBatchResponse = Message<"qdrant.SearchBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchBatchResponse.
 * Use `create(SearchBatchResponseSchema)` to create a new message.
 */
export const SearchBatchResponseSchema: GenMessage<SearchBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 94);

/**
 * @generated from message qdrant.SearchGroupsResponse
 */
export type SearchGroupsResponse = Message<"qdrant.SearchGroupsResponse"> & {
  /**
   * @generated from field: qdrant.GroupsResult result = 1;
   */
  result?: GroupsResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchGroupsResponse.
 * Use `create(SearchGroupsResponseSchema)` to create a new message.
 */
export const SearchGroupsResponseSchema: GenMessage<SearchGroupsResponse> = /*@__PURE__*/
  messageDesc(file_points, 95);

/**
 * @generated from message qdrant.CountResponse
 */
export type CountResponse = Message<"qdrant.CountResponse"> & {
  /**
   * @generated from field: qdrant.CountResult result = 1;
   */
  result?: CountResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.CountResponse.
 * Use `create(CountResponseSchema)` to create a new message.
 */
export const CountResponseSchema: GenMessage<CountResponse> = /*@__PURE__*/
  messageDesc(file_points, 96);

/**
 * @generated from message qdrant.ScrollResponse
 */
export type ScrollResponse = Message<"qdrant.ScrollResponse"> & {
  /**
   * Use this offset for the next query
   *
   * @generated from field: optional qdrant.PointId next_page_offset = 1;
   */
  nextPageOffset?: PointId;

  /**
   * @generated from field: repeated qdrant.RetrievedPoint result = 2;
   */
  result: RetrievedPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 3;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 4;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.ScrollResponse.
 * Use `create(ScrollResponseSchema)` to create a new message.
 */
export const ScrollResponseSchema: GenMessage<ScrollResponse> = /*@__PURE__*/
  messageDesc(file_points, 97);

/**
 * @generated from message qdrant.CountResult
 */
export type CountResult = Message<"qdrant.CountResult"> & {
  /**
   * @generated from field: uint64 count = 1;
   */
  count: bigint;
};

/**
 * Describes the message qdrant.CountResult.
 * Use `create(CountResultSchema)` to create a new message.
 */
export const CountResultSchema: GenMessage<CountResult> = /*@__PURE__*/
  messageDesc(file_points, 98);

/**
 * @generated from message qdrant.RetrievedPoint
 */
export type RetrievedPoint = Message<"qdrant.RetrievedPoint"> & {
  /**
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * @generated from field: map<string, qdrant.Value> payload = 2;
   */
  payload: { [key: string]: Value };

  /**
   * @generated from field: optional qdrant.VectorsOutput vectors = 4;
   */
  vectors?: VectorsOutput;

  /**
   * Shard key
   *
   * @generated from field: optional qdrant.ShardKey shard_key = 5;
   */
  shardKey?: ShardKey;

  /**
   * Order-by value
   *
   * @generated from field: optional qdrant.OrderValue order_value = 6;
   */
  orderValue?: OrderValue;
};

/**
 * Describes the message qdrant.RetrievedPoint.
 * Use `create(RetrievedPointSchema)` to create a new message.
 */
export const RetrievedPointSchema: GenMessage<RetrievedPoint> = /*@__PURE__*/
  messageDesc(file_points, 99);

/**
 * @generated from message qdrant.GetResponse
 */
export type GetResponse = Message<"qdrant.GetResponse"> & {
  /**
   * @generated from field: repeated qdrant.RetrievedPoint result = 1;
   */
  result: RetrievedPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.GetResponse.
 * Use `create(GetResponseSchema)` to create a new message.
 */
export const GetResponseSchema: GenMessage<GetResponse> = /*@__PURE__*/
  messageDesc(file_points, 100);

/**
 * @generated from message qdrant.RecommendResponse
 */
export type RecommendResponse = Message<"qdrant.RecommendResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.RecommendResponse.
 * Use `create(RecommendResponseSchema)` to create a new message.
 */
export const RecommendResponseSchema: GenMessage<RecommendResponse> = /*@__PURE__*/
  messageDesc(file_points, 101);

/**
 * @generated from message qdrant.RecommendBatchResponse
 */
export type RecommendBatchResponse = Message<"qdrant.RecommendBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.RecommendBatchResponse.
 * Use `create(RecommendBatchResponseSchema)` to create a new message.
 */
export const RecommendBatchResponseSchema: GenMessage<RecommendBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 102);

/**
 * @generated from message qdrant.DiscoverResponse
 */
export type DiscoverResponse = Message<"qdrant.DiscoverResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.DiscoverResponse.
 * Use `create(DiscoverResponseSchema)` to create a new message.
 */
export const DiscoverResponseSchema: GenMessage<DiscoverResponse> = /*@__PURE__*/
  messageDesc(file_points, 103);

/**
 * @generated from message qdrant.DiscoverBatchResponse
 */
export type DiscoverBatchResponse = Message<"qdrant.DiscoverBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.DiscoverBatchResponse.
 * Use `create(DiscoverBatchResponseSchema)` to create a new message.
 */
export const DiscoverBatchResponseSchema: GenMessage<DiscoverBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 104);

/**
 * @generated from message qdrant.RecommendGroupsResponse
 */
export type RecommendGroupsResponse = Message<"qdrant.RecommendGroupsResponse"> & {
  /**
   * @generated from field: qdrant.GroupsResult result = 1;
   */
  result?: GroupsResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.RecommendGroupsResponse.
 * Use `create(RecommendGroupsResponseSchema)` to create a new message.
 */
export const RecommendGroupsResponseSchema: GenMessage<RecommendGroupsResponse> = /*@__PURE__*/
  messageDesc(file_points, 105);

/**
 * @generated from message qdrant.UpdateBatchResponse
 */
export type UpdateBatchResponse = Message<"qdrant.UpdateBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.UpdateResult result = 1;
   */
  result: UpdateResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.UpdateBatchResponse.
 * Use `create(UpdateBatchResponseSchema)` to create a new message.
 */
export const UpdateBatchResponseSchema: GenMessage<UpdateBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 106);

/**
 * @generated from message qdrant.FacetResponse
 */
export type FacetResponse = Message<"qdrant.FacetResponse"> & {
  /**
   * @generated from field: repeated qdrant.FacetHit hits = 1;
   */
  hits: FacetHit[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.FacetResponse.
 * Use `create(FacetResponseSchema)` to create a new message.
 */
export const FacetResponseSchema: GenMessage<FacetResponse> = /*@__PURE__*/
  messageDesc(file_points, 107);

/**
 * @generated from message qdrant.SearchMatrixPairsResponse
 */
export type SearchMatrixPairsResponse = Message<"qdrant.SearchMatrixPairsResponse"> & {
  /**
   * @generated from field: qdrant.SearchMatrixPairs result = 1;
   */
  result?: SearchMatrixPairs;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchMatrixPairsResponse.
 * Use `create(SearchMatrixPairsResponseSchema)` to create a new message.
 */
export const SearchMatrixPairsResponseSchema: GenMessage<SearchMatrixPairsResponse> = /*@__PURE__*/
  messageDesc(file_points, 108);

/**
 * @generated from message qdrant.SearchMatrixOffsetsResponse
 */
export type SearchMatrixOffsetsResponse = Message<"qdrant.SearchMatrixOffsetsResponse"> & {
  /**
   * @generated from field: qdrant.SearchMatrixOffsets result = 1;
   */
  result?: SearchMatrixOffsets;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchMatrixOffsetsResponse.
 * Use `create(SearchMatrixOffsetsResponseSchema)` to create a new message.
 */
export const SearchMatrixOffsetsResponseSchema: GenMessage<SearchMatrixOffsetsResponse> = /*@__PURE__*/
  messageDesc(file_points, 109);

/**
 * @generated from message qdrant.PointsSelector
 */
export type PointsSelector = Message<"qdrant.PointsSelector"> & {
  /**
   * @generated from oneof qdrant.PointsSelector.points_selector_one_of
   */
  pointsSelectorOneOf: {
    /**
     * @generated from field: qdrant.PointsIdsList points = 1;
     */
    value: PointsIdsList;
    case: "points";
  } | {
    /**
     * @generated from field: qdrant.Filter filter = 2;
     */
    value: Filter;
    case: "filter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.PointsSelector.
 * Use `create(PointsSelectorSchema)` to create a new message.
 */
export const PointsSelectorSchema: GenMessage<PointsSelector> = /*@__PURE__*/
  messageDesc(file_points, 110);

/**
 * @generated from message qdrant.PointsIdsList
 */
export type PointsIdsList = Message<"qdrant.PointsIdsList"> & {
  /**
   * @generated from field: repeated qdrant.PointId ids = 1;
   */
  ids: PointId[];
};

/**
 * Describes the message qdrant.PointsIdsList.
 * Use `create(PointsIdsListSchema)` to create a new message.
 */
export const PointsIdsListSchema: GenMessage<PointsIdsList> = /*@__PURE__*/
  messageDesc(file_points, 111);

/**
 * @generated from message qdrant.PointStruct
 */
export type PointStruct = Message<"qdrant.PointStruct"> & {
  /**
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * @generated from field: map<string, qdrant.Value> payload = 3;
   */
  payload: { [key: string]: Value };

  /**
   * @generated from field: optional qdrant.Vectors vectors = 4;
   */
  vectors?: Vectors;
};

/**
 * Describes the message qdrant.PointStruct.
 * Use `create(PointStructSchema)` to create a new message.
 */
export const PointStructSchema: GenMessage<PointStruct> = /*@__PURE__*/
  messageDesc(file_points, 112);

/**
 * ---------------------------------------------
 * ----------- Measurements collector ----------
 * ---------------------------------------------
 *
 * @generated from message qdrant.Usage
 */
export type Usage = Message<"qdrant.Usage"> & {
  /**
   * @generated from field: optional qdrant.HardwareUsage hardware = 1;
   */
  hardware?: HardwareUsage;

  /**
   * @generated from field: optional qdrant.InferenceUsage inference = 2;
   */
  inference?: InferenceUsage;
};

/**
 * Describes the message qdrant.Usage.
 * Use `create(UsageSchema)` to create a new message.
 */
export const UsageSchema: GenMessage<Usage> = /*@__PURE__*/
  messageDesc(file_points, 113);

/**
 * @generated from message qdrant.InferenceUsage
 */
export type InferenceUsage = Message<"qdrant.InferenceUsage"> & {
  /**
   * @generated from field: map<string, qdrant.ModelUsage> models = 1;
   */
  models: { [key: string]: ModelUsage };
};

/**
 * Describes the message qdrant.InferenceUsage.
 * Use `create(InferenceUsageSchema)` to create a new message.
 */
export const InferenceUsageSchema: GenMessage<InferenceUsage> = /*@__PURE__*/
  messageDesc(file_points, 114);

/**
 * @generated from message qdrant.ModelUsage
 */
export type ModelUsage = Message<"qdrant.ModelUsage"> & {
  /**
   * @generated from field: uint64 tokens = 1;
   */
  tokens: bigint;
};

/**
 * Describes the message qdrant.ModelUsage.
 * Use `create(ModelUsageSchema)` to create a new message.
 */
export const ModelUsageSchema: GenMessage<ModelUsage> = /*@__PURE__*/
  messageDesc(file_points, 115);

/**
 * @generated from message qdrant.HardwareUsage
 */
export type HardwareUsage = Message<"qdrant.HardwareUsage"> & {
  /**
   * @generated from field: uint64 cpu = 1;
   */
  cpu: bigint;

  /**
   * @generated from field: uint64 payload_io_read = 2;
   */
  payloadIoRead: bigint;

  /**
   * @generated from field: uint64 payload_io_write = 3;
   */
  payloadIoWrite: bigint;

  /**
   * @generated from field: uint64 payload_index_io_read = 4;
   */
  payloadIndexIoRead: bigint;

  /**
   * @generated from field: uint64 payload_index_io_write = 5;
   */
  payloadIndexIoWrite: bigint;

  /**
   * @generated from field: uint64 vector_io_read = 6;
   */
  vectorIoRead: bigint;

  /**
   * @generated from field: uint64 vector_io_write = 7;
   */
  vectorIoWrite: bigint;
};

/**
 * Describes the message qdrant.HardwareUsage.
 * Use `create(HardwareUsageSchema)` to create a new message.
 */
export const HardwareUsageSchema: GenMessage<HardwareUsage> = /*@__PURE__*/
  messageDesc(file_points, 116);

/**
 * @generated from enum qdrant.WriteOrderingType
 */
export enum WriteOrderingType {
  /**
   * Write operations may be reordered, works faster, default
   *
   * @generated from enum value: Weak = 0;
   */
  Weak = 0,

  /**
   * Write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change
   *
   * @generated from enum value: Medium = 1;
   */
  Medium = 1,

  /**
   * Write operations go through the permanent leader, consistent, but may be unavailable if leader is down
   *
   * @generated from enum value: Strong = 2;
   */
  Strong = 2,
}

/**
 * Describes the enum qdrant.WriteOrderingType.
 */
export const WriteOrderingTypeSchema: GenEnum<WriteOrderingType> = /*@__PURE__*/
  enumDesc(file_points, 0);

/**
 * @generated from enum qdrant.ReadConsistencyType
 */
export enum ReadConsistencyType {
  /**
   * Send request to all nodes and return points which are present on all of them
   *
   * @generated from enum value: All = 0;
   */
  All = 0,

  /**
   * Send requests to all nodes and return points which are present on majority of them
   *
   * @generated from enum value: Majority = 1;
   */
  Majority = 1,

  /**
   * Send requests to half + 1 nodes, return points which are present on all of them
   *
   * @generated from enum value: Quorum = 2;
   */
  Quorum = 2,
}

/**
 * Describes the enum qdrant.ReadConsistencyType.
 */
export const ReadConsistencyTypeSchema: GenEnum<ReadConsistencyType> = /*@__PURE__*/
  enumDesc(file_points, 1);

/**
 * @generated from enum qdrant.FieldType
 */
export enum FieldType {
  /**
   * @generated from enum value: FieldTypeKeyword = 0;
   */
  FieldTypeKeyword = 0,

  /**
   * @generated from enum value: FieldTypeInteger = 1;
   */
  FieldTypeInteger = 1,

  /**
   * @generated from enum value: FieldTypeFloat = 2;
   */
  FieldTypeFloat = 2,

  /**
   * @generated from enum value: FieldTypeGeo = 3;
   */
  FieldTypeGeo = 3,

  /**
   * @generated from enum value: FieldTypeText = 4;
   */
  FieldTypeText = 4,

  /**
   * @generated from enum value: FieldTypeBool = 5;
   */
  FieldTypeBool = 5,

  /**
   * @generated from enum value: FieldTypeDatetime = 6;
   */
  FieldTypeDatetime = 6,

  /**
   * @generated from enum value: FieldTypeUuid = 7;
   */
  FieldTypeUuid = 7,
}

/**
 * Describes the enum qdrant.FieldType.
 */
export const FieldTypeSchema: GenEnum<FieldType> = /*@__PURE__*/
  enumDesc(file_points, 2);

/**
 * @generated from enum qdrant.Direction
 */
export enum Direction {
  /**
   * @generated from enum value: Asc = 0;
   */
  Asc = 0,

  /**
   * @generated from enum value: Desc = 1;
   */
  Desc = 1,
}

/**
 * Describes the enum qdrant.Direction.
 */
export const DirectionSchema: GenEnum<Direction> = /*@__PURE__*/
  enumDesc(file_points, 3);

/**
 * How to use positive and negative vectors to find the results, default is `AverageVector`.
 *
 * @generated from enum qdrant.RecommendStrategy
 */
export enum RecommendStrategy {
  /**
   * Average positive and negative vectors and create a single query with the formula
   * `query = avg_pos + avg_pos - avg_neg`. Then performs normal search.
   *
   * @generated from enum value: AverageVector = 0;
   */
  AverageVector = 0,

  /**
   * Uses custom search objective. Each candidate is compared against all
   * examples, its score is then chosen from the `max(max_pos_score, max_neg_score)`.
   * If the `max_neg_score` is chosen then it is squared and negated.
   *
   * @generated from enum value: BestScore = 1;
   */
  BestScore = 1,

  /**
   * Uses custom search objective. Compares against all inputs, sums all the scores.
   * Scores against positive vectors are added, against negatives are subtracted.
   *
   * @generated from enum value: SumScores = 2;
   */
  SumScores = 2,
}

/**
 * Describes the enum qdrant.RecommendStrategy.
 */
export const RecommendStrategySchema: GenEnum<RecommendStrategy> = /*@__PURE__*/
  enumDesc(file_points, 4);

/**
 * @generated from enum qdrant.Fusion
 */
export enum Fusion {
  /**
   * Reciprocal Rank Fusion (with default parameters)
   *
   * @generated from enum value: RRF = 0;
   */
  RRF = 0,

  /**
   * Distribution-Based Score Fusion
   *
   * @generated from enum value: DBSF = 1;
   */
  DBSF = 1,
}

/**
 * Describes the enum qdrant.Fusion.
 */
export const FusionSchema: GenEnum<Fusion> = /*@__PURE__*/
  enumDesc(file_points, 5);

/**
 * Sample points from the collection
 *
 * Available sampling methods:
 *
 * * `random` - Random sampling
 *
 * @generated from enum qdrant.Sample
 */
export enum Sample {
  /**
   * @generated from enum value: Random = 0;
   */
  Random = 0,
}

/**
 * Describes the enum qdrant.Sample.
 */
export const SampleSchema: GenEnum<Sample> = /*@__PURE__*/
  enumDesc(file_points, 6);

/**
 * @generated from enum qdrant.UpdateStatus
 */
export enum UpdateStatus {
  /**
   * @generated from enum value: UnknownUpdateStatus = 0;
   */
  UnknownUpdateStatus = 0,

  /**
   * Update is received, but not processed yet
   *
   * @generated from enum value: Acknowledged = 1;
   */
  Acknowledged = 1,

  /**
   * Update is applied and ready for search
   *
   * @generated from enum value: Completed = 2;
   */
  Completed = 2,

  /**
   * Internal: update is rejected due to an outdated clock
   *
   * @generated from enum value: ClockRejected = 3;
   */
  ClockRejected = 3,
}

/**
 * Describes the enum qdrant.UpdateStatus.
 */
export const UpdateStatusSchema: GenEnum<UpdateStatus> = /*@__PURE__*/
  enumDesc(file_points, 7);

