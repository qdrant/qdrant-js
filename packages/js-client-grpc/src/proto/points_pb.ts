// @generated by protoc-gen-es v2.10.0 with parameter "target=ts,import_extension=js"
// @generated from file points.proto (package qdrant, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { PayloadIndexParams, ShardKey } from "./collections_pb.js";
import { file_collections } from "./collections_pb.js";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Value } from "./json_with_int_pb.js";
import { file_json_with_int } from "./json_with_int_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file points.proto.
 */
export const file_points: GenFile = /*@__PURE__*/
  fileDesc("Cgxwb2ludHMucHJvdG8SBnFkcmFudCI4Cg1Xcml0ZU9yZGVyaW5nEicKBHR5cGUYASABKA4yGS5xZHJhbnQuV3JpdGVPcmRlcmluZ1R5cGUiWQoPUmVhZENvbnNpc3RlbmN5EisKBHR5cGUYASABKA4yGy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5VHlwZUgAEhAKBmZhY3RvchgCIAEoBEgAQgcKBXZhbHVlIjwKB1BvaW50SWQSDQoDbnVtGAEgASgESAASDgoEdXVpZBgCIAEoCUgAQhIKEHBvaW50X2lkX29wdGlvbnMiHQoNU3BhcnNlSW5kaWNlcxIMCgRkYXRhGAEgAygNIpYBCghEb2N1bWVudBIMCgR0ZXh0GAEgASgJEg0KBW1vZGVsGAMgASgJEi4KB29wdGlvbnMYBCADKAsyHS5xZHJhbnQuRG9jdW1lbnQuT3B0aW9uc0VudHJ5Gj0KDE9wdGlvbnNFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBIqABCgVJbWFnZRIcCgVpbWFnZRgBIAEoCzINLnFkcmFudC5WYWx1ZRINCgVtb2RlbBgCIAEoCRIrCgdvcHRpb25zGAMgAygLMhoucWRyYW50LkltYWdlLk9wdGlvbnNFbnRyeRo9CgxPcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEhwKBXZhbHVlGAIgASgLMg0ucWRyYW50LlZhbHVlOgI4ASK1AQoPSW5mZXJlbmNlT2JqZWN0Eh0KBm9iamVjdBgBIAEoCzINLnFkcmFudC5WYWx1ZRINCgVtb2RlbBgCIAEoCRI1CgdvcHRpb25zGAMgAygLMiQucWRyYW50LkluZmVyZW5jZU9iamVjdC5PcHRpb25zRW50cnkaPQoMT3B0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRIcCgV2YWx1ZRgCIAEoCzINLnFkcmFudC5WYWx1ZToCOAEi9wIKBlZlY3RvchIMCgRkYXRhGAEgAygCEisKB2luZGljZXMYAiABKAsyFS5xZHJhbnQuU3BhcnNlSW5kaWNlc0gBiAEBEhoKDXZlY3RvcnNfY291bnQYAyABKA1IAogBARIkCgVkZW5zZRhlIAEoCzITLnFkcmFudC5EZW5zZVZlY3RvckgAEiYKBnNwYXJzZRhmIAEoCzIULnFkcmFudC5TcGFyc2VWZWN0b3JIABIvCgttdWx0aV9kZW5zZRhnIAEoCzIYLnFkcmFudC5NdWx0aURlbnNlVmVjdG9ySAASJAoIZG9jdW1lbnQYaCABKAsyEC5xZHJhbnQuRG9jdW1lbnRIABIeCgVpbWFnZRhpIAEoCzINLnFkcmFudC5JbWFnZUgAEikKBm9iamVjdBhqIAEoCzIXLnFkcmFudC5JbmZlcmVuY2VPYmplY3RIAEIICgZ2ZWN0b3JCCgoIX2luZGljZXNCEAoOX3ZlY3RvcnNfY291bnQijAIKDFZlY3Rvck91dHB1dBIMCgRkYXRhGAEgAygCEisKB2luZGljZXMYAiABKAsyFS5xZHJhbnQuU3BhcnNlSW5kaWNlc0gBiAEBEhoKDXZlY3RvcnNfY291bnQYAyABKA1IAogBARIkCgVkZW5zZRhlIAEoCzITLnFkcmFudC5EZW5zZVZlY3RvckgAEiYKBnNwYXJzZRhmIAEoCzIULnFkcmFudC5TcGFyc2VWZWN0b3JIABIvCgttdWx0aV9kZW5zZRhnIAEoCzIYLnFkcmFudC5NdWx0aURlbnNlVmVjdG9ySABCCAoGdmVjdG9yQgoKCF9pbmRpY2VzQhAKDl92ZWN0b3JzX2NvdW50IhsKC0RlbnNlVmVjdG9yEgwKBGRhdGEYASADKAIiLwoMU3BhcnNlVmVjdG9yEg4KBnZhbHVlcxgBIAMoAhIPCgdpbmRpY2VzGAIgAygNIjgKEE11bHRpRGVuc2VWZWN0b3ISJAoHdmVjdG9ycxgBIAMoCzITLnFkcmFudC5EZW5zZVZlY3RvciKnAgoLVmVjdG9ySW5wdXQSHQoCaWQYASABKAsyDy5xZHJhbnQuUG9pbnRJZEgAEiQKBWRlbnNlGAIgASgLMhMucWRyYW50LkRlbnNlVmVjdG9ySAASJgoGc3BhcnNlGAMgASgLMhQucWRyYW50LlNwYXJzZVZlY3RvckgAEi8KC211bHRpX2RlbnNlGAQgASgLMhgucWRyYW50Lk11bHRpRGVuc2VWZWN0b3JIABIkCghkb2N1bWVudBgFIAEoCzIQLnFkcmFudC5Eb2N1bWVudEgAEh4KBWltYWdlGAYgASgLMg0ucWRyYW50LkltYWdlSAASKQoGb2JqZWN0GAcgASgLMhcucWRyYW50LkluZmVyZW5jZU9iamVjdEgAQgkKB3ZhcmlhbnQibgoQU2hhcmRLZXlTZWxlY3RvchIkCgpzaGFyZF9rZXlzGAEgAygLMhAucWRyYW50LlNoYXJkS2V5EicKCGZhbGxiYWNrGAIgASgLMhAucWRyYW50LlNoYXJkS2V5SACIAQFCCwoJX2ZhbGxiYWNrIrMCCgxVcHNlcnRQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhEKBHdhaXQYAiABKAhIAIgBARIjCgZwb2ludHMYAyADKAsyEy5xZHJhbnQuUG9pbnRTdHJ1Y3QSLAoIb3JkZXJpbmcYBCABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gBiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgFIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAKIAQESKgoNdXBkYXRlX2ZpbHRlchgGIAEoCzIOLnFkcmFudC5GaWx0ZXJIA4gBAUIHCgVfd2FpdEILCglfb3JkZXJpbmdCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIQCg5fdXBkYXRlX2ZpbHRlciL4AQoMRGVsZXRlUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIRCgR3YWl0GAIgASgISACIAQESJgoGcG9pbnRzGAMgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9yEiwKCG9yZGVyaW5nGAQgASgLMhUucWRyYW50LldyaXRlT3JkZXJpbmdIAYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYBSABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgCiAEBQgcKBV93YWl0QgsKCV9vcmRlcmluZ0IVChNfc2hhcmRfa2V5X3NlbGVjdG9yIoUDCglHZXRQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhwKA2lkcxgCIAMoCzIPLnFkcmFudC5Qb2ludElkEjEKDHdpdGhfcGF5bG9hZBgEIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9yEjYKDHdpdGhfdmVjdG9ycxgFIAEoCzIbLnFkcmFudC5XaXRoVmVjdG9yc1NlbGVjdG9ySACIAQESNgoQcmVhZF9jb25zaXN0ZW5jeRgGIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIAYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYByABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgCiAEBEhQKB3RpbWVvdXQYCCABKARIA4gBAUIPCg1fd2l0aF92ZWN0b3JzQhMKEV9yZWFkX2NvbnNpc3RlbmN5QhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCCgoIX3RpbWVvdXRKBAgDEAQiugIKElVwZGF0ZVBvaW50VmVjdG9ycxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEiQKBnBvaW50cxgDIAMoCzIULnFkcmFudC5Qb2ludFZlY3RvcnMSLAoIb3JkZXJpbmcYBCABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gBiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgFIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAKIAQESKgoNdXBkYXRlX2ZpbHRlchgGIAEoCzIOLnFkcmFudC5GaWx0ZXJIA4gBAUIHCgVfd2FpdEILCglfb3JkZXJpbmdCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIQCg5fdXBkYXRlX2ZpbHRlciJNCgxQb2ludFZlY3RvcnMSGwoCaWQYASABKAsyDy5xZHJhbnQuUG9pbnRJZBIgCgd2ZWN0b3JzGAIgASgLMg8ucWRyYW50LlZlY3RvcnMisQIKEkRlbGV0ZVBvaW50VmVjdG9ycxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEi8KD3BvaW50c19zZWxlY3RvchgDIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvchIoCgd2ZWN0b3JzGAQgASgLMhcucWRyYW50LlZlY3RvcnNTZWxlY3RvchIsCghvcmRlcmluZxgFIAEoCzIVLnFkcmFudC5Xcml0ZU9yZGVyaW5nSAGIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAYgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAogBAUIHCgVfd2FpdEILCglfb3JkZXJpbmdCFQoTX3NoYXJkX2tleV9zZWxlY3RvciK1AwoQU2V0UGF5bG9hZFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEjYKB3BheWxvYWQYAyADKAsyJS5xZHJhbnQuU2V0UGF5bG9hZFBvaW50cy5QYXlsb2FkRW50cnkSNAoPcG9pbnRzX3NlbGVjdG9yGAUgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9ySAGIAQESLAoIb3JkZXJpbmcYBiABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gCiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgHIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAOIAQESEAoDa2V5GAggASgJSASIAQEaPQoMUGF5bG9hZEVudHJ5EgsKA2tleRgBIAEoCRIcCgV2YWx1ZRgCIAEoCzINLnFkcmFudC5WYWx1ZToCOAFCBwoFX3dhaXRCEgoQX3BvaW50c19zZWxlY3RvckILCglfb3JkZXJpbmdCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIGCgRfa2V5SgQIBBAFIrUCChNEZWxldGVQYXlsb2FkUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIRCgR3YWl0GAIgASgISACIAQESDAoEa2V5cxgDIAMoCRI0Cg9wb2ludHNfc2VsZWN0b3IYBSABKAsyFi5xZHJhbnQuUG9pbnRzU2VsZWN0b3JIAYgBARIsCghvcmRlcmluZxgGIAEoCzIVLnFkcmFudC5Xcml0ZU9yZGVyaW5nSAKIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAcgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIA4gBAUIHCgVfd2FpdEISChBfcG9pbnRzX3NlbGVjdG9yQgsKCV9vcmRlcmluZ0IVChNfc2hhcmRfa2V5X3NlbGVjdG9ySgQIBBAFIv4BChJDbGVhclBheWxvYWRQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhEKBHdhaXQYAiABKAhIAIgBARImCgZwb2ludHMYAyABKAsyFi5xZHJhbnQuUG9pbnRzU2VsZWN0b3ISLAoIb3JkZXJpbmcYBCABKAsyFS5xZHJhbnQuV3JpdGVPcmRlcmluZ0gBiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgFIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAKIAQFCBwoFX3dhaXRCCwoJX29yZGVyaW5nQhUKE19zaGFyZF9rZXlfc2VsZWN0b3IirwIKGkNyZWF0ZUZpZWxkSW5kZXhDb2xsZWN0aW9uEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIRCgR3YWl0GAIgASgISACIAQESEgoKZmllbGRfbmFtZRgDIAEoCRIqCgpmaWVsZF90eXBlGAQgASgOMhEucWRyYW50LkZpZWxkVHlwZUgBiAEBEjsKEmZpZWxkX2luZGV4X3BhcmFtcxgFIAEoCzIaLnFkcmFudC5QYXlsb2FkSW5kZXhQYXJhbXNIAogBARIsCghvcmRlcmluZxgGIAEoCzIVLnFkcmFudC5Xcml0ZU9yZGVyaW5nSAOIAQFCBwoFX3dhaXRCDQoLX2ZpZWxkX3R5cGVCFQoTX2ZpZWxkX2luZGV4X3BhcmFtc0ILCglfb3JkZXJpbmcioAEKGkRlbGV0ZUZpZWxkSW5kZXhDb2xsZWN0aW9uEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIRCgR3YWl0GAIgASgISACIAQESEgoKZmllbGRfbmFtZRgDIAEoCRIsCghvcmRlcmluZxgEIAEoCzIVLnFkcmFudC5Xcml0ZU9yZGVyaW5nSAGIAQFCBwoFX3dhaXRCCwoJX29yZGVyaW5nIigKFlBheWxvYWRJbmNsdWRlU2VsZWN0b3ISDgoGZmllbGRzGAEgAygJIigKFlBheWxvYWRFeGNsdWRlU2VsZWN0b3ISDgoGZmllbGRzGAEgAygJIqEBChNXaXRoUGF5bG9hZFNlbGVjdG9yEhAKBmVuYWJsZRgBIAEoCEgAEjEKB2luY2x1ZGUYAiABKAsyHi5xZHJhbnQuUGF5bG9hZEluY2x1ZGVTZWxlY3RvckgAEjEKB2V4Y2x1ZGUYAyABKAsyHi5xZHJhbnQuUGF5bG9hZEV4Y2x1ZGVTZWxlY3RvckgAQhIKEHNlbGVjdG9yX29wdGlvbnMiggEKDE5hbWVkVmVjdG9ycxIyCgd2ZWN0b3JzGAEgAygLMiEucWRyYW50Lk5hbWVkVmVjdG9ycy5WZWN0b3JzRW50cnkaPgoMVmVjdG9yc0VudHJ5EgsKA2tleRgBIAEoCRIdCgV2YWx1ZRgCIAEoCzIOLnFkcmFudC5WZWN0b3I6AjgBIpQBChJOYW1lZFZlY3RvcnNPdXRwdXQSOAoHdmVjdG9ycxgBIAMoCzInLnFkcmFudC5OYW1lZFZlY3RvcnNPdXRwdXQuVmVjdG9yc0VudHJ5GkQKDFZlY3RvcnNFbnRyeRILCgNrZXkYASABKAkSIwoFdmFsdWUYAiABKAsyFC5xZHJhbnQuVmVjdG9yT3V0cHV0OgI4ASJnCgdWZWN0b3JzEiAKBnZlY3RvchgBIAEoCzIOLnFkcmFudC5WZWN0b3JIABInCgd2ZWN0b3JzGAIgASgLMhQucWRyYW50Lk5hbWVkVmVjdG9yc0gAQhEKD3ZlY3RvcnNfb3B0aW9ucyJ5Cg1WZWN0b3JzT3V0cHV0EiYKBnZlY3RvchgBIAEoCzIULnFkcmFudC5WZWN0b3JPdXRwdXRIABItCgd2ZWN0b3JzGAIgASgLMhoucWRyYW50Lk5hbWVkVmVjdG9yc091dHB1dEgAQhEKD3ZlY3RvcnNfb3B0aW9ucyIgCg9WZWN0b3JzU2VsZWN0b3ISDQoFbmFtZXMYASADKAkiZwoTV2l0aFZlY3RvcnNTZWxlY3RvchIQCgZlbmFibGUYASABKAhIABIqCgdpbmNsdWRlGAIgASgLMhcucWRyYW50LlZlY3RvcnNTZWxlY3RvckgAQhIKEHNlbGVjdG9yX29wdGlvbnMiiAEKGFF1YW50aXphdGlvblNlYXJjaFBhcmFtcxITCgZpZ25vcmUYASABKAhIAIgBARIUCgdyZXNjb3JlGAIgASgISAGIAQESGQoMb3ZlcnNhbXBsaW5nGAMgASgBSAKIAQFCCQoHX2lnbm9yZUIKCghfcmVzY29yZUIPCg1fb3ZlcnNhbXBsaW5nImUKEUFjb3JuU2VhcmNoUGFyYW1zEhMKBmVuYWJsZRgBIAEoCEgAiAEBEhwKD21heF9zZWxlY3Rpdml0eRgCIAEoAUgBiAEBQgkKB19lbmFibGVCEgoQX21heF9zZWxlY3Rpdml0eSKBAgoMU2VhcmNoUGFyYW1zEhQKB2huc3dfZWYYASABKARIAIgBARISCgVleGFjdBgCIAEoCEgBiAEBEjsKDHF1YW50aXphdGlvbhgDIAEoCzIgLnFkcmFudC5RdWFudGl6YXRpb25TZWFyY2hQYXJhbXNIAogBARIZCgxpbmRleGVkX29ubHkYBCABKAhIA4gBARItCgVhY29ybhgFIAEoCzIZLnFkcmFudC5BY29yblNlYXJjaFBhcmFtc0gEiAEBQgoKCF9obnN3X2VmQggKBl9leGFjdEIPCg1fcXVhbnRpemF0aW9uQg8KDV9pbmRleGVkX29ubHlCCAoGX2Fjb3JuIpIFCgxTZWFyY2hQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEg4KBnZlY3RvchgCIAMoAhIeCgZmaWx0ZXIYAyABKAsyDi5xZHJhbnQuRmlsdGVyEg0KBWxpbWl0GAQgASgEEjEKDHdpdGhfcGF5bG9hZBgGIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9yEiQKBnBhcmFtcxgHIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXMSHAoPc2NvcmVfdGhyZXNob2xkGAggASgCSACIAQESEwoGb2Zmc2V0GAkgASgESAGIAQESGAoLdmVjdG9yX25hbWUYCiABKAlIAogBARI2Cgx3aXRoX3ZlY3RvcnMYCyABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgDiAEBEjYKEHJlYWRfY29uc2lzdGVuY3kYDCABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SASIAQESFAoHdGltZW91dBgNIAEoBEgFiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgOIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAaIAQESMgoOc3BhcnNlX2luZGljZXMYDyABKAsyFS5xZHJhbnQuU3BhcnNlSW5kaWNlc0gHiAEBQhIKEF9zY29yZV90aHJlc2hvbGRCCQoHX29mZnNldEIOCgxfdmVjdG9yX25hbWVCDwoNX3dpdGhfdmVjdG9yc0ITChFfcmVhZF9jb25zaXN0ZW5jeUIKCghfdGltZW91dEIVChNfc2hhcmRfa2V5X3NlbGVjdG9yQhEKD19zcGFyc2VfaW5kaWNlc0oECAUQBiLIAQoRU2VhcmNoQmF0Y2hQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEisKDXNlYXJjaF9wb2ludHMYAiADKAsyFC5xZHJhbnQuU2VhcmNoUG9pbnRzEjYKEHJlYWRfY29uc2lzdGVuY3kYAyABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SACIAQESFAoHdGltZW91dBgEIAEoBEgBiAEBQhMKEV9yZWFkX2NvbnNpc3RlbmN5QgoKCF90aW1lb3V0IrIBCgpXaXRoTG9va3VwEhIKCmNvbGxlY3Rpb24YASABKAkSNgoMd2l0aF9wYXlsb2FkGAIgASgLMhsucWRyYW50LldpdGhQYXlsb2FkU2VsZWN0b3JIAIgBARI2Cgx3aXRoX3ZlY3RvcnMYAyABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgBiAEBQg8KDV93aXRoX3BheWxvYWRCDwoNX3dpdGhfdmVjdG9ycyLVBQoRU2VhcmNoUG9pbnRHcm91cHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEg4KBnZlY3RvchgCIAMoAhIeCgZmaWx0ZXIYAyABKAsyDi5xZHJhbnQuRmlsdGVyEg0KBWxpbWl0GAQgASgNEjEKDHdpdGhfcGF5bG9hZBgFIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9yEiQKBnBhcmFtcxgGIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXMSHAoPc2NvcmVfdGhyZXNob2xkGAcgASgCSACIAQESGAoLdmVjdG9yX25hbWUYCCABKAlIAYgBARI2Cgx3aXRoX3ZlY3RvcnMYCSABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgCiAEBEhAKCGdyb3VwX2J5GAogASgJEhIKCmdyb3VwX3NpemUYCyABKA0SNgoQcmVhZF9jb25zaXN0ZW5jeRgMIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIA4gBARIsCgt3aXRoX2xvb2t1cBgNIAEoCzISLnFkcmFudC5XaXRoTG9va3VwSASIAQESFAoHdGltZW91dBgOIAEoBEgFiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgPIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAaIAQESMgoOc3BhcnNlX2luZGljZXMYECABKAsyFS5xZHJhbnQuU3BhcnNlSW5kaWNlc0gHiAEBQhIKEF9zY29yZV90aHJlc2hvbGRCDgoMX3ZlY3Rvcl9uYW1lQg8KDV93aXRoX3ZlY3RvcnNCEwoRX3JlYWRfY29uc2lzdGVuY3lCDgoMX3dpdGhfbG9va3VwQgoKCF90aW1lb3V0QhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCEQoPX3NwYXJzZV9pbmRpY2VzIn0KCVN0YXJ0RnJvbRIPCgVmbG9hdBgBIAEoAUgAEhEKB2ludGVnZXIYAiABKANIABIvCgl0aW1lc3RhbXAYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAASEgoIZGF0ZXRpbWUYBCABKAlIAEIHCgV2YWx1ZSKKAQoHT3JkZXJCeRILCgNrZXkYASABKAkSKQoJZGlyZWN0aW9uGAIgASgOMhEucWRyYW50LkRpcmVjdGlvbkgAiAEBEioKCnN0YXJ0X2Zyb20YAyABKAsyES5xZHJhbnQuU3RhcnRGcm9tSAGIAQFCDAoKX2RpcmVjdGlvbkINCgtfc3RhcnRfZnJvbSKOBAoMU2Nyb2xsUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIeCgZmaWx0ZXIYAiABKAsyDi5xZHJhbnQuRmlsdGVyEiQKBm9mZnNldBgDIAEoCzIPLnFkcmFudC5Qb2ludElkSACIAQESEgoFbGltaXQYBCABKA1IAYgBARIxCgx3aXRoX3BheWxvYWQYBiABKAsyGy5xZHJhbnQuV2l0aFBheWxvYWRTZWxlY3RvchI2Cgx3aXRoX3ZlY3RvcnMYByABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgCiAEBEjYKEHJlYWRfY29uc2lzdGVuY3kYCCABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SAOIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAkgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIBIgBARImCghvcmRlcl9ieRgKIAEoCzIPLnFkcmFudC5PcmRlckJ5SAWIAQESFAoHdGltZW91dBgLIAEoBEgGiAEBQgkKB19vZmZzZXRCCAoGX2xpbWl0Qg8KDV93aXRoX3ZlY3RvcnNCEwoRX3JlYWRfY29uc2lzdGVuY3lCFQoTX3NoYXJkX2tleV9zZWxlY3RvckILCglfb3JkZXJfYnlCCgoIX3RpbWVvdXRKBAgFEAYipQEKDkxvb2t1cExvY2F0aW9uEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIYCgt2ZWN0b3JfbmFtZRgCIAEoCUgAiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgDIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAGIAQFCDgoMX3ZlY3Rvcl9uYW1lQhUKE19zaGFyZF9rZXlfc2VsZWN0b3IizQYKD1JlY29tbWVuZFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSIQoIcG9zaXRpdmUYAiADKAsyDy5xZHJhbnQuUG9pbnRJZBIhCghuZWdhdGl2ZRgDIAMoCzIPLnFkcmFudC5Qb2ludElkEh4KBmZpbHRlchgEIAEoCzIOLnFkcmFudC5GaWx0ZXISDQoFbGltaXQYBSABKAQSMQoMd2l0aF9wYXlsb2FkGAcgASgLMhsucWRyYW50LldpdGhQYXlsb2FkU2VsZWN0b3ISJAoGcGFyYW1zGAggASgLMhQucWRyYW50LlNlYXJjaFBhcmFtcxIcCg9zY29yZV90aHJlc2hvbGQYCSABKAJIAIgBARITCgZvZmZzZXQYCiABKARIAYgBARISCgV1c2luZxgLIAEoCUgCiAEBEjYKDHdpdGhfdmVjdG9ycxgMIAEoCzIbLnFkcmFudC5XaXRoVmVjdG9yc1NlbGVjdG9ySAOIAQESMAoLbG9va3VwX2Zyb20YDSABKAsyFi5xZHJhbnQuTG9va3VwTG9jYXRpb25IBIgBARI2ChByZWFkX2NvbnNpc3RlbmN5GA4gASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgFiAEBEjAKCHN0cmF0ZWd5GBAgASgOMhkucWRyYW50LlJlY29tbWVuZFN0cmF0ZWd5SAaIAQESKAoQcG9zaXRpdmVfdmVjdG9ycxgRIAMoCzIOLnFkcmFudC5WZWN0b3ISKAoQbmVnYXRpdmVfdmVjdG9ycxgSIAMoCzIOLnFkcmFudC5WZWN0b3ISFAoHdGltZW91dBgTIAEoBEgHiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgUIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAiIAQFCEgoQX3Njb3JlX3RocmVzaG9sZEIJCgdfb2Zmc2V0QggKBl91c2luZ0IPCg1fd2l0aF92ZWN0b3JzQg4KDF9sb29rdXBfZnJvbUITChFfcmVhZF9jb25zaXN0ZW5jeUILCglfc3RyYXRlZ3lCCgoIX3RpbWVvdXRCFQoTX3NoYXJkX2tleV9zZWxlY3RvckoECAYQByLRAQoUUmVjb21tZW5kQmF0Y2hQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEjEKEHJlY29tbWVuZF9wb2ludHMYAiADKAsyFy5xZHJhbnQuUmVjb21tZW5kUG9pbnRzEjYKEHJlYWRfY29uc2lzdGVuY3kYAyABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SACIAQESFAoHdGltZW91dBgEIAEoBEgBiAEBQhMKEV9yZWFkX2NvbnNpc3RlbmN5QgoKCF90aW1lb3V0IpAHChRSZWNvbW1lbmRQb2ludEdyb3VwcxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSIQoIcG9zaXRpdmUYAiADKAsyDy5xZHJhbnQuUG9pbnRJZBIhCghuZWdhdGl2ZRgDIAMoCzIPLnFkcmFudC5Qb2ludElkEh4KBmZpbHRlchgEIAEoCzIOLnFkcmFudC5GaWx0ZXISDQoFbGltaXQYBSABKA0SMQoMd2l0aF9wYXlsb2FkGAYgASgLMhsucWRyYW50LldpdGhQYXlsb2FkU2VsZWN0b3ISJAoGcGFyYW1zGAcgASgLMhQucWRyYW50LlNlYXJjaFBhcmFtcxIcCg9zY29yZV90aHJlc2hvbGQYCCABKAJIAIgBARISCgV1c2luZxgJIAEoCUgBiAEBEjYKDHdpdGhfdmVjdG9ycxgKIAEoCzIbLnFkcmFudC5XaXRoVmVjdG9yc1NlbGVjdG9ySAKIAQESMAoLbG9va3VwX2Zyb20YCyABKAsyFi5xZHJhbnQuTG9va3VwTG9jYXRpb25IA4gBARIQCghncm91cF9ieRgMIAEoCRISCgpncm91cF9zaXplGA0gASgNEjYKEHJlYWRfY29uc2lzdGVuY3kYDiABKAsyFy5xZHJhbnQuUmVhZENvbnNpc3RlbmN5SASIAQESLAoLd2l0aF9sb29rdXAYDyABKAsyEi5xZHJhbnQuV2l0aExvb2t1cEgFiAEBEjAKCHN0cmF0ZWd5GBEgASgOMhkucWRyYW50LlJlY29tbWVuZFN0cmF0ZWd5SAaIAQESKAoQcG9zaXRpdmVfdmVjdG9ycxgSIAMoCzIOLnFkcmFudC5WZWN0b3ISKAoQbmVnYXRpdmVfdmVjdG9ycxgTIAMoCzIOLnFkcmFudC5WZWN0b3ISFAoHdGltZW91dBgUIAEoBEgHiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgVIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAiIAQFCEgoQX3Njb3JlX3RocmVzaG9sZEIICgZfdXNpbmdCDwoNX3dpdGhfdmVjdG9yc0IOCgxfbG9va3VwX2Zyb21CEwoRX3JlYWRfY29uc2lzdGVuY3lCDgoMX3dpdGhfbG9va3VwQgsKCV9zdHJhdGVneUIKCghfdGltZW91dEIVChNfc2hhcmRfa2V5X3NlbGVjdG9yIkEKDFRhcmdldFZlY3RvchInCgZzaW5nbGUYASABKAsyFS5xZHJhbnQuVmVjdG9yRXhhbXBsZUgAQggKBnRhcmdldCJbCg1WZWN0b3JFeGFtcGxlEh0KAmlkGAEgASgLMg8ucWRyYW50LlBvaW50SWRIABIgCgZ2ZWN0b3IYAiABKAsyDi5xZHJhbnQuVmVjdG9ySABCCQoHZXhhbXBsZSJmChJDb250ZXh0RXhhbXBsZVBhaXISJwoIcG9zaXRpdmUYASABKAsyFS5xZHJhbnQuVmVjdG9yRXhhbXBsZRInCghuZWdhdGl2ZRgCIAEoCzIVLnFkcmFudC5WZWN0b3JFeGFtcGxlIo4FCg5EaXNjb3ZlclBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSJAoGdGFyZ2V0GAIgASgLMhQucWRyYW50LlRhcmdldFZlY3RvchIrCgdjb250ZXh0GAMgAygLMhoucWRyYW50LkNvbnRleHRFeGFtcGxlUGFpchIeCgZmaWx0ZXIYBCABKAsyDi5xZHJhbnQuRmlsdGVyEg0KBWxpbWl0GAUgASgEEjEKDHdpdGhfcGF5bG9hZBgGIAEoCzIbLnFkcmFudC5XaXRoUGF5bG9hZFNlbGVjdG9yEiQKBnBhcmFtcxgHIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXMSEwoGb2Zmc2V0GAggASgESACIAQESEgoFdXNpbmcYCSABKAlIAYgBARI2Cgx3aXRoX3ZlY3RvcnMYCiABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgCiAEBEjAKC2xvb2t1cF9mcm9tGAsgASgLMhYucWRyYW50Lkxvb2t1cExvY2F0aW9uSAOIAQESNgoQcmVhZF9jb25zaXN0ZW5jeRgMIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIBIgBARIUCgd0aW1lb3V0GA0gASgESAWIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGA4gASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIBogBAUIJCgdfb2Zmc2V0QggKBl91c2luZ0IPCg1fd2l0aF92ZWN0b3JzQg4KDF9sb29rdXBfZnJvbUITChFfcmVhZF9jb25zaXN0ZW5jeUIKCghfdGltZW91dEIVChNfc2hhcmRfa2V5X3NlbGVjdG9yIs4BChNEaXNjb3ZlckJhdGNoUG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIvCg9kaXNjb3Zlcl9wb2ludHMYAiADKAsyFi5xZHJhbnQuRGlzY292ZXJQb2ludHMSNgoQcmVhZF9jb25zaXN0ZW5jeRgDIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIAIgBARIUCgd0aW1lb3V0GAQgASgESAGIAQFCEwoRX3JlYWRfY29uc2lzdGVuY3lCCgoIX3RpbWVvdXQipQIKC0NvdW50UG9pbnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRIeCgZmaWx0ZXIYAiABKAsyDi5xZHJhbnQuRmlsdGVyEhIKBWV4YWN0GAMgASgISACIAQESNgoQcmVhZF9jb25zaXN0ZW5jeRgEIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIAYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYBSABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgCiAEBEhQKB3RpbWVvdXQYBiABKARIA4gBAUIICgZfZXhhY3RCEwoRX3JlYWRfY29uc2lzdGVuY3lCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIKCghfdGltZW91dCKdAQoOUmVjb21tZW5kSW5wdXQSJQoIcG9zaXRpdmUYASADKAsyEy5xZHJhbnQuVmVjdG9ySW5wdXQSJQoIbmVnYXRpdmUYAiADKAsyEy5xZHJhbnQuVmVjdG9ySW5wdXQSMAoIc3RyYXRlZ3kYAyABKA4yGS5xZHJhbnQuUmVjb21tZW5kU3RyYXRlZ3lIAIgBAUILCglfc3RyYXRlZ3kiYAoQQ29udGV4dElucHV0UGFpchIlCghwb3NpdGl2ZRgBIAEoCzITLnFkcmFudC5WZWN0b3JJbnB1dBIlCghuZWdhdGl2ZRgCIAEoCzITLnFkcmFudC5WZWN0b3JJbnB1dCJbCg1EaXNjb3ZlcklucHV0EiMKBnRhcmdldBgBIAEoCzITLnFkcmFudC5WZWN0b3JJbnB1dBIlCgdjb250ZXh0GAIgASgLMhQucWRyYW50LkNvbnRleHRJbnB1dCI3CgxDb250ZXh0SW5wdXQSJwoFcGFpcnMYASADKAsyGC5xZHJhbnQuQ29udGV4dElucHV0UGFpciKiAQoHRm9ybXVsYRImCgpleHByZXNzaW9uGAEgASgLMhIucWRyYW50LkV4cHJlc3Npb24SLwoIZGVmYXVsdHMYAiADKAsyHS5xZHJhbnQuRm9ybXVsYS5EZWZhdWx0c0VudHJ5Gj4KDURlZmF1bHRzRW50cnkSCwoDa2V5GAEgASgJEhwKBXZhbHVlGAIgASgLMg0ucWRyYW50LlZhbHVlOgI4ASLMBQoKRXhwcmVzc2lvbhISCghjb25zdGFudBgBIAEoAkgAEhIKCHZhcmlhYmxlGAIgASgJSAASJgoJY29uZGl0aW9uGAMgASgLMhEucWRyYW50LkNvbmRpdGlvbkgAEisKDGdlb19kaXN0YW5jZRgEIAEoCzITLnFkcmFudC5HZW9EaXN0YW5jZUgAEhIKCGRhdGV0aW1lGAUgASgJSAASFgoMZGF0ZXRpbWVfa2V5GAYgASgJSAASJgoEbXVsdBgHIAEoCzIWLnFkcmFudC5NdWx0RXhwcmVzc2lvbkgAEiQKA3N1bRgIIAEoCzIVLnFkcmFudC5TdW1FeHByZXNzaW9uSAASJAoDZGl2GAkgASgLMhUucWRyYW50LkRpdkV4cHJlc3Npb25IABIhCgNuZWcYCiABKAsyEi5xZHJhbnQuRXhwcmVzc2lvbkgAEiEKA2FicxgLIAEoCzISLnFkcmFudC5FeHByZXNzaW9uSAASIgoEc3FydBgMIAEoCzISLnFkcmFudC5FeHByZXNzaW9uSAASJAoDcG93GA0gASgLMhUucWRyYW50LlBvd0V4cHJlc3Npb25IABIhCgNleHAYDiABKAsyEi5xZHJhbnQuRXhwcmVzc2lvbkgAEiMKBWxvZzEwGA8gASgLMhIucWRyYW50LkV4cHJlc3Npb25IABIgCgJsbhgQIAEoCzISLnFkcmFudC5FeHByZXNzaW9uSAASMgoJZXhwX2RlY2F5GBEgASgLMh0ucWRyYW50LkRlY2F5UGFyYW1zRXhwcmVzc2lvbkgAEjQKC2dhdXNzX2RlY2F5GBIgASgLMh0ucWRyYW50LkRlY2F5UGFyYW1zRXhwcmVzc2lvbkgAEjIKCWxpbl9kZWNheRgTIAEoCzIdLnFkcmFudC5EZWNheVBhcmFtc0V4cHJlc3Npb25IAEIJCgd2YXJpYW50IjsKC0dlb0Rpc3RhbmNlEiAKBm9yaWdpbhgBIAEoCzIQLnFkcmFudC5HZW9Qb2ludBIKCgJ0bxgCIAEoCSIyCg5NdWx0RXhwcmVzc2lvbhIgCgRtdWx0GAEgAygLMhIucWRyYW50LkV4cHJlc3Npb24iMAoNU3VtRXhwcmVzc2lvbhIfCgNzdW0YASADKAsyEi5xZHJhbnQuRXhwcmVzc2lvbiKGAQoNRGl2RXhwcmVzc2lvbhIgCgRsZWZ0GAEgASgLMhIucWRyYW50LkV4cHJlc3Npb24SIQoFcmlnaHQYAiABKAsyEi5xZHJhbnQuRXhwcmVzc2lvbhIcCg9ieV96ZXJvX2RlZmF1bHQYAyABKAJIAIgBAUISChBfYnlfemVyb19kZWZhdWx0IlcKDVBvd0V4cHJlc3Npb24SIAoEYmFzZRgBIAEoCzISLnFkcmFudC5FeHByZXNzaW9uEiQKCGV4cG9uZW50GAIgASgLMhIucWRyYW50LkV4cHJlc3Npb24irAEKFURlY2F5UGFyYW1zRXhwcmVzc2lvbhIdCgF4GAEgASgLMhIucWRyYW50LkV4cHJlc3Npb24SJwoGdGFyZ2V0GAIgASgLMhIucWRyYW50LkV4cHJlc3Npb25IAIgBARISCgVzY2FsZRgDIAEoAkgBiAEBEhUKCG1pZHBvaW50GAQgASgCSAKIAQFCCQoHX3RhcmdldEIICgZfc2NhbGVCCwoJX21pZHBvaW50IlUKE05lYXJlc3RJbnB1dFdpdGhNbXISJAoHbmVhcmVzdBgBIAEoCzITLnFkcmFudC5WZWN0b3JJbnB1dBIYCgNtbXIYAiABKAsyCy5xZHJhbnQuTW1yIl8KA01tchIWCglkaXZlcnNpdHkYAiABKAJIAIgBARIdChBjYW5kaWRhdGVzX2xpbWl0GAMgASgNSAGIAQFCDAoKX2RpdmVyc2l0eUITChFfY2FuZGlkYXRlc19saW1pdCIbCgNScmYSDgoBaxgBIAEoDUgAiAEBQgQKAl9rIp0DCgVRdWVyeRImCgduZWFyZXN0GAEgASgLMhMucWRyYW50LlZlY3RvcklucHV0SAASKwoJcmVjb21tZW5kGAIgASgLMhYucWRyYW50LlJlY29tbWVuZElucHV0SAASKQoIZGlzY292ZXIYAyABKAsyFS5xZHJhbnQuRGlzY292ZXJJbnB1dEgAEicKB2NvbnRleHQYBCABKAsyFC5xZHJhbnQuQ29udGV4dElucHV0SAASIwoIb3JkZXJfYnkYBSABKAsyDy5xZHJhbnQuT3JkZXJCeUgAEiAKBmZ1c2lvbhgGIAEoDjIOLnFkcmFudC5GdXNpb25IABIgCgZzYW1wbGUYByABKA4yDi5xZHJhbnQuU2FtcGxlSAASIgoHZm9ybXVsYRgIIAEoCzIPLnFkcmFudC5Gb3JtdWxhSAASNwoQbmVhcmVzdF93aXRoX21tchgJIAEoCzIbLnFkcmFudC5OZWFyZXN0SW5wdXRXaXRoTW1ySAASGgoDcnJmGAogASgLMgsucWRyYW50LlJyZkgAQgkKB3ZhcmlhbnQi+wIKDVByZWZldGNoUXVlcnkSJwoIcHJlZmV0Y2gYASADKAsyFS5xZHJhbnQuUHJlZmV0Y2hRdWVyeRIhCgVxdWVyeRgCIAEoCzINLnFkcmFudC5RdWVyeUgAiAEBEhIKBXVzaW5nGAMgASgJSAGIAQESIwoGZmlsdGVyGAQgASgLMg4ucWRyYW50LkZpbHRlckgCiAEBEikKBnBhcmFtcxgFIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXNIA4gBARIcCg9zY29yZV90aHJlc2hvbGQYBiABKAJIBIgBARISCgVsaW1pdBgHIAEoBEgFiAEBEjAKC2xvb2t1cF9mcm9tGAggASgLMhYucWRyYW50Lkxvb2t1cExvY2F0aW9uSAaIAQFCCAoGX3F1ZXJ5QggKBl91c2luZ0IJCgdfZmlsdGVyQgkKB19wYXJhbXNCEgoQX3Njb3JlX3RocmVzaG9sZEIICgZfbGltaXRCDgoMX2xvb2t1cF9mcm9tIoUGCgtRdWVyeVBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSJwoIcHJlZmV0Y2gYAiADKAsyFS5xZHJhbnQuUHJlZmV0Y2hRdWVyeRIhCgVxdWVyeRgDIAEoCzINLnFkcmFudC5RdWVyeUgAiAEBEhIKBXVzaW5nGAQgASgJSAGIAQESIwoGZmlsdGVyGAUgASgLMg4ucWRyYW50LkZpbHRlckgCiAEBEikKBnBhcmFtcxgGIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXNIA4gBARIcCg9zY29yZV90aHJlc2hvbGQYByABKAJIBIgBARISCgVsaW1pdBgIIAEoBEgFiAEBEhMKBm9mZnNldBgJIAEoBEgGiAEBEjYKDHdpdGhfdmVjdG9ycxgKIAEoCzIbLnFkcmFudC5XaXRoVmVjdG9yc1NlbGVjdG9ySAeIAQESNgoMd2l0aF9wYXlsb2FkGAsgASgLMhsucWRyYW50LldpdGhQYXlsb2FkU2VsZWN0b3JICIgBARI2ChByZWFkX2NvbnNpc3RlbmN5GAwgASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgJiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgNIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAqIAQESMAoLbG9va3VwX2Zyb20YDiABKAsyFi5xZHJhbnQuTG9va3VwTG9jYXRpb25IC4gBARIUCgd0aW1lb3V0GA8gASgESAyIAQFCCAoGX3F1ZXJ5QggKBl91c2luZ0IJCgdfZmlsdGVyQgkKB19wYXJhbXNCEgoQX3Njb3JlX3RocmVzaG9sZEIICgZfbGltaXRCCQoHX29mZnNldEIPCg1fd2l0aF92ZWN0b3JzQg8KDV93aXRoX3BheWxvYWRCEwoRX3JlYWRfY29uc2lzdGVuY3lCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIOCgxfbG9va3VwX2Zyb21CCgoIX3RpbWVvdXQixQEKEFF1ZXJ5QmF0Y2hQb2ludHMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEikKDHF1ZXJ5X3BvaW50cxgCIAMoCzITLnFkcmFudC5RdWVyeVBvaW50cxI2ChByZWFkX2NvbnNpc3RlbmN5GAMgASgLMhcucWRyYW50LlJlYWRDb25zaXN0ZW5jeUgAiAEBEhQKB3RpbWVvdXQYBCABKARIAYgBAUITChFfcmVhZF9jb25zaXN0ZW5jeUIKCghfdGltZW91dCLMBgoQUXVlcnlQb2ludEdyb3VwcxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSJwoIcHJlZmV0Y2gYAiADKAsyFS5xZHJhbnQuUHJlZmV0Y2hRdWVyeRIhCgVxdWVyeRgDIAEoCzINLnFkcmFudC5RdWVyeUgAiAEBEhIKBXVzaW5nGAQgASgJSAGIAQESIwoGZmlsdGVyGAUgASgLMg4ucWRyYW50LkZpbHRlckgCiAEBEikKBnBhcmFtcxgGIAEoCzIULnFkcmFudC5TZWFyY2hQYXJhbXNIA4gBARIcCg9zY29yZV90aHJlc2hvbGQYByABKAJIBIgBARIxCgx3aXRoX3BheWxvYWQYCCABKAsyGy5xZHJhbnQuV2l0aFBheWxvYWRTZWxlY3RvchI2Cgx3aXRoX3ZlY3RvcnMYCSABKAsyGy5xZHJhbnQuV2l0aFZlY3RvcnNTZWxlY3RvckgFiAEBEjAKC2xvb2t1cF9mcm9tGAogASgLMhYucWRyYW50Lkxvb2t1cExvY2F0aW9uSAaIAQESEgoFbGltaXQYCyABKARIB4gBARIXCgpncm91cF9zaXplGAwgASgESAiIAQESEAoIZ3JvdXBfYnkYDSABKAkSNgoQcmVhZF9jb25zaXN0ZW5jeRgOIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lICYgBARIsCgt3aXRoX2xvb2t1cBgPIAEoCzISLnFkcmFudC5XaXRoTG9va3VwSAqIAQESFAoHdGltZW91dBgQIAEoBEgLiAEBEjkKEnNoYXJkX2tleV9zZWxlY3RvchgRIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySAyIAQFCCAoGX3F1ZXJ5QggKBl91c2luZ0IJCgdfZmlsdGVyQgkKB19wYXJhbXNCEgoQX3Njb3JlX3RocmVzaG9sZEIPCg1fd2l0aF92ZWN0b3JzQg4KDF9sb29rdXBfZnJvbUIICgZfbGltaXRCDQoLX2dyb3VwX3NpemVCEwoRX3JlYWRfY29uc2lzdGVuY3lCDgoMX3dpdGhfbG9va3VwQgoKCF90aW1lb3V0QhUKE19zaGFyZF9rZXlfc2VsZWN0b3Ii4AIKC0ZhY2V0Q291bnRzEhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRILCgNrZXkYAiABKAkSIwoGZmlsdGVyGAMgASgLMg4ucWRyYW50LkZpbHRlckgAiAEBEhIKBWxpbWl0GAQgASgESAGIAQESEgoFZXhhY3QYBSABKAhIAogBARIUCgd0aW1lb3V0GAYgASgESAOIAQESNgoQcmVhZF9jb25zaXN0ZW5jeRgHIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIBIgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYCCABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgFiAEBQgkKB19maWx0ZXJCCAoGX2xpbWl0QggKBl9leGFjdEIKCghfdGltZW91dEITChFfcmVhZF9jb25zaXN0ZW5jeUIVChNfc2hhcmRfa2V5X3NlbGVjdG9yIl4KCkZhY2V0VmFsdWUSFgoMc3RyaW5nX3ZhbHVlGAEgASgJSAASFwoNaW50ZWdlcl92YWx1ZRgCIAEoA0gAEhQKCmJvb2xfdmFsdWUYAyABKAhIAEIJCgd2YXJpYW50IjwKCEZhY2V0SGl0EiEKBXZhbHVlGAEgASgLMhIucWRyYW50LkZhY2V0VmFsdWUSDQoFY291bnQYAiABKAQi+gIKElNlYXJjaE1hdHJpeFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSIwoGZmlsdGVyGAIgASgLMg4ucWRyYW50LkZpbHRlckgAiAEBEhMKBnNhbXBsZRgDIAEoBEgBiAEBEhIKBWxpbWl0GAQgASgESAKIAQESEgoFdXNpbmcYBSABKAlIA4gBARIUCgd0aW1lb3V0GAYgASgESASIAQESNgoQcmVhZF9jb25zaXN0ZW5jeRgHIAEoCzIXLnFkcmFudC5SZWFkQ29uc2lzdGVuY3lIBYgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYCCABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgGiAEBQgkKB19maWx0ZXJCCQoHX3NhbXBsZUIICgZfbGltaXRCCAoGX3VzaW5nQgoKCF90aW1lb3V0QhMKEV9yZWFkX2NvbnNpc3RlbmN5QhUKE19zaGFyZF9rZXlfc2VsZWN0b3IiPAoRU2VhcmNoTWF0cml4UGFpcnMSJwoFcGFpcnMYASADKAsyGC5xZHJhbnQuU2VhcmNoTWF0cml4UGFpciJZChBTZWFyY2hNYXRyaXhQYWlyEhoKAWEYASABKAsyDy5xZHJhbnQuUG9pbnRJZBIaCgFiGAIgASgLMg8ucWRyYW50LlBvaW50SWQSDQoFc2NvcmUYAyABKAIibQoTU2VhcmNoTWF0cml4T2Zmc2V0cxITCgtvZmZzZXRzX3JvdxgBIAMoBBITCgtvZmZzZXRzX2NvbBgCIAMoBBIOCgZzY29yZXMYAyADKAISHAoDaWRzGAQgAygLMg8ucWRyYW50LlBvaW50SWQikRMKFVBvaW50c1VwZGF0ZU9wZXJhdGlvbhI/CgZ1cHNlcnQYASABKAsyLS5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uLlBvaW50U3RydWN0TGlzdEgAEjcKEWRlbGV0ZV9kZXByZWNhdGVkGAIgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9yQgIYAUgAEj8KC3NldF9wYXlsb2FkGAMgASgLMigucWRyYW50LlBvaW50c1VwZGF0ZU9wZXJhdGlvbi5TZXRQYXlsb2FkSAASSwoRb3ZlcndyaXRlX3BheWxvYWQYBCABKAsyLi5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uLk92ZXJ3cml0ZVBheWxvYWRIABJFCg5kZWxldGVfcGF5bG9hZBgFIAEoCzIrLnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uRGVsZXRlUGF5bG9hZEgAEj4KGGNsZWFyX3BheWxvYWRfZGVwcmVjYXRlZBgGIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvckICGAFIABJFCg51cGRhdGVfdmVjdG9ycxgHIAEoCzIrLnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uVXBkYXRlVmVjdG9yc0gAEkUKDmRlbGV0ZV92ZWN0b3JzGAggASgLMisucWRyYW50LlBvaW50c1VwZGF0ZU9wZXJhdGlvbi5EZWxldGVWZWN0b3JzSAASQwoNZGVsZXRlX3BvaW50cxgJIAEoCzIqLnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uRGVsZXRlUG9pbnRzSAASQwoNY2xlYXJfcGF5bG9hZBgKIAEoCzIqLnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uQ2xlYXJQYXlsb2FkSAAaxgEKD1BvaW50U3RydWN0TGlzdBIjCgZwb2ludHMYASADKAsyEy5xZHJhbnQuUG9pbnRTdHJ1Y3QSOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAIgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAIgBARIqCg11cGRhdGVfZmlsdGVyGAMgASgLMg4ucWRyYW50LkZpbHRlckgBiAEBQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCEAoOX3VwZGF0ZV9maWx0ZXIayQIKClNldFBheWxvYWQSRgoHcGF5bG9hZBgBIAMoCzI1LnFkcmFudC5Qb2ludHNVcGRhdGVPcGVyYXRpb24uU2V0UGF5bG9hZC5QYXlsb2FkRW50cnkSNAoPcG9pbnRzX3NlbGVjdG9yGAIgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9ySACIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAMgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAYgBARIQCgNrZXkYBCABKAlIAogBARo9CgxQYXlsb2FkRW50cnkSCwoDa2V5GAEgASgJEhwKBXZhbHVlGAIgASgLMg0ucWRyYW50LlZhbHVlOgI4AUISChBfcG9pbnRzX3NlbGVjdG9yQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCBgoEX2tleRrVAgoQT3ZlcndyaXRlUGF5bG9hZBJMCgdwYXlsb2FkGAEgAygLMjsucWRyYW50LlBvaW50c1VwZGF0ZU9wZXJhdGlvbi5PdmVyd3JpdGVQYXlsb2FkLlBheWxvYWRFbnRyeRI0Cg9wb2ludHNfc2VsZWN0b3IYAiABKAsyFi5xZHJhbnQuUG9pbnRzU2VsZWN0b3JIAIgBARI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYAyABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgBiAEBEhAKA2tleRgEIAEoCUgCiAEBGj0KDFBheWxvYWRFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBQhIKEF9wb2ludHNfc2VsZWN0b3JCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIGCgRfa2V5GrkBCg1EZWxldGVQYXlsb2FkEgwKBGtleXMYASADKAkSNAoPcG9pbnRzX3NlbGVjdG9yGAIgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9ySACIAQESOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAMgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAYgBAUISChBfcG9pbnRzX3NlbGVjdG9yQhUKE19zaGFyZF9rZXlfc2VsZWN0b3IaxQEKDVVwZGF0ZVZlY3RvcnMSJAoGcG9pbnRzGAEgAygLMhQucWRyYW50LlBvaW50VmVjdG9ycxI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYAiABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgAiAEBEioKDXVwZGF0ZV9maWx0ZXIYAyABKAsyDi5xZHJhbnQuRmlsdGVySAGIAQFCFQoTX3NoYXJkX2tleV9zZWxlY3RvckIQCg5fdXBkYXRlX2ZpbHRlchq8AQoNRGVsZXRlVmVjdG9ycxIvCg9wb2ludHNfc2VsZWN0b3IYASABKAsyFi5xZHJhbnQuUG9pbnRzU2VsZWN0b3ISKAoHdmVjdG9ycxgCIAEoCzIXLnFkcmFudC5WZWN0b3JzU2VsZWN0b3ISOQoSc2hhcmRfa2V5X3NlbGVjdG9yGAMgASgLMhgucWRyYW50LlNoYXJkS2V5U2VsZWN0b3JIAIgBAUIVChNfc2hhcmRfa2V5X3NlbGVjdG9yGogBCgxEZWxldGVQb2ludHMSJgoGcG9pbnRzGAEgASgLMhYucWRyYW50LlBvaW50c1NlbGVjdG9yEjkKEnNoYXJkX2tleV9zZWxlY3RvchgCIAEoCzIYLnFkcmFudC5TaGFyZEtleVNlbGVjdG9ySACIAQFCFQoTX3NoYXJkX2tleV9zZWxlY3RvchqIAQoMQ2xlYXJQYXlsb2FkEiYKBnBvaW50cxgBIAEoCzIWLnFkcmFudC5Qb2ludHNTZWxlY3RvchI5ChJzaGFyZF9rZXlfc2VsZWN0b3IYAiABKAsyGC5xZHJhbnQuU2hhcmRLZXlTZWxlY3RvckgAiAEBQhUKE19zaGFyZF9rZXlfc2VsZWN0b3JCCwoJb3BlcmF0aW9uIrYBChFVcGRhdGVCYXRjaFBvaW50cxIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSEQoEd2FpdBgCIAEoCEgAiAEBEjEKCm9wZXJhdGlvbnMYAyADKAsyHS5xZHJhbnQuUG9pbnRzVXBkYXRlT3BlcmF0aW9uEiwKCG9yZGVyaW5nGAQgASgLMhUucWRyYW50LldyaXRlT3JkZXJpbmdIAYgBAUIHCgVfd2FpdEILCglfb3JkZXJpbmciegoXUG9pbnRzT3BlcmF0aW9uUmVzcG9uc2USJAoGcmVzdWx0GAEgASgLMhQucWRyYW50LlVwZGF0ZVJlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlImAKDFVwZGF0ZVJlc3VsdBIZCgxvcGVyYXRpb25faWQYASABKARIAIgBARIkCgZzdGF0dXMYAiABKA4yFC5xZHJhbnQuVXBkYXRlU3RhdHVzQg8KDV9vcGVyYXRpb25faWQiNwoKT3JkZXJWYWx1ZRINCgNpbnQYASABKANIABIPCgVmbG9hdBgCIAEoAUgAQgkKB3ZhcmlhbnQi8QIKC1Njb3JlZFBvaW50EhsKAmlkGAEgASgLMg8ucWRyYW50LlBvaW50SWQSMQoHcGF5bG9hZBgCIAMoCzIgLnFkcmFudC5TY29yZWRQb2ludC5QYXlsb2FkRW50cnkSDQoFc2NvcmUYAyABKAISDwoHdmVyc2lvbhgFIAEoBBIrCgd2ZWN0b3JzGAYgASgLMhUucWRyYW50LlZlY3RvcnNPdXRwdXRIAIgBARIoCglzaGFyZF9rZXkYByABKAsyEC5xZHJhbnQuU2hhcmRLZXlIAYgBARIsCgtvcmRlcl92YWx1ZRgIIAEoCzISLnFkcmFudC5PcmRlclZhbHVlSAKIAQEaPQoMUGF5bG9hZEVudHJ5EgsKA2tleRgBIAEoCRIcCgV2YWx1ZRgCIAEoCzINLnFkcmFudC5WYWx1ZToCOAFCCgoIX3ZlY3RvcnNCDAoKX3NoYXJkX2tleUIOCgxfb3JkZXJfdmFsdWVKBAgEEAUiXAoHR3JvdXBJZBIYCg51bnNpZ25lZF92YWx1ZRgBIAEoBEgAEhcKDWludGVnZXJfdmFsdWUYAiABKANIABIWCgxzdHJpbmdfdmFsdWUYAyABKAlIAEIGCgRraW5kInQKClBvaW50R3JvdXASGwoCaWQYASABKAsyDy5xZHJhbnQuR3JvdXBJZBIhCgRoaXRzGAIgAygLMhMucWRyYW50LlNjb3JlZFBvaW50EiYKBmxvb2t1cBgDIAEoCzIWLnFkcmFudC5SZXRyaWV2ZWRQb2ludCIyCgxHcm91cHNSZXN1bHQSIgoGZ3JvdXBzGAEgAygLMhIucWRyYW50LlBvaW50R3JvdXAicAoOU2VhcmNoUmVzcG9uc2USIwoGcmVzdWx0GAEgAygLMhMucWRyYW50LlNjb3JlZFBvaW50EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UibwoNUXVlcnlSZXNwb25zZRIjCgZyZXN1bHQYASADKAsyEy5xZHJhbnQuU2NvcmVkUG9pbnQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJ0ChJRdWVyeUJhdGNoUmVzcG9uc2USIwoGcmVzdWx0GAEgAygLMhMucWRyYW50LkJhdGNoUmVzdWx0EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UidgoTUXVlcnlHcm91cHNSZXNwb25zZRIkCgZyZXN1bHQYASABKAsyFC5xZHJhbnQuR3JvdXBzUmVzdWx0EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UiMgoLQmF0Y2hSZXN1bHQSIwoGcmVzdWx0GAEgAygLMhMucWRyYW50LlNjb3JlZFBvaW50InUKE1NlYXJjaEJhdGNoUmVzcG9uc2USIwoGcmVzdWx0GAEgAygLMhMucWRyYW50LkJhdGNoUmVzdWx0EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UidwoUU2VhcmNoR3JvdXBzUmVzcG9uc2USJAoGcmVzdWx0GAEgASgLMhQucWRyYW50Lkdyb3Vwc1Jlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlIm8KDUNvdW50UmVzcG9uc2USIwoGcmVzdWx0GAEgASgLMhMucWRyYW50LkNvdW50UmVzdWx0EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UiuAEKDlNjcm9sbFJlc3BvbnNlEi4KEG5leHRfcGFnZV9vZmZzZXQYASABKAsyDy5xZHJhbnQuUG9pbnRJZEgAiAEBEiYKBnJlc3VsdBgCIAMoCzIWLnFkcmFudC5SZXRyaWV2ZWRQb2ludBIMCgR0aW1lGAMgASgBEiEKBXVzYWdlGAQgASgLMg0ucWRyYW50LlVzYWdlSAGIAQFCEwoRX25leHRfcGFnZV9vZmZzZXRCCAoGX3VzYWdlIhwKC0NvdW50UmVzdWx0Eg0KBWNvdW50GAEgASgEItcCCg5SZXRyaWV2ZWRQb2ludBIbCgJpZBgBIAEoCzIPLnFkcmFudC5Qb2ludElkEjQKB3BheWxvYWQYAiADKAsyIy5xZHJhbnQuUmV0cmlldmVkUG9pbnQuUGF5bG9hZEVudHJ5EisKB3ZlY3RvcnMYBCABKAsyFS5xZHJhbnQuVmVjdG9yc091dHB1dEgAiAEBEigKCXNoYXJkX2tleRgFIAEoCzIQLnFkcmFudC5TaGFyZEtleUgBiAEBEiwKC29yZGVyX3ZhbHVlGAYgASgLMhIucWRyYW50Lk9yZGVyVmFsdWVIAogBARo9CgxQYXlsb2FkRW50cnkSCwoDa2V5GAEgASgJEhwKBXZhbHVlGAIgASgLMg0ucWRyYW50LlZhbHVlOgI4AUIKCghfdmVjdG9yc0IMCgpfc2hhcmRfa2V5Qg4KDF9vcmRlcl92YWx1ZUoECAMQBCJwCgtHZXRSZXNwb25zZRImCgZyZXN1bHQYASADKAsyFi5xZHJhbnQuUmV0cmlldmVkUG9pbnQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJzChFSZWNvbW1lbmRSZXNwb25zZRIjCgZyZXN1bHQYASADKAsyEy5xZHJhbnQuU2NvcmVkUG9pbnQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJ4ChZSZWNvbW1lbmRCYXRjaFJlc3BvbnNlEiMKBnJlc3VsdBgBIAMoCzITLnFkcmFudC5CYXRjaFJlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlInIKEERpc2NvdmVyUmVzcG9uc2USIwoGcmVzdWx0GAEgAygLMhMucWRyYW50LlNjb3JlZFBvaW50EgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UidwoVRGlzY292ZXJCYXRjaFJlc3BvbnNlEiMKBnJlc3VsdBgBIAMoCzITLnFkcmFudC5CYXRjaFJlc3VsdBIMCgR0aW1lGAIgASgBEiEKBXVzYWdlGAMgASgLMg0ucWRyYW50LlVzYWdlSACIAQFCCAoGX3VzYWdlInoKF1JlY29tbWVuZEdyb3Vwc1Jlc3BvbnNlEiQKBnJlc3VsdBgBIAEoCzIULnFkcmFudC5Hcm91cHNSZXN1bHQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJ2ChNVcGRhdGVCYXRjaFJlc3BvbnNlEiQKBnJlc3VsdBgBIAMoCzIULnFkcmFudC5VcGRhdGVSZXN1bHQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSJqCg1GYWNldFJlc3BvbnNlEh4KBGhpdHMYASADKAsyEC5xZHJhbnQuRmFjZXRIaXQSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSKBAQoZU2VhcmNoTWF0cml4UGFpcnNSZXNwb25zZRIpCgZyZXN1bHQYASABKAsyGS5xZHJhbnQuU2VhcmNoTWF0cml4UGFpcnMSDAoEdGltZRgCIAEoARIhCgV1c2FnZRgDIAEoCzINLnFkcmFudC5Vc2FnZUgAiAEBQggKBl91c2FnZSKFAQobU2VhcmNoTWF0cml4T2Zmc2V0c1Jlc3BvbnNlEisKBnJlc3VsdBgBIAEoCzIbLnFkcmFudC5TZWFyY2hNYXRyaXhPZmZzZXRzEgwKBHRpbWUYAiABKAESIQoFdXNhZ2UYAyABKAsyDS5xZHJhbnQuVXNhZ2VIAIgBAUIICgZfdXNhZ2UirAEKBkZpbHRlchIhCgZzaG91bGQYASADKAsyES5xZHJhbnQuQ29uZGl0aW9uEh8KBG11c3QYAiADKAsyES5xZHJhbnQuQ29uZGl0aW9uEiMKCG11c3Rfbm90GAMgAygLMhEucWRyYW50LkNvbmRpdGlvbhIqCgptaW5fc2hvdWxkGAQgASgLMhEucWRyYW50Lk1pblNob3VsZEgAiAEBQg0KC19taW5fc2hvdWxkIkUKCU1pblNob3VsZBIlCgpjb25kaXRpb25zGAEgAygLMhEucWRyYW50LkNvbmRpdGlvbhIRCgltaW5fY291bnQYAiABKAQiywIKCUNvbmRpdGlvbhInCgVmaWVsZBgBIAEoCzIWLnFkcmFudC5GaWVsZENvbmRpdGlvbkgAEiwKCGlzX2VtcHR5GAIgASgLMhgucWRyYW50LklzRW1wdHlDb25kaXRpb25IABIoCgZoYXNfaWQYAyABKAsyFi5xZHJhbnQuSGFzSWRDb25kaXRpb25IABIgCgZmaWx0ZXIYBCABKAsyDi5xZHJhbnQuRmlsdGVySAASKgoHaXNfbnVsbBgFIAEoCzIXLnFkcmFudC5Jc051bGxDb25kaXRpb25IABIpCgZuZXN0ZWQYBiABKAsyFy5xZHJhbnQuTmVzdGVkQ29uZGl0aW9uSAASMAoKaGFzX3ZlY3RvchgHIAEoCzIaLnFkcmFudC5IYXNWZWN0b3JDb25kaXRpb25IAEISChBjb25kaXRpb25fb25lX29mIh8KEElzRW1wdHlDb25kaXRpb24SCwoDa2V5GAEgASgJIh4KD0lzTnVsbENvbmRpdGlvbhILCgNrZXkYASABKAkiMQoOSGFzSWRDb25kaXRpb24SHwoGaGFzX2lkGAEgAygLMg8ucWRyYW50LlBvaW50SWQiKAoSSGFzVmVjdG9yQ29uZGl0aW9uEhIKCmhhc192ZWN0b3IYASABKAkiPgoPTmVzdGVkQ29uZGl0aW9uEgsKA2tleRgBIAEoCRIeCgZmaWx0ZXIYAiABKAsyDi5xZHJhbnQuRmlsdGVyIvsCCg5GaWVsZENvbmRpdGlvbhILCgNrZXkYASABKAkSHAoFbWF0Y2gYAiABKAsyDS5xZHJhbnQuTWF0Y2gSHAoFcmFuZ2UYAyABKAsyDS5xZHJhbnQuUmFuZ2USMAoQZ2VvX2JvdW5kaW5nX2JveBgEIAEoCzIWLnFkcmFudC5HZW9Cb3VuZGluZ0JveBIlCgpnZW9fcmFkaXVzGAUgASgLMhEucWRyYW50Lkdlb1JhZGl1cxIpCgx2YWx1ZXNfY291bnQYBiABKAsyEy5xZHJhbnQuVmFsdWVzQ291bnQSJwoLZ2VvX3BvbHlnb24YByABKAsyEi5xZHJhbnQuR2VvUG9seWdvbhItCg5kYXRldGltZV9yYW5nZRgIIAEoCzIVLnFkcmFudC5EYXRldGltZVJhbmdlEhUKCGlzX2VtcHR5GAkgASgISACIAQESFAoHaXNfbnVsbBgKIAEoCEgBiAEBQgsKCV9pc19lbXB0eUIKCghfaXNfbnVsbCLJAgoFTWF0Y2gSEQoHa2V5d29yZBgBIAEoCUgAEhEKB2ludGVnZXIYAiABKANIABIRCgdib29sZWFuGAMgASgISAASDgoEdGV4dBgEIAEoCUgAEisKCGtleXdvcmRzGAUgASgLMhcucWRyYW50LlJlcGVhdGVkU3RyaW5nc0gAEiwKCGludGVnZXJzGAYgASgLMhgucWRyYW50LlJlcGVhdGVkSW50ZWdlcnNIABIzCg9leGNlcHRfaW50ZWdlcnMYByABKAsyGC5xZHJhbnQuUmVwZWF0ZWRJbnRlZ2Vyc0gAEjIKD2V4Y2VwdF9rZXl3b3JkcxgIIAEoCzIXLnFkcmFudC5SZXBlYXRlZFN0cmluZ3NIABIQCgZwaHJhc2UYCSABKAlIABISCgh0ZXh0X2FueRgKIAEoCUgAQg0KC21hdGNoX3ZhbHVlIiIKD1JlcGVhdGVkU3RyaW5ncxIPCgdzdHJpbmdzGAEgAygJIiQKEFJlcGVhdGVkSW50ZWdlcnMSEAoIaW50ZWdlcnMYASADKAMiawoFUmFuZ2USDwoCbHQYASABKAFIAIgBARIPCgJndBgCIAEoAUgBiAEBEhAKA2d0ZRgDIAEoAUgCiAEBEhAKA2x0ZRgEIAEoAUgDiAEBQgUKA19sdEIFCgNfZ3RCBgoEX2d0ZUIGCgRfbHRlIuMBCg1EYXRldGltZVJhbmdlEisKAmx0GAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAiAEBEisKAmd0GAIgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgBiAEBEiwKA2d0ZRgDIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBIAogBARIsCgNsdGUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wSAOIAQFCBQoDX2x0QgUKA19ndEIGCgRfZ3RlQgYKBF9sdGUiXAoOR2VvQm91bmRpbmdCb3gSIgoIdG9wX2xlZnQYASABKAsyEC5xZHJhbnQuR2VvUG9pbnQSJgoMYm90dG9tX3JpZ2h0GAIgASgLMhAucWRyYW50Lkdlb1BvaW50Ij0KCUdlb1JhZGl1cxIgCgZjZW50ZXIYASABKAsyEC5xZHJhbnQuR2VvUG9pbnQSDgoGcmFkaXVzGAIgASgCIjEKDUdlb0xpbmVTdHJpbmcSIAoGcG9pbnRzGAEgAygLMhAucWRyYW50Lkdlb1BvaW50Il8KCkdlb1BvbHlnb24SJwoIZXh0ZXJpb3IYASABKAsyFS5xZHJhbnQuR2VvTGluZVN0cmluZxIoCglpbnRlcmlvcnMYAiADKAsyFS5xZHJhbnQuR2VvTGluZVN0cmluZyJxCgtWYWx1ZXNDb3VudBIPCgJsdBgBIAEoBEgAiAEBEg8KAmd0GAIgASgESAGIAQESEAoDZ3RlGAMgASgESAKIAQESEAoDbHRlGAQgASgESAOIAQFCBQoDX2x0QgUKA19ndEIGCgRfZ3RlQgYKBF9sdGUidQoOUG9pbnRzU2VsZWN0b3ISJwoGcG9pbnRzGAEgASgLMhUucWRyYW50LlBvaW50c0lkc0xpc3RIABIgCgZmaWx0ZXIYAiABKAsyDi5xZHJhbnQuRmlsdGVySABCGAoWcG9pbnRzX3NlbGVjdG9yX29uZV9vZiItCg1Qb2ludHNJZHNMaXN0EhwKA2lkcxgBIAMoCzIPLnFkcmFudC5Qb2ludElkItUBCgtQb2ludFN0cnVjdBIbCgJpZBgBIAEoCzIPLnFkcmFudC5Qb2ludElkEjEKB3BheWxvYWQYAyADKAsyIC5xZHJhbnQuUG9pbnRTdHJ1Y3QuUGF5bG9hZEVudHJ5EiUKB3ZlY3RvcnMYBCABKAsyDy5xZHJhbnQuVmVjdG9yc0gAiAEBGj0KDFBheWxvYWRFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBQgoKCF92ZWN0b3JzSgQIAhADIiQKCEdlb1BvaW50EgsKA2xvbhgBIAEoARILCgNsYXQYAiABKAEigAEKBVVzYWdlEiwKCGhhcmR3YXJlGAEgASgLMhUucWRyYW50LkhhcmR3YXJlVXNhZ2VIAIgBARIuCglpbmZlcmVuY2UYAiABKAsyFi5xZHJhbnQuSW5mZXJlbmNlVXNhZ2VIAYgBAUILCglfaGFyZHdhcmVCDAoKX2luZmVyZW5jZSKHAQoOSW5mZXJlbmNlVXNhZ2USMgoGbW9kZWxzGAEgAygLMiIucWRyYW50LkluZmVyZW5jZVVzYWdlLk1vZGVsc0VudHJ5GkEKC01vZGVsc0VudHJ5EgsKA2tleRgBIAEoCRIhCgV2YWx1ZRgCIAEoCzISLnFkcmFudC5Nb2RlbFVzYWdlOgI4ASIcCgpNb2RlbFVzYWdlEg4KBnRva2VucxgBIAEoBCK/AQoNSGFyZHdhcmVVc2FnZRILCgNjcHUYASABKAQSFwoPcGF5bG9hZF9pb19yZWFkGAIgASgEEhgKEHBheWxvYWRfaW9fd3JpdGUYAyABKAQSHQoVcGF5bG9hZF9pbmRleF9pb19yZWFkGAQgASgEEh4KFnBheWxvYWRfaW5kZXhfaW9fd3JpdGUYBSABKAQSFgoOdmVjdG9yX2lvX3JlYWQYBiABKAQSFwoPdmVjdG9yX2lvX3dyaXRlGAcgASgEKjUKEVdyaXRlT3JkZXJpbmdUeXBlEggKBFdlYWsQABIKCgZNZWRpdW0QARIKCgZTdHJvbmcQAio4ChNSZWFkQ29uc2lzdGVuY3lUeXBlEgcKA0FsbBAAEgwKCE1ham9yaXR5EAESCgoGUXVvcnVtEAIqrQEKCUZpZWxkVHlwZRIUChBGaWVsZFR5cGVLZXl3b3JkEAASFAoQRmllbGRUeXBlSW50ZWdlchABEhIKDkZpZWxkVHlwZUZsb2F0EAISEAoMRmllbGRUeXBlR2VvEAMSEQoNRmllbGRUeXBlVGV4dBAEEhEKDUZpZWxkVHlwZUJvb2wQBRIVChFGaWVsZFR5cGVEYXRldGltZRAGEhEKDUZpZWxkVHlwZVV1aWQQByoeCglEaXJlY3Rpb24SBwoDQXNjEAASCAoERGVzYxABKkQKEVJlY29tbWVuZFN0cmF0ZWd5EhEKDUF2ZXJhZ2VWZWN0b3IQABINCglCZXN0U2NvcmUQARINCglTdW1TY29yZXMQAiobCgZGdXNpb24SBwoDUlJGEAASCAoEREJTRhABKhQKBlNhbXBsZRIKCgZSYW5kb20QACpbCgxVcGRhdGVTdGF0dXMSFwoTVW5rbm93blVwZGF0ZVN0YXR1cxAAEhAKDEFja25vd2xlZGdlZBABEg0KCUNvbXBsZXRlZBACEhEKDUNsb2NrUmVqZWN0ZWQQA0IVqgISUWRyYW50LkNsaWVudC5HcnBjYgZwcm90bzM", [file_collections, file_google_protobuf_timestamp, file_json_with_int]);

/**
 * @generated from message qdrant.WriteOrdering
 */
export type WriteOrdering = Message<"qdrant.WriteOrdering"> & {
  /**
   * Write ordering guarantees
   *
   * @generated from field: qdrant.WriteOrderingType type = 1;
   */
  type: WriteOrderingType;
};

/**
 * Describes the message qdrant.WriteOrdering.
 * Use `create(WriteOrderingSchema)` to create a new message.
 */
export const WriteOrderingSchema: GenMessage<WriteOrdering> = /*@__PURE__*/
  messageDesc(file_points, 0);

/**
 * @generated from message qdrant.ReadConsistency
 */
export type ReadConsistency = Message<"qdrant.ReadConsistency"> & {
  /**
   * @generated from oneof qdrant.ReadConsistency.value
   */
  value: {
    /**
     * Common read consistency configurations
     *
     * @generated from field: qdrant.ReadConsistencyType type = 1;
     */
    value: ReadConsistencyType;
    case: "type";
  } | {
    /**
     * Send request to a specified number of nodes, and return points which are present on all of them
     *
     * @generated from field: uint64 factor = 2;
     */
    value: bigint;
    case: "factor";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.ReadConsistency.
 * Use `create(ReadConsistencySchema)` to create a new message.
 */
export const ReadConsistencySchema: GenMessage<ReadConsistency> = /*@__PURE__*/
  messageDesc(file_points, 1);

/**
 * @generated from message qdrant.PointId
 */
export type PointId = Message<"qdrant.PointId"> & {
  /**
   * @generated from oneof qdrant.PointId.point_id_options
   */
  pointIdOptions: {
    /**
     * Numerical ID of the point
     *
     * @generated from field: uint64 num = 1;
     */
    value: bigint;
    case: "num";
  } | {
    /**
     * UUID
     *
     * @generated from field: string uuid = 2;
     */
    value: string;
    case: "uuid";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.PointId.
 * Use `create(PointIdSchema)` to create a new message.
 */
export const PointIdSchema: GenMessage<PointId> = /*@__PURE__*/
  messageDesc(file_points, 2);

/**
 * @generated from message qdrant.SparseIndices
 */
export type SparseIndices = Message<"qdrant.SparseIndices"> & {
  /**
   * @generated from field: repeated uint32 data = 1;
   */
  data: number[];
};

/**
 * Describes the message qdrant.SparseIndices.
 * Use `create(SparseIndicesSchema)` to create a new message.
 */
export const SparseIndicesSchema: GenMessage<SparseIndices> = /*@__PURE__*/
  messageDesc(file_points, 3);

/**
 * @generated from message qdrant.Document
 */
export type Document = Message<"qdrant.Document"> & {
  /**
   * Text of the document
   *
   * @generated from field: string text = 1;
   */
  text: string;

  /**
   * Model name
   *
   * @generated from field: string model = 3;
   */
  model: string;

  /**
   * Model options
   *
   * @generated from field: map<string, qdrant.Value> options = 4;
   */
  options: { [key: string]: Value };
};

/**
 * Describes the message qdrant.Document.
 * Use `create(DocumentSchema)` to create a new message.
 */
export const DocumentSchema: GenMessage<Document> = /*@__PURE__*/
  messageDesc(file_points, 4);

/**
 * @generated from message qdrant.Image
 */
export type Image = Message<"qdrant.Image"> & {
  /**
   * Image data, either base64 encoded or URL
   *
   * @generated from field: qdrant.Value image = 1;
   */
  image?: Value;

  /**
   * Model name
   *
   * @generated from field: string model = 2;
   */
  model: string;

  /**
   * Model options
   *
   * @generated from field: map<string, qdrant.Value> options = 3;
   */
  options: { [key: string]: Value };
};

/**
 * Describes the message qdrant.Image.
 * Use `create(ImageSchema)` to create a new message.
 */
export const ImageSchema: GenMessage<Image> = /*@__PURE__*/
  messageDesc(file_points, 5);

/**
 * @generated from message qdrant.InferenceObject
 */
export type InferenceObject = Message<"qdrant.InferenceObject"> & {
  /**
   * Object to infer
   *
   * @generated from field: qdrant.Value object = 1;
   */
  object?: Value;

  /**
   * Model name
   *
   * @generated from field: string model = 2;
   */
  model: string;

  /**
   * Model options
   *
   * @generated from field: map<string, qdrant.Value> options = 3;
   */
  options: { [key: string]: Value };
};

/**
 * Describes the message qdrant.InferenceObject.
 * Use `create(InferenceObjectSchema)` to create a new message.
 */
export const InferenceObjectSchema: GenMessage<InferenceObject> = /*@__PURE__*/
  messageDesc(file_points, 6);

/**
 * @generated from message qdrant.Vector
 */
export type Vector = Message<"qdrant.Vector"> & {
  /**
   * Vector data (flatten for multi vectors), deprecated
   *
   * @generated from field: repeated float data = 1;
   */
  data: number[];

  /**
   * Sparse indices for sparse vectors, deprecated
   *
   * @generated from field: optional qdrant.SparseIndices indices = 2;
   */
  indices?: SparseIndices;

  /**
   * Number of vectors per multi vector, deprecated
   *
   * @generated from field: optional uint32 vectors_count = 3;
   */
  vectorsCount?: number;

  /**
   * @generated from oneof qdrant.Vector.vector
   */
  vector: {
    /**
     * Dense vector
     *
     * @generated from field: qdrant.DenseVector dense = 101;
     */
    value: DenseVector;
    case: "dense";
  } | {
    /**
     * Sparse vector
     *
     * @generated from field: qdrant.SparseVector sparse = 102;
     */
    value: SparseVector;
    case: "sparse";
  } | {
    /**
     * Multi dense vector
     *
     * @generated from field: qdrant.MultiDenseVector multi_dense = 103;
     */
    value: MultiDenseVector;
    case: "multiDense";
  } | {
    /**
     * @generated from field: qdrant.Document document = 104;
     */
    value: Document;
    case: "document";
  } | {
    /**
     * @generated from field: qdrant.Image image = 105;
     */
    value: Image;
    case: "image";
  } | {
    /**
     * @generated from field: qdrant.InferenceObject object = 106;
     */
    value: InferenceObject;
    case: "object";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Vector.
 * Use `create(VectorSchema)` to create a new message.
 */
export const VectorSchema: GenMessage<Vector> = /*@__PURE__*/
  messageDesc(file_points, 7);

/**
 * @generated from message qdrant.VectorOutput
 */
export type VectorOutput = Message<"qdrant.VectorOutput"> & {
  /**
   * Vector data (flatten for multi vectors), deprecated
   *
   * @generated from field: repeated float data = 1;
   */
  data: number[];

  /**
   * Sparse indices for sparse vectors, deprecated
   *
   * @generated from field: optional qdrant.SparseIndices indices = 2;
   */
  indices?: SparseIndices;

  /**
   * Number of vectors per multi vector, deprecated
   *
   * @generated from field: optional uint32 vectors_count = 3;
   */
  vectorsCount?: number;

  /**
   * @generated from oneof qdrant.VectorOutput.vector
   */
  vector: {
    /**
     * Dense vector
     *
     * @generated from field: qdrant.DenseVector dense = 101;
     */
    value: DenseVector;
    case: "dense";
  } | {
    /**
     * Sparse vector
     *
     * @generated from field: qdrant.SparseVector sparse = 102;
     */
    value: SparseVector;
    case: "sparse";
  } | {
    /**
     * Multi dense vector
     *
     * @generated from field: qdrant.MultiDenseVector multi_dense = 103;
     */
    value: MultiDenseVector;
    case: "multiDense";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorOutput.
 * Use `create(VectorOutputSchema)` to create a new message.
 */
export const VectorOutputSchema: GenMessage<VectorOutput> = /*@__PURE__*/
  messageDesc(file_points, 8);

/**
 * @generated from message qdrant.DenseVector
 */
export type DenseVector = Message<"qdrant.DenseVector"> & {
  /**
   * @generated from field: repeated float data = 1;
   */
  data: number[];
};

/**
 * Describes the message qdrant.DenseVector.
 * Use `create(DenseVectorSchema)` to create a new message.
 */
export const DenseVectorSchema: GenMessage<DenseVector> = /*@__PURE__*/
  messageDesc(file_points, 9);

/**
 * @generated from message qdrant.SparseVector
 */
export type SparseVector = Message<"qdrant.SparseVector"> & {
  /**
   * @generated from field: repeated float values = 1;
   */
  values: number[];

  /**
   * @generated from field: repeated uint32 indices = 2;
   */
  indices: number[];
};

/**
 * Describes the message qdrant.SparseVector.
 * Use `create(SparseVectorSchema)` to create a new message.
 */
export const SparseVectorSchema: GenMessage<SparseVector> = /*@__PURE__*/
  messageDesc(file_points, 10);

/**
 * @generated from message qdrant.MultiDenseVector
 */
export type MultiDenseVector = Message<"qdrant.MultiDenseVector"> & {
  /**
   * @generated from field: repeated qdrant.DenseVector vectors = 1;
   */
  vectors: DenseVector[];
};

/**
 * Describes the message qdrant.MultiDenseVector.
 * Use `create(MultiDenseVectorSchema)` to create a new message.
 */
export const MultiDenseVectorSchema: GenMessage<MultiDenseVector> = /*@__PURE__*/
  messageDesc(file_points, 11);

/**
 * Vector type to be used in queries. Ids will be substituted with their corresponding vectors from the collection.
 *
 * @generated from message qdrant.VectorInput
 */
export type VectorInput = Message<"qdrant.VectorInput"> & {
  /**
   * @generated from oneof qdrant.VectorInput.variant
   */
  variant: {
    /**
     * @generated from field: qdrant.PointId id = 1;
     */
    value: PointId;
    case: "id";
  } | {
    /**
     * @generated from field: qdrant.DenseVector dense = 2;
     */
    value: DenseVector;
    case: "dense";
  } | {
    /**
     * @generated from field: qdrant.SparseVector sparse = 3;
     */
    value: SparseVector;
    case: "sparse";
  } | {
    /**
     * @generated from field: qdrant.MultiDenseVector multi_dense = 4;
     */
    value: MultiDenseVector;
    case: "multiDense";
  } | {
    /**
     * @generated from field: qdrant.Document document = 5;
     */
    value: Document;
    case: "document";
  } | {
    /**
     * @generated from field: qdrant.Image image = 6;
     */
    value: Image;
    case: "image";
  } | {
    /**
     * @generated from field: qdrant.InferenceObject object = 7;
     */
    value: InferenceObject;
    case: "object";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorInput.
 * Use `create(VectorInputSchema)` to create a new message.
 */
export const VectorInputSchema: GenMessage<VectorInput> = /*@__PURE__*/
  messageDesc(file_points, 12);

/**
 * @generated from message qdrant.ShardKeySelector
 */
export type ShardKeySelector = Message<"qdrant.ShardKeySelector"> & {
  /**
   * List of shard keys which should be used in the request
   *
   * @generated from field: repeated qdrant.ShardKey shard_keys = 1;
   */
  shardKeys: ShardKey[];

  /**
   * @generated from field: optional qdrant.ShardKey fallback = 2;
   */
  fallback?: ShardKey;
};

/**
 * Describes the message qdrant.ShardKeySelector.
 * Use `create(ShardKeySelectorSchema)` to create a new message.
 */
export const ShardKeySelectorSchema: GenMessage<ShardKeySelector> = /*@__PURE__*/
  messageDesc(file_points, 13);

/**
 * @generated from message qdrant.UpsertPoints
 */
export type UpsertPoints = Message<"qdrant.UpsertPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * @generated from field: repeated qdrant.PointStruct points = 3;
   */
  points: PointStruct[];

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated, others will be inserted
   *
   * @generated from field: optional qdrant.Filter update_filter = 6;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.UpsertPoints.
 * Use `create(UpsertPointsSchema)` to create a new message.
 */
export const UpsertPointsSchema: GenMessage<UpsertPoints> = /*@__PURE__*/
  messageDesc(file_points, 14);

/**
 * @generated from message qdrant.DeletePoints
 */
export type DeletePoints = Message<"qdrant.DeletePoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 3;
   */
  points?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DeletePoints.
 * Use `create(DeletePointsSchema)` to create a new message.
 */
export const DeletePointsSchema: GenMessage<DeletePoints> = /*@__PURE__*/
  messageDesc(file_points, 15);

/**
 * @generated from message qdrant.GetPoints
 */
export type GetPoints = Message<"qdrant.GetPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * List of points to retrieve
   *
   * @generated from field: repeated qdrant.PointId ids = 2;
   */
  ids: PointId[];

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 4;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 5;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 6;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 8;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.GetPoints.
 * Use `create(GetPointsSchema)` to create a new message.
 */
export const GetPointsSchema: GenMessage<GetPoints> = /*@__PURE__*/
  messageDesc(file_points, 16);

/**
 * @generated from message qdrant.UpdatePointVectors
 */
export type UpdatePointVectors = Message<"qdrant.UpdatePointVectors"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * List of points and vectors to update
   *
   * @generated from field: repeated qdrant.PointVectors points = 3;
   */
  points: PointVectors[];

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated
   *
   * @generated from field: optional qdrant.Filter update_filter = 6;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.UpdatePointVectors.
 * Use `create(UpdatePointVectorsSchema)` to create a new message.
 */
export const UpdatePointVectorsSchema: GenMessage<UpdatePointVectors> = /*@__PURE__*/
  messageDesc(file_points, 17);

/**
 * @generated from message qdrant.PointVectors
 */
export type PointVectors = Message<"qdrant.PointVectors"> & {
  /**
   * ID to update vectors for
   *
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * Named vectors to update, leave others intact
   *
   * @generated from field: qdrant.Vectors vectors = 2;
   */
  vectors?: Vectors;
};

/**
 * Describes the message qdrant.PointVectors.
 * Use `create(PointVectorsSchema)` to create a new message.
 */
export const PointVectorsSchema: GenMessage<PointVectors> = /*@__PURE__*/
  messageDesc(file_points, 18);

/**
 * @generated from message qdrant.DeletePointVectors
 */
export type DeletePointVectors = Message<"qdrant.DeletePointVectors"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points_selector = 3;
   */
  pointsSelector?: PointsSelector;

  /**
   * List of vector names to delete
   *
   * @generated from field: qdrant.VectorsSelector vectors = 4;
   */
  vectors?: VectorsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 5;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 6;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DeletePointVectors.
 * Use `create(DeletePointVectorsSchema)` to create a new message.
 */
export const DeletePointVectorsSchema: GenMessage<DeletePointVectors> = /*@__PURE__*/
  messageDesc(file_points, 19);

/**
 * @generated from message qdrant.SetPayloadPoints
 */
export type SetPayloadPoints = Message<"qdrant.SetPayloadPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * New payload values
   *
   * @generated from field: map<string, qdrant.Value> payload = 3;
   */
  payload: { [key: string]: Value };

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 5;
   */
  pointsSelector?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Option for indicate property of payload
   *
   * @generated from field: optional string key = 8;
   */
  key?: string;
};

/**
 * Describes the message qdrant.SetPayloadPoints.
 * Use `create(SetPayloadPointsSchema)` to create a new message.
 */
export const SetPayloadPointsSchema: GenMessage<SetPayloadPoints> = /*@__PURE__*/
  messageDesc(file_points, 20);

/**
 * @generated from message qdrant.DeletePayloadPoints
 */
export type DeletePayloadPoints = Message<"qdrant.DeletePayloadPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * List of keys to delete
   *
   * @generated from field: repeated string keys = 3;
   */
  keys: string[];

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 5;
   */
  pointsSelector?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 7;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DeletePayloadPoints.
 * Use `create(DeletePayloadPointsSchema)` to create a new message.
 */
export const DeletePayloadPointsSchema: GenMessage<DeletePayloadPoints> = /*@__PURE__*/
  messageDesc(file_points, 21);

/**
 * @generated from message qdrant.ClearPayloadPoints
 */
export type ClearPayloadPoints = Message<"qdrant.ClearPayloadPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 3;
   */
  points?: PointsSelector;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.ClearPayloadPoints.
 * Use `create(ClearPayloadPointsSchema)` to create a new message.
 */
export const ClearPayloadPointsSchema: GenMessage<ClearPayloadPoints> = /*@__PURE__*/
  messageDesc(file_points, 22);

/**
 * @generated from message qdrant.CreateFieldIndexCollection
 */
export type CreateFieldIndexCollection = Message<"qdrant.CreateFieldIndexCollection"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Field name to index
   *
   * @generated from field: string field_name = 3;
   */
  fieldName: string;

  /**
   * Field type.
   *
   * @generated from field: optional qdrant.FieldType field_type = 4;
   */
  fieldType?: FieldType;

  /**
   * Payload index params.
   *
   * @generated from field: optional qdrant.PayloadIndexParams field_index_params = 5;
   */
  fieldIndexParams?: PayloadIndexParams;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 6;
   */
  ordering?: WriteOrdering;
};

/**
 * Describes the message qdrant.CreateFieldIndexCollection.
 * Use `create(CreateFieldIndexCollectionSchema)` to create a new message.
 */
export const CreateFieldIndexCollectionSchema: GenMessage<CreateFieldIndexCollection> = /*@__PURE__*/
  messageDesc(file_points, 23);

/**
 * @generated from message qdrant.DeleteFieldIndexCollection
 */
export type DeleteFieldIndexCollection = Message<"qdrant.DeleteFieldIndexCollection"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * Field name to delete
   *
   * @generated from field: string field_name = 3;
   */
  fieldName: string;

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;
};

/**
 * Describes the message qdrant.DeleteFieldIndexCollection.
 * Use `create(DeleteFieldIndexCollectionSchema)` to create a new message.
 */
export const DeleteFieldIndexCollectionSchema: GenMessage<DeleteFieldIndexCollection> = /*@__PURE__*/
  messageDesc(file_points, 24);

/**
 * @generated from message qdrant.PayloadIncludeSelector
 */
export type PayloadIncludeSelector = Message<"qdrant.PayloadIncludeSelector"> & {
  /**
   * List of payload keys to include into result
   *
   * @generated from field: repeated string fields = 1;
   */
  fields: string[];
};

/**
 * Describes the message qdrant.PayloadIncludeSelector.
 * Use `create(PayloadIncludeSelectorSchema)` to create a new message.
 */
export const PayloadIncludeSelectorSchema: GenMessage<PayloadIncludeSelector> = /*@__PURE__*/
  messageDesc(file_points, 25);

/**
 * @generated from message qdrant.PayloadExcludeSelector
 */
export type PayloadExcludeSelector = Message<"qdrant.PayloadExcludeSelector"> & {
  /**
   * List of payload keys to exclude from the result
   *
   * @generated from field: repeated string fields = 1;
   */
  fields: string[];
};

/**
 * Describes the message qdrant.PayloadExcludeSelector.
 * Use `create(PayloadExcludeSelectorSchema)` to create a new message.
 */
export const PayloadExcludeSelectorSchema: GenMessage<PayloadExcludeSelector> = /*@__PURE__*/
  messageDesc(file_points, 26);

/**
 * @generated from message qdrant.WithPayloadSelector
 */
export type WithPayloadSelector = Message<"qdrant.WithPayloadSelector"> & {
  /**
   * @generated from oneof qdrant.WithPayloadSelector.selector_options
   */
  selectorOptions: {
    /**
     * If `true` - return all payload, if `false` - none
     *
     * @generated from field: bool enable = 1;
     */
    value: boolean;
    case: "enable";
  } | {
    /**
     * @generated from field: qdrant.PayloadIncludeSelector include = 2;
     */
    value: PayloadIncludeSelector;
    case: "include";
  } | {
    /**
     * @generated from field: qdrant.PayloadExcludeSelector exclude = 3;
     */
    value: PayloadExcludeSelector;
    case: "exclude";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.WithPayloadSelector.
 * Use `create(WithPayloadSelectorSchema)` to create a new message.
 */
export const WithPayloadSelectorSchema: GenMessage<WithPayloadSelector> = /*@__PURE__*/
  messageDesc(file_points, 27);

/**
 * @generated from message qdrant.NamedVectors
 */
export type NamedVectors = Message<"qdrant.NamedVectors"> & {
  /**
   * @generated from field: map<string, qdrant.Vector> vectors = 1;
   */
  vectors: { [key: string]: Vector };
};

/**
 * Describes the message qdrant.NamedVectors.
 * Use `create(NamedVectorsSchema)` to create a new message.
 */
export const NamedVectorsSchema: GenMessage<NamedVectors> = /*@__PURE__*/
  messageDesc(file_points, 28);

/**
 * @generated from message qdrant.NamedVectorsOutput
 */
export type NamedVectorsOutput = Message<"qdrant.NamedVectorsOutput"> & {
  /**
   * @generated from field: map<string, qdrant.VectorOutput> vectors = 1;
   */
  vectors: { [key: string]: VectorOutput };
};

/**
 * Describes the message qdrant.NamedVectorsOutput.
 * Use `create(NamedVectorsOutputSchema)` to create a new message.
 */
export const NamedVectorsOutputSchema: GenMessage<NamedVectorsOutput> = /*@__PURE__*/
  messageDesc(file_points, 29);

/**
 * @generated from message qdrant.Vectors
 */
export type Vectors = Message<"qdrant.Vectors"> & {
  /**
   * @generated from oneof qdrant.Vectors.vectors_options
   */
  vectorsOptions: {
    /**
     * @generated from field: qdrant.Vector vector = 1;
     */
    value: Vector;
    case: "vector";
  } | {
    /**
     * @generated from field: qdrant.NamedVectors vectors = 2;
     */
    value: NamedVectors;
    case: "vectors";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Vectors.
 * Use `create(VectorsSchema)` to create a new message.
 */
export const VectorsSchema: GenMessage<Vectors> = /*@__PURE__*/
  messageDesc(file_points, 30);

/**
 * @generated from message qdrant.VectorsOutput
 */
export type VectorsOutput = Message<"qdrant.VectorsOutput"> & {
  /**
   * @generated from oneof qdrant.VectorsOutput.vectors_options
   */
  vectorsOptions: {
    /**
     * @generated from field: qdrant.VectorOutput vector = 1;
     */
    value: VectorOutput;
    case: "vector";
  } | {
    /**
     * @generated from field: qdrant.NamedVectorsOutput vectors = 2;
     */
    value: NamedVectorsOutput;
    case: "vectors";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorsOutput.
 * Use `create(VectorsOutputSchema)` to create a new message.
 */
export const VectorsOutputSchema: GenMessage<VectorsOutput> = /*@__PURE__*/
  messageDesc(file_points, 31);

/**
 * @generated from message qdrant.VectorsSelector
 */
export type VectorsSelector = Message<"qdrant.VectorsSelector"> & {
  /**
   * List of vectors to include into result
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];
};

/**
 * Describes the message qdrant.VectorsSelector.
 * Use `create(VectorsSelectorSchema)` to create a new message.
 */
export const VectorsSelectorSchema: GenMessage<VectorsSelector> = /*@__PURE__*/
  messageDesc(file_points, 32);

/**
 * @generated from message qdrant.WithVectorsSelector
 */
export type WithVectorsSelector = Message<"qdrant.WithVectorsSelector"> & {
  /**
   * @generated from oneof qdrant.WithVectorsSelector.selector_options
   */
  selectorOptions: {
    /**
     * If `true` - return all vectors, if `false` - none
     *
     * @generated from field: bool enable = 1;
     */
    value: boolean;
    case: "enable";
  } | {
    /**
     * List of payload keys to include into result
     *
     * @generated from field: qdrant.VectorsSelector include = 2;
     */
    value: VectorsSelector;
    case: "include";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.WithVectorsSelector.
 * Use `create(WithVectorsSelectorSchema)` to create a new message.
 */
export const WithVectorsSelectorSchema: GenMessage<WithVectorsSelector> = /*@__PURE__*/
  messageDesc(file_points, 33);

/**
 * @generated from message qdrant.QuantizationSearchParams
 */
export type QuantizationSearchParams = Message<"qdrant.QuantizationSearchParams"> & {
  /**
   *
   * If set to true, search will ignore quantized vector data
   *
   * @generated from field: optional bool ignore = 1;
   */
  ignore?: boolean;

  /**
   *
   * If true, use original vectors to re-score top-k results. If ignored, qdrant decides automatically does rescore enabled or not.
   *
   * @generated from field: optional bool rescore = 2;
   */
  rescore?: boolean;

  /**
   *
   * Oversampling factor for quantization.
   *
   * Defines how many extra vectors should be pre-selected using quantized index,
   * and then re-scored using original vectors.
   *
   * For example, if `oversampling` is 2.4 and `limit` is 100, then 240 vectors will be pre-selected using quantized index,
   * and then top-100 will be returned after re-scoring.
   *
   * @generated from field: optional double oversampling = 3;
   */
  oversampling?: number;
};

/**
 * Describes the message qdrant.QuantizationSearchParams.
 * Use `create(QuantizationSearchParamsSchema)` to create a new message.
 */
export const QuantizationSearchParamsSchema: GenMessage<QuantizationSearchParams> = /*@__PURE__*/
  messageDesc(file_points, 34);

/**
 * @generated from message qdrant.AcornSearchParams
 */
export type AcornSearchParams = Message<"qdrant.AcornSearchParams"> & {
  /**
   *
   * If true, then ACORN may be used for the HNSW search based on filters
   * selectivity.
   *
   * Improves search recall for searches with multiple low-selectivity
   * payload filters, at cost of performance.
   *
   * @generated from field: optional bool enable = 1;
   */
  enable?: boolean;

  /**
   *
   * Maximum selectivity of filters to enable ACORN.
   *
   * If estimated filters selectivity is higher than this value,
   * ACORN will not be used. Selectivity is estimated as:
   * `estimated number of points satisfying the filters / total number of points`.
   *
   * 0.0 for never, 1.0 for always. Default is 0.4.
   *
   * @generated from field: optional double max_selectivity = 2;
   */
  maxSelectivity?: number;
};

/**
 * Describes the message qdrant.AcornSearchParams.
 * Use `create(AcornSearchParamsSchema)` to create a new message.
 */
export const AcornSearchParamsSchema: GenMessage<AcornSearchParams> = /*@__PURE__*/
  messageDesc(file_points, 35);

/**
 * @generated from message qdrant.SearchParams
 */
export type SearchParams = Message<"qdrant.SearchParams"> & {
  /**
   *
   * Params relevant to HNSW index. Size of the beam in a beam-search.
   * Larger the value - more accurate the result, more time required for search.
   *
   * @generated from field: optional uint64 hnsw_ef = 1;
   */
  hnswEf?: bigint;

  /**
   *
   * Search without approximation. If set to true, search may run long but with exact results.
   *
   * @generated from field: optional bool exact = 2;
   */
  exact?: boolean;

  /**
   *
   * If set to true, search will ignore quantized vector data
   *
   * @generated from field: optional qdrant.QuantizationSearchParams quantization = 3;
   */
  quantization?: QuantizationSearchParams;

  /**
   *
   * If enabled, the engine will only perform search among indexed or small segments.
   * Using this option prevents slow searches in case of delayed index, but does not
   * guarantee that all uploaded vectors will be included in search results
   *
   * @generated from field: optional bool indexed_only = 4;
   */
  indexedOnly?: boolean;

  /**
   *
   * ACORN search params
   *
   * @generated from field: optional qdrant.AcornSearchParams acorn = 5;
   */
  acorn?: AcornSearchParams;
};

/**
 * Describes the message qdrant.SearchParams.
 * Use `create(SearchParamsSchema)` to create a new message.
 */
export const SearchParamsSchema: GenMessage<SearchParams> = /*@__PURE__*/
  messageDesc(file_points, 36);

/**
 * @generated from message qdrant.SearchPoints
 */
export type SearchPoints = Message<"qdrant.SearchPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * vector
   *
   * @generated from field: repeated float vector = 2;
   */
  vector: number[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 4;
   */
  limit: bigint;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 7;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 8;
   */
  scoreThreshold?: number;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 9;
   */
  offset?: bigint;

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 10;
   */
  vectorName?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 11;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 13;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 14;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * @generated from field: optional qdrant.SparseIndices sparse_indices = 15;
   */
  sparseIndices?: SparseIndices;
};

/**
 * Describes the message qdrant.SearchPoints.
 * Use `create(SearchPointsSchema)` to create a new message.
 */
export const SearchPointsSchema: GenMessage<SearchPoints> = /*@__PURE__*/
  messageDesc(file_points, 37);

/**
 * @generated from message qdrant.SearchBatchPoints
 */
export type SearchBatchPoints = Message<"qdrant.SearchBatchPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.SearchPoints search_points = 2;
   */
  searchPoints: SearchPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.SearchBatchPoints.
 * Use `create(SearchBatchPointsSchema)` to create a new message.
 */
export const SearchBatchPointsSchema: GenMessage<SearchBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 38);

/**
 * @generated from message qdrant.WithLookup
 */
export type WithLookup = Message<"qdrant.WithLookup"> & {
  /**
   * Name of the collection to use for points lookup
   *
   * @generated from field: string collection = 1;
   */
  collection: string;

  /**
   * Options for specifying which payload to include (or not)
   *
   * @generated from field: optional qdrant.WithPayloadSelector with_payload = 2;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include (or not)
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 3;
   */
  withVectors?: WithVectorsSelector;
};

/**
 * Describes the message qdrant.WithLookup.
 * Use `create(WithLookupSchema)` to create a new message.
 */
export const WithLookupSchema: GenMessage<WithLookup> = /*@__PURE__*/
  messageDesc(file_points, 39);

/**
 * @generated from message qdrant.SearchPointGroups
 */
export type SearchPointGroups = Message<"qdrant.SearchPointGroups"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Vector to compare against
   *
   * @generated from field: repeated float vector = 2;
   */
  vector: number[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint32 limit = 4;
   */
  limit: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 5;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 6;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 7;
   */
  scoreThreshold?: number;

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 8;
   */
  vectorName?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 9;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
   *
   * @generated from field: string group_by = 10;
   */
  groupBy: string;

  /**
   * Maximum amount of points to return per group
   *
   * @generated from field: uint32 group_size = 11;
   */
  groupSize: number;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * Options for specifying how to use the group id to lookup points in another collection
   *
   * @generated from field: optional qdrant.WithLookup with_lookup = 13;
   */
  withLookup?: WithLookup;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 14;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 15;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * @generated from field: optional qdrant.SparseIndices sparse_indices = 16;
   */
  sparseIndices?: SparseIndices;
};

/**
 * Describes the message qdrant.SearchPointGroups.
 * Use `create(SearchPointGroupsSchema)` to create a new message.
 */
export const SearchPointGroupsSchema: GenMessage<SearchPointGroups> = /*@__PURE__*/
  messageDesc(file_points, 40);

/**
 * @generated from message qdrant.StartFrom
 */
export type StartFrom = Message<"qdrant.StartFrom"> & {
  /**
   * @generated from oneof qdrant.StartFrom.value
   */
  value: {
    /**
     * @generated from field: double float = 1;
     */
    value: number;
    case: "float";
  } | {
    /**
     * @generated from field: int64 integer = 2;
     */
    value: bigint;
    case: "integer";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp timestamp = 3;
     */
    value: Timestamp;
    case: "timestamp";
  } | {
    /**
     * @generated from field: string datetime = 4;
     */
    value: string;
    case: "datetime";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.StartFrom.
 * Use `create(StartFromSchema)` to create a new message.
 */
export const StartFromSchema: GenMessage<StartFrom> = /*@__PURE__*/
  messageDesc(file_points, 41);

/**
 * @generated from message qdrant.OrderBy
 */
export type OrderBy = Message<"qdrant.OrderBy"> & {
  /**
   * Payload key to order by
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Ascending or descending order
   *
   * @generated from field: optional qdrant.Direction direction = 2;
   */
  direction?: Direction;

  /**
   * Start from this value
   *
   * @generated from field: optional qdrant.StartFrom start_from = 3;
   */
  startFrom?: StartFrom;
};

/**
 * Describes the message qdrant.OrderBy.
 * Use `create(OrderBySchema)` to create a new message.
 */
export const OrderBySchema: GenMessage<OrderBy> = /*@__PURE__*/
  messageDesc(file_points, 42);

/**
 * @generated from message qdrant.ScrollPoints
 */
export type ScrollPoints = Message<"qdrant.ScrollPoints"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * Start with this ID
   *
   * @generated from field: optional qdrant.PointId offset = 3;
   */
  offset?: PointId;

  /**
   * Max number of result
   *
   * @generated from field: optional uint32 limit = 4;
   */
  limit?: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 7;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 8;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 9;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Order the records by a payload field
   *
   * @generated from field: optional qdrant.OrderBy order_by = 10;
   */
  orderBy?: OrderBy;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 11;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.ScrollPoints.
 * Use `create(ScrollPointsSchema)` to create a new message.
 */
export const ScrollPointsSchema: GenMessage<ScrollPoints> = /*@__PURE__*/
  messageDesc(file_points, 43);

/**
 * @generated from message qdrant.LookupLocation
 */
export type LookupLocation = Message<"qdrant.LookupLocation"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Which vector to use for search, if not specified - use default vector
   *
   * @generated from field: optional string vector_name = 2;
   */
  vectorName?: string;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.LookupLocation.
 * Use `create(LookupLocationSchema)` to create a new message.
 */
export const LookupLocationSchema: GenMessage<LookupLocation> = /*@__PURE__*/
  messageDesc(file_points, 44);

/**
 * @generated from message qdrant.RecommendPoints
 */
export type RecommendPoints = Message<"qdrant.RecommendPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Look for vectors closest to the vectors from these points
   *
   * @generated from field: repeated qdrant.PointId positive = 2;
   */
  positive: PointId[];

  /**
   * Try to avoid vectors like the vector from these points
   *
   * @generated from field: repeated qdrant.PointId negative = 3;
   */
  negative: PointId[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 5;
   */
  limit: bigint;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 7;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 8;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 9;
   */
  scoreThreshold?: number;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 10;
   */
  offset?: bigint;

  /**
   * Define which vector to use for recommendation, if not specified - default vector
   *
   * @generated from field: optional string using = 11;
   */
  using?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 12;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Name of the collection to use for points lookup, if not specified - use current collection
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 13;
   */
  lookupFrom?: LookupLocation;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
   */
  readConsistency?: ReadConsistency;

  /**
   * How to use the example vectors to find the results
   *
   * @generated from field: optional qdrant.RecommendStrategy strategy = 16;
   */
  strategy?: RecommendStrategy;

  /**
   * Look for vectors closest to those
   *
   * @generated from field: repeated qdrant.Vector positive_vectors = 17;
   */
  positiveVectors: Vector[];

  /**
   * Try to avoid vectors like this
   *
   * @generated from field: repeated qdrant.Vector negative_vectors = 18;
   */
  negativeVectors: Vector[];

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 19;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 20;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.RecommendPoints.
 * Use `create(RecommendPointsSchema)` to create a new message.
 */
export const RecommendPointsSchema: GenMessage<RecommendPoints> = /*@__PURE__*/
  messageDesc(file_points, 45);

/**
 * @generated from message qdrant.RecommendBatchPoints
 */
export type RecommendBatchPoints = Message<"qdrant.RecommendBatchPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.RecommendPoints recommend_points = 2;
   */
  recommendPoints: RecommendPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.RecommendBatchPoints.
 * Use `create(RecommendBatchPointsSchema)` to create a new message.
 */
export const RecommendBatchPointsSchema: GenMessage<RecommendBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 46);

/**
 * @generated from message qdrant.RecommendPointGroups
 */
export type RecommendPointGroups = Message<"qdrant.RecommendPointGroups"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Look for vectors closest to the vectors from these points
   *
   * @generated from field: repeated qdrant.PointId positive = 2;
   */
  positive: PointId[];

  /**
   * Try to avoid vectors like the vector from these points
   *
   * @generated from field: repeated qdrant.PointId negative = 3;
   */
  negative: PointId[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Max number of groups in result
   *
   * @generated from field: uint32 limit = 5;
   */
  limit: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 7;
   */
  params?: SearchParams;

  /**
   * If provided - cut off results with worse scores
   *
   * @generated from field: optional float score_threshold = 8;
   */
  scoreThreshold?: number;

  /**
   * Define which vector to use for recommendation, if not specified - default vector
   *
   * @generated from field: optional string using = 9;
   */
  using?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Name of the collection to use for points lookup, if not specified - use current collection
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 11;
   */
  lookupFrom?: LookupLocation;

  /**
   * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
   *
   * @generated from field: string group_by = 12;
   */
  groupBy: string;

  /**
   * Maximum amount of points to return per group
   *
   * @generated from field: uint32 group_size = 13;
   */
  groupSize: number;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
   */
  readConsistency?: ReadConsistency;

  /**
   * Options for specifying how to use the group id to lookup points in another collection
   *
   * @generated from field: optional qdrant.WithLookup with_lookup = 15;
   */
  withLookup?: WithLookup;

  /**
   * How to use the example vectors to find the results
   *
   * @generated from field: optional qdrant.RecommendStrategy strategy = 17;
   */
  strategy?: RecommendStrategy;

  /**
   * Look for vectors closest to those
   *
   * @generated from field: repeated qdrant.Vector positive_vectors = 18;
   */
  positiveVectors: Vector[];

  /**
   * Try to avoid vectors like this
   *
   * @generated from field: repeated qdrant.Vector negative_vectors = 19;
   */
  negativeVectors: Vector[];

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 20;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 21;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.RecommendPointGroups.
 * Use `create(RecommendPointGroupsSchema)` to create a new message.
 */
export const RecommendPointGroupsSchema: GenMessage<RecommendPointGroups> = /*@__PURE__*/
  messageDesc(file_points, 47);

/**
 * @generated from message qdrant.TargetVector
 */
export type TargetVector = Message<"qdrant.TargetVector"> & {
  /**
   * @generated from oneof qdrant.TargetVector.target
   */
  target: {
    /**
     * @generated from field: qdrant.VectorExample single = 1;
     */
    value: VectorExample;
    case: "single";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.TargetVector.
 * Use `create(TargetVectorSchema)` to create a new message.
 */
export const TargetVectorSchema: GenMessage<TargetVector> = /*@__PURE__*/
  messageDesc(file_points, 48);

/**
 * @generated from message qdrant.VectorExample
 */
export type VectorExample = Message<"qdrant.VectorExample"> & {
  /**
   * @generated from oneof qdrant.VectorExample.example
   */
  example: {
    /**
     * @generated from field: qdrant.PointId id = 1;
     */
    value: PointId;
    case: "id";
  } | {
    /**
     * @generated from field: qdrant.Vector vector = 2;
     */
    value: Vector;
    case: "vector";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorExample.
 * Use `create(VectorExampleSchema)` to create a new message.
 */
export const VectorExampleSchema: GenMessage<VectorExample> = /*@__PURE__*/
  messageDesc(file_points, 49);

/**
 * @generated from message qdrant.ContextExamplePair
 */
export type ContextExamplePair = Message<"qdrant.ContextExamplePair"> & {
  /**
   * @generated from field: qdrant.VectorExample positive = 1;
   */
  positive?: VectorExample;

  /**
   * @generated from field: qdrant.VectorExample negative = 2;
   */
  negative?: VectorExample;
};

/**
 * Describes the message qdrant.ContextExamplePair.
 * Use `create(ContextExamplePairSchema)` to create a new message.
 */
export const ContextExamplePairSchema: GenMessage<ContextExamplePair> = /*@__PURE__*/
  messageDesc(file_points, 50);

/**
 * @generated from message qdrant.DiscoverPoints
 */
export type DiscoverPoints = Message<"qdrant.DiscoverPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Use this as the primary search objective
   *
   * @generated from field: qdrant.TargetVector target = 2;
   */
  target?: TargetVector;

  /**
   * Search will be constrained by these pairs of examples
   *
   * @generated from field: repeated qdrant.ContextExamplePair context = 3;
   */
  context: ContextExamplePair[];

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Max number of result
   *
   * @generated from field: uint64 limit = 5;
   */
  limit: bigint;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 6;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Search config
   *
   * @generated from field: qdrant.SearchParams params = 7;
   */
  params?: SearchParams;

  /**
   * Offset of the result
   *
   * @generated from field: optional uint64 offset = 8;
   */
  offset?: bigint;

  /**
   * Define which vector to use for recommendation, if not specified - default vector
   *
   * @generated from field: optional string using = 9;
   */
  using?: string;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Name of the collection to use for points lookup, if not specified - use current collection
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 11;
   */
  lookupFrom?: LookupLocation;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 13;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 14;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.DiscoverPoints.
 * Use `create(DiscoverPointsSchema)` to create a new message.
 */
export const DiscoverPointsSchema: GenMessage<DiscoverPoints> = /*@__PURE__*/
  messageDesc(file_points, 51);

/**
 * @generated from message qdrant.DiscoverBatchPoints
 */
export type DiscoverBatchPoints = Message<"qdrant.DiscoverBatchPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.DiscoverPoints discover_points = 2;
   */
  discoverPoints: DiscoverPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.DiscoverBatchPoints.
 * Use `create(DiscoverBatchPointsSchema)` to create a new message.
 */
export const DiscoverBatchPointsSchema: GenMessage<DiscoverBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 52);

/**
 * @generated from message qdrant.CountPoints
 */
export type CountPoints = Message<"qdrant.CountPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions
   *
   * @generated from field: qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * If `true` - return exact count, if `false` - return approximate count
   *
   * @generated from field: optional bool exact = 3;
   */
  exact?: boolean;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 4;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 5;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 6;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.CountPoints.
 * Use `create(CountPointsSchema)` to create a new message.
 */
export const CountPointsSchema: GenMessage<CountPoints> = /*@__PURE__*/
  messageDesc(file_points, 53);

/**
 * @generated from message qdrant.RecommendInput
 */
export type RecommendInput = Message<"qdrant.RecommendInput"> & {
  /**
   * Look for vectors closest to the vectors from these points
   *
   * @generated from field: repeated qdrant.VectorInput positive = 1;
   */
  positive: VectorInput[];

  /**
   * Try to avoid vectors like the vector from these points
   *
   * @generated from field: repeated qdrant.VectorInput negative = 2;
   */
  negative: VectorInput[];

  /**
   * How to use the provided vectors to find the results
   *
   * @generated from field: optional qdrant.RecommendStrategy strategy = 3;
   */
  strategy?: RecommendStrategy;
};

/**
 * Describes the message qdrant.RecommendInput.
 * Use `create(RecommendInputSchema)` to create a new message.
 */
export const RecommendInputSchema: GenMessage<RecommendInput> = /*@__PURE__*/
  messageDesc(file_points, 54);

/**
 * @generated from message qdrant.ContextInputPair
 */
export type ContextInputPair = Message<"qdrant.ContextInputPair"> & {
  /**
   * A positive vector
   *
   * @generated from field: qdrant.VectorInput positive = 1;
   */
  positive?: VectorInput;

  /**
   * Repel from this vector
   *
   * @generated from field: qdrant.VectorInput negative = 2;
   */
  negative?: VectorInput;
};

/**
 * Describes the message qdrant.ContextInputPair.
 * Use `create(ContextInputPairSchema)` to create a new message.
 */
export const ContextInputPairSchema: GenMessage<ContextInputPair> = /*@__PURE__*/
  messageDesc(file_points, 55);

/**
 * @generated from message qdrant.DiscoverInput
 */
export type DiscoverInput = Message<"qdrant.DiscoverInput"> & {
  /**
   * Use this as the primary search objective
   *
   * @generated from field: qdrant.VectorInput target = 1;
   */
  target?: VectorInput;

  /**
   * Search space will be constrained by these pairs of vectors
   *
   * @generated from field: qdrant.ContextInput context = 2;
   */
  context?: ContextInput;
};

/**
 * Describes the message qdrant.DiscoverInput.
 * Use `create(DiscoverInputSchema)` to create a new message.
 */
export const DiscoverInputSchema: GenMessage<DiscoverInput> = /*@__PURE__*/
  messageDesc(file_points, 56);

/**
 * @generated from message qdrant.ContextInput
 */
export type ContextInput = Message<"qdrant.ContextInput"> & {
  /**
   * Search space will be constrained by these pairs of vectors
   *
   * @generated from field: repeated qdrant.ContextInputPair pairs = 1;
   */
  pairs: ContextInputPair[];
};

/**
 * Describes the message qdrant.ContextInput.
 * Use `create(ContextInputSchema)` to create a new message.
 */
export const ContextInputSchema: GenMessage<ContextInput> = /*@__PURE__*/
  messageDesc(file_points, 57);

/**
 * @generated from message qdrant.Formula
 */
export type Formula = Message<"qdrant.Formula"> & {
  /**
   * @generated from field: qdrant.Expression expression = 1;
   */
  expression?: Expression;

  /**
   * @generated from field: map<string, qdrant.Value> defaults = 2;
   */
  defaults: { [key: string]: Value };
};

/**
 * Describes the message qdrant.Formula.
 * Use `create(FormulaSchema)` to create a new message.
 */
export const FormulaSchema: GenMessage<Formula> = /*@__PURE__*/
  messageDesc(file_points, 58);

/**
 * @generated from message qdrant.Expression
 */
export type Expression = Message<"qdrant.Expression"> & {
  /**
   * @generated from oneof qdrant.Expression.variant
   */
  variant: {
    /**
     * @generated from field: float constant = 1;
     */
    value: number;
    case: "constant";
  } | {
    /**
     * Payload key or reference to score.
     *
     * @generated from field: string variable = 2;
     */
    value: string;
    case: "variable";
  } | {
    /**
     * Payload condition. If true, becomes 1.0; otherwise 0.0
     *
     * @generated from field: qdrant.Condition condition = 3;
     */
    value: Condition;
    case: "condition";
  } | {
    /**
     * Geographic distance in meters
     *
     * @generated from field: qdrant.GeoDistance geo_distance = 4;
     */
    value: GeoDistance;
    case: "geoDistance";
  } | {
    /**
     * Date-time constant
     *
     * @generated from field: string datetime = 5;
     */
    value: string;
    case: "datetime";
  } | {
    /**
     * Payload key with date-time values
     *
     * @generated from field: string datetime_key = 6;
     */
    value: string;
    case: "datetimeKey";
  } | {
    /**
     * Multiply
     *
     * @generated from field: qdrant.MultExpression mult = 7;
     */
    value: MultExpression;
    case: "mult";
  } | {
    /**
     * Sum
     *
     * @generated from field: qdrant.SumExpression sum = 8;
     */
    value: SumExpression;
    case: "sum";
  } | {
    /**
     * Divide
     *
     * @generated from field: qdrant.DivExpression div = 9;
     */
    value: DivExpression;
    case: "div";
  } | {
    /**
     * Negate
     *
     * @generated from field: qdrant.Expression neg = 10;
     */
    value: Expression;
    case: "neg";
  } | {
    /**
     * Absolute value
     *
     * @generated from field: qdrant.Expression abs = 11;
     */
    value: Expression;
    case: "abs";
  } | {
    /**
     * Square root
     *
     * @generated from field: qdrant.Expression sqrt = 12;
     */
    value: Expression;
    case: "sqrt";
  } | {
    /**
     * Power
     *
     * @generated from field: qdrant.PowExpression pow = 13;
     */
    value: PowExpression;
    case: "pow";
  } | {
    /**
     * Exponential
     *
     * @generated from field: qdrant.Expression exp = 14;
     */
    value: Expression;
    case: "exp";
  } | {
    /**
     * Logarithm
     *
     * @generated from field: qdrant.Expression log10 = 15;
     */
    value: Expression;
    case: "log10";
  } | {
    /**
     * Natural logarithm
     *
     * @generated from field: qdrant.Expression ln = 16;
     */
    value: Expression;
    case: "ln";
  } | {
    /**
     * Exponential decay
     *
     * @generated from field: qdrant.DecayParamsExpression exp_decay = 17;
     */
    value: DecayParamsExpression;
    case: "expDecay";
  } | {
    /**
     * Gaussian decay
     *
     * @generated from field: qdrant.DecayParamsExpression gauss_decay = 18;
     */
    value: DecayParamsExpression;
    case: "gaussDecay";
  } | {
    /**
     * Linear decay
     *
     * @generated from field: qdrant.DecayParamsExpression lin_decay = 19;
     */
    value: DecayParamsExpression;
    case: "linDecay";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Expression.
 * Use `create(ExpressionSchema)` to create a new message.
 */
export const ExpressionSchema: GenMessage<Expression> = /*@__PURE__*/
  messageDesc(file_points, 59);

/**
 * @generated from message qdrant.GeoDistance
 */
export type GeoDistance = Message<"qdrant.GeoDistance"> & {
  /**
   * @generated from field: qdrant.GeoPoint origin = 1;
   */
  origin?: GeoPoint;

  /**
   * @generated from field: string to = 2;
   */
  to: string;
};

/**
 * Describes the message qdrant.GeoDistance.
 * Use `create(GeoDistanceSchema)` to create a new message.
 */
export const GeoDistanceSchema: GenMessage<GeoDistance> = /*@__PURE__*/
  messageDesc(file_points, 60);

/**
 * @generated from message qdrant.MultExpression
 */
export type MultExpression = Message<"qdrant.MultExpression"> & {
  /**
   * @generated from field: repeated qdrant.Expression mult = 1;
   */
  mult: Expression[];
};

/**
 * Describes the message qdrant.MultExpression.
 * Use `create(MultExpressionSchema)` to create a new message.
 */
export const MultExpressionSchema: GenMessage<MultExpression> = /*@__PURE__*/
  messageDesc(file_points, 61);

/**
 * @generated from message qdrant.SumExpression
 */
export type SumExpression = Message<"qdrant.SumExpression"> & {
  /**
   * @generated from field: repeated qdrant.Expression sum = 1;
   */
  sum: Expression[];
};

/**
 * Describes the message qdrant.SumExpression.
 * Use `create(SumExpressionSchema)` to create a new message.
 */
export const SumExpressionSchema: GenMessage<SumExpression> = /*@__PURE__*/
  messageDesc(file_points, 62);

/**
 * @generated from message qdrant.DivExpression
 */
export type DivExpression = Message<"qdrant.DivExpression"> & {
  /**
   * @generated from field: qdrant.Expression left = 1;
   */
  left?: Expression;

  /**
   * @generated from field: qdrant.Expression right = 2;
   */
  right?: Expression;

  /**
   * @generated from field: optional float by_zero_default = 3;
   */
  byZeroDefault?: number;
};

/**
 * Describes the message qdrant.DivExpression.
 * Use `create(DivExpressionSchema)` to create a new message.
 */
export const DivExpressionSchema: GenMessage<DivExpression> = /*@__PURE__*/
  messageDesc(file_points, 63);

/**
 * @generated from message qdrant.PowExpression
 */
export type PowExpression = Message<"qdrant.PowExpression"> & {
  /**
   * @generated from field: qdrant.Expression base = 1;
   */
  base?: Expression;

  /**
   * @generated from field: qdrant.Expression exponent = 2;
   */
  exponent?: Expression;
};

/**
 * Describes the message qdrant.PowExpression.
 * Use `create(PowExpressionSchema)` to create a new message.
 */
export const PowExpressionSchema: GenMessage<PowExpression> = /*@__PURE__*/
  messageDesc(file_points, 64);

/**
 * @generated from message qdrant.DecayParamsExpression
 */
export type DecayParamsExpression = Message<"qdrant.DecayParamsExpression"> & {
  /**
   * The variable to decay
   *
   * @generated from field: qdrant.Expression x = 1;
   */
  x?: Expression;

  /**
   * The target value to start decaying from. Defaults to 0.
   *
   * @generated from field: optional qdrant.Expression target = 2;
   */
  target?: Expression;

  /**
   * The scale factor of the decay, in terms of `x`. Defaults to 1.0. Must be a non-zero positive number.
   *
   * @generated from field: optional float scale = 3;
   */
  scale?: number;

  /**
   * The midpoint of the decay. Should be between 0 and 1. Defaults to 0.5. Output will be this value when `|x - target| == scale`.
   *
   * @generated from field: optional float midpoint = 4;
   */
  midpoint?: number;
};

/**
 * Describes the message qdrant.DecayParamsExpression.
 * Use `create(DecayParamsExpressionSchema)` to create a new message.
 */
export const DecayParamsExpressionSchema: GenMessage<DecayParamsExpression> = /*@__PURE__*/
  messageDesc(file_points, 65);

/**
 * @generated from message qdrant.NearestInputWithMmr
 */
export type NearestInputWithMmr = Message<"qdrant.NearestInputWithMmr"> & {
  /**
   * The vector to search for nearest neighbors.
   *
   * @generated from field: qdrant.VectorInput nearest = 1;
   */
  nearest?: VectorInput;

  /**
   * Perform MMR (Maximal Marginal Relevance) reranking after search,
   * using the same vector in this query to calculate relevance.
   *
   * @generated from field: qdrant.Mmr mmr = 2;
   */
  mmr?: Mmr;
};

/**
 * Describes the message qdrant.NearestInputWithMmr.
 * Use `create(NearestInputWithMmrSchema)` to create a new message.
 */
export const NearestInputWithMmrSchema: GenMessage<NearestInputWithMmr> = /*@__PURE__*/
  messageDesc(file_points, 66);

/**
 * Maximal Marginal Relevance (MMR) algorithm for re-ranking the points.
 *
 * @generated from message qdrant.Mmr
 */
export type Mmr = Message<"qdrant.Mmr"> & {
  /**
   * Tunable parameter for the MMR algorithm.
   * Determines the balance between diversity and relevance.
   *
   * A higher value favors diversity (dissimilarity to selected results),
   * while a lower value favors relevance (similarity to the query vector).
   *
   * Must be in the range [0, 1].
   * Default value is 0.5.
   *
   * @generated from field: optional float diversity = 2;
   */
  diversity?: number;

  /**
   * The maximum number of candidates to consider for re-ranking.
   *
   * If not specified, the `limit` value is used.
   *
   * @generated from field: optional uint32 candidates_limit = 3;
   */
  candidatesLimit?: number;
};

/**
 * Describes the message qdrant.Mmr.
 * Use `create(MmrSchema)` to create a new message.
 */
export const MmrSchema: GenMessage<Mmr> = /*@__PURE__*/
  messageDesc(file_points, 67);

/**
 * Parameterized reciprocal rank fusion
 *
 * @generated from message qdrant.Rrf
 */
export type Rrf = Message<"qdrant.Rrf"> & {
  /**
   * K parameter for reciprocal rank fusion
   *
   * @generated from field: optional uint32 k = 1;
   */
  k?: number;
};

/**
 * Describes the message qdrant.Rrf.
 * Use `create(RrfSchema)` to create a new message.
 */
export const RrfSchema: GenMessage<Rrf> = /*@__PURE__*/
  messageDesc(file_points, 68);

/**
 * @generated from message qdrant.Query
 */
export type Query = Message<"qdrant.Query"> & {
  /**
   * @generated from oneof qdrant.Query.variant
   */
  variant: {
    /**
     * Find the nearest neighbors to this vector.
     *
     * @generated from field: qdrant.VectorInput nearest = 1;
     */
    value: VectorInput;
    case: "nearest";
  } | {
    /**
     * Use multiple positive and negative vectors to find the results.
     *
     * @generated from field: qdrant.RecommendInput recommend = 2;
     */
    value: RecommendInput;
    case: "recommend";
  } | {
    /**
     * Search for nearest points, but constrain the search space with context
     *
     * @generated from field: qdrant.DiscoverInput discover = 3;
     */
    value: DiscoverInput;
    case: "discover";
  } | {
    /**
     * Return points that live in positive areas.
     *
     * @generated from field: qdrant.ContextInput context = 4;
     */
    value: ContextInput;
    case: "context";
  } | {
    /**
     * Order the points by a payload field.
     *
     * @generated from field: qdrant.OrderBy order_by = 5;
     */
    value: OrderBy;
    case: "orderBy";
  } | {
    /**
     * Fuse the results of multiple prefetches.
     *
     * @generated from field: qdrant.Fusion fusion = 6;
     */
    value: Fusion;
    case: "fusion";
  } | {
    /**
     * Sample points from the collection.
     *
     * @generated from field: qdrant.Sample sample = 7;
     */
    value: Sample;
    case: "sample";
  } | {
    /**
     * Score boosting via an arbitrary formula
     *
     * @generated from field: qdrant.Formula formula = 8;
     */
    value: Formula;
    case: "formula";
  } | {
    /**
     * Search nearest neighbors, but re-rank based on the Maximal Marginal Relevance algorithm.
     *
     * @generated from field: qdrant.NearestInputWithMmr nearest_with_mmr = 9;
     */
    value: NearestInputWithMmr;
    case: "nearestWithMmr";
  } | {
    /**
     * Parameterized reciprocal rank fusion
     *
     * @generated from field: qdrant.Rrf rrf = 10;
     */
    value: Rrf;
    case: "rrf";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Query.
 * Use `create(QuerySchema)` to create a new message.
 */
export const QuerySchema: GenMessage<Query> = /*@__PURE__*/
  messageDesc(file_points, 69);

/**
 * @generated from message qdrant.PrefetchQuery
 */
export type PrefetchQuery = Message<"qdrant.PrefetchQuery"> & {
  /**
   * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
   *
   * @generated from field: repeated qdrant.PrefetchQuery prefetch = 1;
   */
  prefetch: PrefetchQuery[];

  /**
   * Query to perform. If missing, returns points ordered by their IDs.
   *
   * @generated from field: optional qdrant.Query query = 2;
   */
  query?: Query;

  /**
   * Define which vector to use for querying. If missing, the default vector is is used.
   *
   * @generated from field: optional string using = 3;
   */
  using?: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 4;
   */
  filter?: Filter;

  /**
   * Search params for when there is no prefetch.
   *
   * @generated from field: optional qdrant.SearchParams params = 5;
   */
  params?: SearchParams;

  /**
   * Return points with scores better than this threshold.
   *
   * @generated from field: optional float score_threshold = 6;
   */
  scoreThreshold?: number;

  /**
   * Max number of points. Default is 10
   *
   * @generated from field: optional uint64 limit = 7;
   */
  limit?: bigint;

  /**
   * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 8;
   */
  lookupFrom?: LookupLocation;
};

/**
 * Describes the message qdrant.PrefetchQuery.
 * Use `create(PrefetchQuerySchema)` to create a new message.
 */
export const PrefetchQuerySchema: GenMessage<PrefetchQuery> = /*@__PURE__*/
  messageDesc(file_points, 70);

/**
 * @generated from message qdrant.QueryPoints
 */
export type QueryPoints = Message<"qdrant.QueryPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
   *
   * @generated from field: repeated qdrant.PrefetchQuery prefetch = 2;
   */
  prefetch: PrefetchQuery[];

  /**
   * Query to perform. If missing, returns points ordered by their IDs.
   *
   * @generated from field: optional qdrant.Query query = 3;
   */
  query?: Query;

  /**
   * Define which vector to use for querying. If missing, the default vector is used.
   *
   * @generated from field: optional string using = 4;
   */
  using?: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 5;
   */
  filter?: Filter;

  /**
   * Search params for when there is no prefetch.
   *
   * @generated from field: optional qdrant.SearchParams params = 6;
   */
  params?: SearchParams;

  /**
   * Return points with scores better than this threshold.
   *
   * @generated from field: optional float score_threshold = 7;
   */
  scoreThreshold?: number;

  /**
   * Max number of points. Default is 10.
   *
   * @generated from field: optional uint64 limit = 8;
   */
  limit?: bigint;

  /**
   * Offset of the result. Skip this many points. Default is 0.
   *
   * @generated from field: optional uint64 offset = 9;
   */
  offset?: bigint;

  /**
   * Options for specifying which vectors to include into the response.
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 10;
   */
  withVectors?: WithVectorsSelector;

  /**
   * Options for specifying which payload to include or not.
   *
   * @generated from field: optional qdrant.WithPayloadSelector with_payload = 11;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying read consistency guarantees.
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 12;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards.
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 13;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 14;
   */
  lookupFrom?: LookupLocation;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 15;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.QueryPoints.
 * Use `create(QueryPointsSchema)` to create a new message.
 */
export const QueryPointsSchema: GenMessage<QueryPoints> = /*@__PURE__*/
  messageDesc(file_points, 71);

/**
 * @generated from message qdrant.QueryBatchPoints
 */
export type QueryBatchPoints = Message<"qdrant.QueryBatchPoints"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from field: repeated qdrant.QueryPoints query_points = 2;
   */
  queryPoints: QueryPoints[];

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 3;
   */
  readConsistency?: ReadConsistency;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 4;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.QueryBatchPoints.
 * Use `create(QueryBatchPointsSchema)` to create a new message.
 */
export const QueryBatchPointsSchema: GenMessage<QueryBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 72);

/**
 * @generated from message qdrant.QueryPointGroups
 */
export type QueryPointGroups = Message<"qdrant.QueryPointGroups"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Sub-requests to perform first. If present, the query will be performed on the results of the prefetches.
   *
   * @generated from field: repeated qdrant.PrefetchQuery prefetch = 2;
   */
  prefetch: PrefetchQuery[];

  /**
   * Query to perform. If missing, returns points ordered by their IDs.
   *
   * @generated from field: optional qdrant.Query query = 3;
   */
  query?: Query;

  /**
   * Define which vector to use for querying. If missing, the default vector is used.
   *
   * @generated from field: optional string using = 4;
   */
  using?: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 5;
   */
  filter?: Filter;

  /**
   * Search params for when there is no prefetch.
   *
   * @generated from field: optional qdrant.SearchParams params = 6;
   */
  params?: SearchParams;

  /**
   * Return points with scores better than this threshold.
   *
   * @generated from field: optional float score_threshold = 7;
   */
  scoreThreshold?: number;

  /**
   * Options for specifying which payload to include or not
   *
   * @generated from field: qdrant.WithPayloadSelector with_payload = 8;
   */
  withPayload?: WithPayloadSelector;

  /**
   * Options for specifying which vectors to include into response
   *
   * @generated from field: optional qdrant.WithVectorsSelector with_vectors = 9;
   */
  withVectors?: WithVectorsSelector;

  /**
   * The location to use for IDs lookup, if not specified - use the current collection and the 'using' vector
   *
   * @generated from field: optional qdrant.LookupLocation lookup_from = 10;
   */
  lookupFrom?: LookupLocation;

  /**
   * Max number of points. Default is 3.
   *
   * @generated from field: optional uint64 limit = 11;
   */
  limit?: bigint;

  /**
   * Maximum amount of points to return per group. Default to 10.
   *
   * @generated from field: optional uint64 group_size = 12;
   */
  groupSize?: bigint;

  /**
   * Payload field to group by, must be a string or number field. If there are multiple values for the field, all of them will be used. One point can be in multiple groups.
   *
   * @generated from field: string group_by = 13;
   */
  groupBy: string;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 14;
   */
  readConsistency?: ReadConsistency;

  /**
   * Options for specifying how to use the group id to lookup points in another collection
   *
   * @generated from field: optional qdrant.WithLookup with_lookup = 15;
   */
  withLookup?: WithLookup;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 16;
   */
  timeout?: bigint;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 17;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.QueryPointGroups.
 * Use `create(QueryPointGroupsSchema)` to create a new message.
 */
export const QueryPointGroupsSchema: GenMessage<QueryPointGroups> = /*@__PURE__*/
  messageDesc(file_points, 73);

/**
 * @generated from message qdrant.FacetCounts
 */
export type FacetCounts = Message<"qdrant.FacetCounts"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Payload key of the facet
   *
   * @generated from field: string key = 2;
   */
  key: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 3;
   */
  filter?: Filter;

  /**
   * Max number of facets. Default is 10.
   *
   * @generated from field: optional uint64 limit = 4;
   */
  limit?: bigint;

  /**
   * If true, return exact counts, slower but useful for debugging purposes. Default is false.
   *
   * @generated from field: optional bool exact = 5;
   */
  exact?: boolean;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 6;
   */
  timeout?: bigint;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 7;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 8;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.FacetCounts.
 * Use `create(FacetCountsSchema)` to create a new message.
 */
export const FacetCountsSchema: GenMessage<FacetCounts> = /*@__PURE__*/
  messageDesc(file_points, 74);

/**
 * @generated from message qdrant.FacetValue
 */
export type FacetValue = Message<"qdrant.FacetValue"> & {
  /**
   * @generated from oneof qdrant.FacetValue.variant
   */
  variant: {
    /**
     * String value from the facet
     *
     * @generated from field: string string_value = 1;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * Integer value from the facet
     *
     * @generated from field: int64 integer_value = 2;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * Boolean value from the facet
     *
     * @generated from field: bool bool_value = 3;
     */
    value: boolean;
    case: "boolValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.FacetValue.
 * Use `create(FacetValueSchema)` to create a new message.
 */
export const FacetValueSchema: GenMessage<FacetValue> = /*@__PURE__*/
  messageDesc(file_points, 75);

/**
 * @generated from message qdrant.FacetHit
 */
export type FacetHit = Message<"qdrant.FacetHit"> & {
  /**
   * Value from the facet
   *
   * @generated from field: qdrant.FacetValue value = 1;
   */
  value?: FacetValue;

  /**
   * Number of points with this value
   *
   * @generated from field: uint64 count = 2;
   */
  count: bigint;
};

/**
 * Describes the message qdrant.FacetHit.
 * Use `create(FacetHitSchema)` to create a new message.
 */
export const FacetHitSchema: GenMessage<FacetHit> = /*@__PURE__*/
  messageDesc(file_points, 76);

/**
 * @generated from message qdrant.SearchMatrixPoints
 */
export type SearchMatrixPoints = Message<"qdrant.SearchMatrixPoints"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Filter conditions - return only those points that satisfy the specified conditions.
   *
   * @generated from field: optional qdrant.Filter filter = 2;
   */
  filter?: Filter;

  /**
   * How many points to select and search within. Default is 10.
   *
   * @generated from field: optional uint64 sample = 3;
   */
  sample?: bigint;

  /**
   * How many neighbours per sample to find. Default is 3.
   *
   * @generated from field: optional uint64 limit = 4;
   */
  limit?: bigint;

  /**
   * Define which vector to use for querying. If missing, the default vector is is used.
   *
   * @generated from field: optional string using = 5;
   */
  using?: string;

  /**
   * If set, overrides global timeout setting for this request. Unit is seconds.
   *
   * @generated from field: optional uint64 timeout = 6;
   */
  timeout?: bigint;

  /**
   * Options for specifying read consistency guarantees
   *
   * @generated from field: optional qdrant.ReadConsistency read_consistency = 7;
   */
  readConsistency?: ReadConsistency;

  /**
   * Specify in which shards to look for the points, if not specified - look in all shards
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 8;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.SearchMatrixPoints.
 * Use `create(SearchMatrixPointsSchema)` to create a new message.
 */
export const SearchMatrixPointsSchema: GenMessage<SearchMatrixPoints> = /*@__PURE__*/
  messageDesc(file_points, 77);

/**
 * @generated from message qdrant.SearchMatrixPairs
 */
export type SearchMatrixPairs = Message<"qdrant.SearchMatrixPairs"> & {
  /**
   * List of pairs of points with scores
   *
   * @generated from field: repeated qdrant.SearchMatrixPair pairs = 1;
   */
  pairs: SearchMatrixPair[];
};

/**
 * Describes the message qdrant.SearchMatrixPairs.
 * Use `create(SearchMatrixPairsSchema)` to create a new message.
 */
export const SearchMatrixPairsSchema: GenMessage<SearchMatrixPairs> = /*@__PURE__*/
  messageDesc(file_points, 78);

/**
 * @generated from message qdrant.SearchMatrixPair
 */
export type SearchMatrixPair = Message<"qdrant.SearchMatrixPair"> & {
  /**
   * first id of the pair
   *
   * @generated from field: qdrant.PointId a = 1;
   */
  a?: PointId;

  /**
   * second id of the pair
   *
   * @generated from field: qdrant.PointId b = 2;
   */
  b?: PointId;

  /**
   * score of the pair
   *
   * @generated from field: float score = 3;
   */
  score: number;
};

/**
 * Describes the message qdrant.SearchMatrixPair.
 * Use `create(SearchMatrixPairSchema)` to create a new message.
 */
export const SearchMatrixPairSchema: GenMessage<SearchMatrixPair> = /*@__PURE__*/
  messageDesc(file_points, 79);

/**
 * @generated from message qdrant.SearchMatrixOffsets
 */
export type SearchMatrixOffsets = Message<"qdrant.SearchMatrixOffsets"> & {
  /**
   * Row indices of the matrix
   *
   * @generated from field: repeated uint64 offsets_row = 1;
   */
  offsetsRow: bigint[];

  /**
   * Column indices of the matrix
   *
   * @generated from field: repeated uint64 offsets_col = 2;
   */
  offsetsCol: bigint[];

  /**
   * Scores associated with matrix coordinates
   *
   * @generated from field: repeated float scores = 3;
   */
  scores: number[];

  /**
   * Ids of the points in order
   *
   * @generated from field: repeated qdrant.PointId ids = 4;
   */
  ids: PointId[];
};

/**
 * Describes the message qdrant.SearchMatrixOffsets.
 * Use `create(SearchMatrixOffsetsSchema)` to create a new message.
 */
export const SearchMatrixOffsetsSchema: GenMessage<SearchMatrixOffsets> = /*@__PURE__*/
  messageDesc(file_points, 80);

/**
 * @generated from message qdrant.PointsUpdateOperation
 */
export type PointsUpdateOperation = Message<"qdrant.PointsUpdateOperation"> & {
  /**
   * @generated from oneof qdrant.PointsUpdateOperation.operation
   */
  operation: {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.PointStructList upsert = 1;
     */
    value: PointsUpdateOperation_PointStructList;
    case: "upsert";
  } | {
    /**
     * @generated from field: qdrant.PointsSelector delete_deprecated = 2 [deprecated = true];
     * @deprecated
     */
    value: PointsSelector;
    case: "deleteDeprecated";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.SetPayload set_payload = 3;
     */
    value: PointsUpdateOperation_SetPayload;
    case: "setPayload";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.OverwritePayload overwrite_payload = 4;
     */
    value: PointsUpdateOperation_OverwritePayload;
    case: "overwritePayload";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.DeletePayload delete_payload = 5;
     */
    value: PointsUpdateOperation_DeletePayload;
    case: "deletePayload";
  } | {
    /**
     * @generated from field: qdrant.PointsSelector clear_payload_deprecated = 6 [deprecated = true];
     * @deprecated
     */
    value: PointsSelector;
    case: "clearPayloadDeprecated";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.UpdateVectors update_vectors = 7;
     */
    value: PointsUpdateOperation_UpdateVectors;
    case: "updateVectors";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.DeleteVectors delete_vectors = 8;
     */
    value: PointsUpdateOperation_DeleteVectors;
    case: "deleteVectors";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.DeletePoints delete_points = 9;
     */
    value: PointsUpdateOperation_DeletePoints;
    case: "deletePoints";
  } | {
    /**
     * @generated from field: qdrant.PointsUpdateOperation.ClearPayload clear_payload = 10;
     */
    value: PointsUpdateOperation_ClearPayload;
    case: "clearPayload";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.PointsUpdateOperation.
 * Use `create(PointsUpdateOperationSchema)` to create a new message.
 */
export const PointsUpdateOperationSchema: GenMessage<PointsUpdateOperation> = /*@__PURE__*/
  messageDesc(file_points, 81);

/**
 * @generated from message qdrant.PointsUpdateOperation.PointStructList
 */
export type PointsUpdateOperation_PointStructList = Message<"qdrant.PointsUpdateOperation.PointStructList"> & {
  /**
   * @generated from field: repeated qdrant.PointStruct points = 1;
   */
  points: PointStruct[];

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated, others will be inserted
   *
   * @generated from field: optional qdrant.Filter update_filter = 3;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.PointStructList.
 * Use `create(PointsUpdateOperation_PointStructListSchema)` to create a new message.
 */
export const PointsUpdateOperation_PointStructListSchema: GenMessage<PointsUpdateOperation_PointStructList> = /*@__PURE__*/
  messageDesc(file_points, 81, 0);

/**
 * @generated from message qdrant.PointsUpdateOperation.SetPayload
 */
export type PointsUpdateOperation_SetPayload = Message<"qdrant.PointsUpdateOperation.SetPayload"> & {
  /**
   * @generated from field: map<string, qdrant.Value> payload = 1;
   */
  payload: { [key: string]: Value };

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 2;
   */
  pointsSelector?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Option for indicate property of payload
   *
   * @generated from field: optional string key = 4;
   */
  key?: string;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.SetPayload.
 * Use `create(PointsUpdateOperation_SetPayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_SetPayloadSchema: GenMessage<PointsUpdateOperation_SetPayload> = /*@__PURE__*/
  messageDesc(file_points, 81, 1);

/**
 * @generated from message qdrant.PointsUpdateOperation.OverwritePayload
 */
export type PointsUpdateOperation_OverwritePayload = Message<"qdrant.PointsUpdateOperation.OverwritePayload"> & {
  /**
   * @generated from field: map<string, qdrant.Value> payload = 1;
   */
  payload: { [key: string]: Value };

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 2;
   */
  pointsSelector?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * Option for indicate property of payload
   *
   * @generated from field: optional string key = 4;
   */
  key?: string;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.OverwritePayload.
 * Use `create(PointsUpdateOperation_OverwritePayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_OverwritePayloadSchema: GenMessage<PointsUpdateOperation_OverwritePayload> = /*@__PURE__*/
  messageDesc(file_points, 81, 2);

/**
 * @generated from message qdrant.PointsUpdateOperation.DeletePayload
 */
export type PointsUpdateOperation_DeletePayload = Message<"qdrant.PointsUpdateOperation.DeletePayload"> & {
  /**
   * @generated from field: repeated string keys = 1;
   */
  keys: string[];

  /**
   * Affected points
   *
   * @generated from field: optional qdrant.PointsSelector points_selector = 2;
   */
  pointsSelector?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.DeletePayload.
 * Use `create(PointsUpdateOperation_DeletePayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_DeletePayloadSchema: GenMessage<PointsUpdateOperation_DeletePayload> = /*@__PURE__*/
  messageDesc(file_points, 81, 3);

/**
 * @generated from message qdrant.PointsUpdateOperation.UpdateVectors
 */
export type PointsUpdateOperation_UpdateVectors = Message<"qdrant.PointsUpdateOperation.UpdateVectors"> & {
  /**
   * List of points and vectors to update
   *
   * @generated from field: repeated qdrant.PointVectors points = 1;
   */
  points: PointVectors[];

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;

  /**
   * If specified, only points that match this filter will be updated
   *
   * @generated from field: optional qdrant.Filter update_filter = 3;
   */
  updateFilter?: Filter;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.UpdateVectors.
 * Use `create(PointsUpdateOperation_UpdateVectorsSchema)` to create a new message.
 */
export const PointsUpdateOperation_UpdateVectorsSchema: GenMessage<PointsUpdateOperation_UpdateVectors> = /*@__PURE__*/
  messageDesc(file_points, 81, 4);

/**
 * @generated from message qdrant.PointsUpdateOperation.DeleteVectors
 */
export type PointsUpdateOperation_DeleteVectors = Message<"qdrant.PointsUpdateOperation.DeleteVectors"> & {
  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points_selector = 1;
   */
  pointsSelector?: PointsSelector;

  /**
   * List of vector names to delete
   *
   * @generated from field: qdrant.VectorsSelector vectors = 2;
   */
  vectors?: VectorsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 3;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.DeleteVectors.
 * Use `create(PointsUpdateOperation_DeleteVectorsSchema)` to create a new message.
 */
export const PointsUpdateOperation_DeleteVectorsSchema: GenMessage<PointsUpdateOperation_DeleteVectors> = /*@__PURE__*/
  messageDesc(file_points, 81, 5);

/**
 * @generated from message qdrant.PointsUpdateOperation.DeletePoints
 */
export type PointsUpdateOperation_DeletePoints = Message<"qdrant.PointsUpdateOperation.DeletePoints"> & {
  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 1;
   */
  points?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.DeletePoints.
 * Use `create(PointsUpdateOperation_DeletePointsSchema)` to create a new message.
 */
export const PointsUpdateOperation_DeletePointsSchema: GenMessage<PointsUpdateOperation_DeletePoints> = /*@__PURE__*/
  messageDesc(file_points, 81, 6);

/**
 * @generated from message qdrant.PointsUpdateOperation.ClearPayload
 */
export type PointsUpdateOperation_ClearPayload = Message<"qdrant.PointsUpdateOperation.ClearPayload"> & {
  /**
   * Affected points
   *
   * @generated from field: qdrant.PointsSelector points = 1;
   */
  points?: PointsSelector;

  /**
   * Option for custom sharding to specify used shard keys
   *
   * @generated from field: optional qdrant.ShardKeySelector shard_key_selector = 2;
   */
  shardKeySelector?: ShardKeySelector;
};

/**
 * Describes the message qdrant.PointsUpdateOperation.ClearPayload.
 * Use `create(PointsUpdateOperation_ClearPayloadSchema)` to create a new message.
 */
export const PointsUpdateOperation_ClearPayloadSchema: GenMessage<PointsUpdateOperation_ClearPayload> = /*@__PURE__*/
  messageDesc(file_points, 81, 7);

/**
 * @generated from message qdrant.UpdateBatchPoints
 */
export type UpdateBatchPoints = Message<"qdrant.UpdateBatchPoints"> & {
  /**
   * name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait until the changes have been applied?
   *
   * @generated from field: optional bool wait = 2;
   */
  wait?: boolean;

  /**
   * @generated from field: repeated qdrant.PointsUpdateOperation operations = 3;
   */
  operations: PointsUpdateOperation[];

  /**
   * Write ordering guarantees
   *
   * @generated from field: optional qdrant.WriteOrdering ordering = 4;
   */
  ordering?: WriteOrdering;
};

/**
 * Describes the message qdrant.UpdateBatchPoints.
 * Use `create(UpdateBatchPointsSchema)` to create a new message.
 */
export const UpdateBatchPointsSchema: GenMessage<UpdateBatchPoints> = /*@__PURE__*/
  messageDesc(file_points, 82);

/**
 * @generated from message qdrant.PointsOperationResponse
 */
export type PointsOperationResponse = Message<"qdrant.PointsOperationResponse"> & {
  /**
   * @generated from field: qdrant.UpdateResult result = 1;
   */
  result?: UpdateResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.PointsOperationResponse.
 * Use `create(PointsOperationResponseSchema)` to create a new message.
 */
export const PointsOperationResponseSchema: GenMessage<PointsOperationResponse> = /*@__PURE__*/
  messageDesc(file_points, 83);

/**
 * @generated from message qdrant.UpdateResult
 */
export type UpdateResult = Message<"qdrant.UpdateResult"> & {
  /**
   * Number of operation
   *
   * @generated from field: optional uint64 operation_id = 1;
   */
  operationId?: bigint;

  /**
   * Operation status
   *
   * @generated from field: qdrant.UpdateStatus status = 2;
   */
  status: UpdateStatus;
};

/**
 * Describes the message qdrant.UpdateResult.
 * Use `create(UpdateResultSchema)` to create a new message.
 */
export const UpdateResultSchema: GenMessage<UpdateResult> = /*@__PURE__*/
  messageDesc(file_points, 84);

/**
 * @generated from message qdrant.OrderValue
 */
export type OrderValue = Message<"qdrant.OrderValue"> & {
  /**
   * @generated from oneof qdrant.OrderValue.variant
   */
  variant: {
    /**
     * @generated from field: int64 int = 1;
     */
    value: bigint;
    case: "int";
  } | {
    /**
     * @generated from field: double float = 2;
     */
    value: number;
    case: "float";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.OrderValue.
 * Use `create(OrderValueSchema)` to create a new message.
 */
export const OrderValueSchema: GenMessage<OrderValue> = /*@__PURE__*/
  messageDesc(file_points, 85);

/**
 * @generated from message qdrant.ScoredPoint
 */
export type ScoredPoint = Message<"qdrant.ScoredPoint"> & {
  /**
   * Point id
   *
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * Payload
   *
   * @generated from field: map<string, qdrant.Value> payload = 2;
   */
  payload: { [key: string]: Value };

  /**
   * Similarity score
   *
   * @generated from field: float score = 3;
   */
  score: number;

  /**
   * Last update operation applied to this point
   *
   * @generated from field: uint64 version = 5;
   */
  version: bigint;

  /**
   * Vectors to search
   *
   * @generated from field: optional qdrant.VectorsOutput vectors = 6;
   */
  vectors?: VectorsOutput;

  /**
   * Shard key
   *
   * @generated from field: optional qdrant.ShardKey shard_key = 7;
   */
  shardKey?: ShardKey;

  /**
   * Order by value
   *
   * @generated from field: optional qdrant.OrderValue order_value = 8;
   */
  orderValue?: OrderValue;
};

/**
 * Describes the message qdrant.ScoredPoint.
 * Use `create(ScoredPointSchema)` to create a new message.
 */
export const ScoredPointSchema: GenMessage<ScoredPoint> = /*@__PURE__*/
  messageDesc(file_points, 86);

/**
 * @generated from message qdrant.GroupId
 */
export type GroupId = Message<"qdrant.GroupId"> & {
  /**
   * @generated from oneof qdrant.GroupId.kind
   */
  kind: {
    /**
     * Represents a double value.
     *
     * @generated from field: uint64 unsigned_value = 1;
     */
    value: bigint;
    case: "unsignedValue";
  } | {
    /**
     * Represents an integer value
     *
     * @generated from field: int64 integer_value = 2;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * Represents a string value.
     *
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.GroupId.
 * Use `create(GroupIdSchema)` to create a new message.
 */
export const GroupIdSchema: GenMessage<GroupId> = /*@__PURE__*/
  messageDesc(file_points, 87);

/**
 * @generated from message qdrant.PointGroup
 */
export type PointGroup = Message<"qdrant.PointGroup"> & {
  /**
   * Group id
   *
   * @generated from field: qdrant.GroupId id = 1;
   */
  id?: GroupId;

  /**
   * Points in the group
   *
   * @generated from field: repeated qdrant.ScoredPoint hits = 2;
   */
  hits: ScoredPoint[];

  /**
   * Point(s) from the lookup collection that matches the group id
   *
   * @generated from field: qdrant.RetrievedPoint lookup = 3;
   */
  lookup?: RetrievedPoint;
};

/**
 * Describes the message qdrant.PointGroup.
 * Use `create(PointGroupSchema)` to create a new message.
 */
export const PointGroupSchema: GenMessage<PointGroup> = /*@__PURE__*/
  messageDesc(file_points, 88);

/**
 * @generated from message qdrant.GroupsResult
 */
export type GroupsResult = Message<"qdrant.GroupsResult"> & {
  /**
   * Groups
   *
   * @generated from field: repeated qdrant.PointGroup groups = 1;
   */
  groups: PointGroup[];
};

/**
 * Describes the message qdrant.GroupsResult.
 * Use `create(GroupsResultSchema)` to create a new message.
 */
export const GroupsResultSchema: GenMessage<GroupsResult> = /*@__PURE__*/
  messageDesc(file_points, 89);

/**
 * @generated from message qdrant.SearchResponse
 */
export type SearchResponse = Message<"qdrant.SearchResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchResponse.
 * Use `create(SearchResponseSchema)` to create a new message.
 */
export const SearchResponseSchema: GenMessage<SearchResponse> = /*@__PURE__*/
  messageDesc(file_points, 90);

/**
 * @generated from message qdrant.QueryResponse
 */
export type QueryResponse = Message<"qdrant.QueryResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.QueryResponse.
 * Use `create(QueryResponseSchema)` to create a new message.
 */
export const QueryResponseSchema: GenMessage<QueryResponse> = /*@__PURE__*/
  messageDesc(file_points, 91);

/**
 * @generated from message qdrant.QueryBatchResponse
 */
export type QueryBatchResponse = Message<"qdrant.QueryBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.QueryBatchResponse.
 * Use `create(QueryBatchResponseSchema)` to create a new message.
 */
export const QueryBatchResponseSchema: GenMessage<QueryBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 92);

/**
 * @generated from message qdrant.QueryGroupsResponse
 */
export type QueryGroupsResponse = Message<"qdrant.QueryGroupsResponse"> & {
  /**
   * @generated from field: qdrant.GroupsResult result = 1;
   */
  result?: GroupsResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.QueryGroupsResponse.
 * Use `create(QueryGroupsResponseSchema)` to create a new message.
 */
export const QueryGroupsResponseSchema: GenMessage<QueryGroupsResponse> = /*@__PURE__*/
  messageDesc(file_points, 93);

/**
 * @generated from message qdrant.BatchResult
 */
export type BatchResult = Message<"qdrant.BatchResult"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];
};

/**
 * Describes the message qdrant.BatchResult.
 * Use `create(BatchResultSchema)` to create a new message.
 */
export const BatchResultSchema: GenMessage<BatchResult> = /*@__PURE__*/
  messageDesc(file_points, 94);

/**
 * @generated from message qdrant.SearchBatchResponse
 */
export type SearchBatchResponse = Message<"qdrant.SearchBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchBatchResponse.
 * Use `create(SearchBatchResponseSchema)` to create a new message.
 */
export const SearchBatchResponseSchema: GenMessage<SearchBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 95);

/**
 * @generated from message qdrant.SearchGroupsResponse
 */
export type SearchGroupsResponse = Message<"qdrant.SearchGroupsResponse"> & {
  /**
   * @generated from field: qdrant.GroupsResult result = 1;
   */
  result?: GroupsResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchGroupsResponse.
 * Use `create(SearchGroupsResponseSchema)` to create a new message.
 */
export const SearchGroupsResponseSchema: GenMessage<SearchGroupsResponse> = /*@__PURE__*/
  messageDesc(file_points, 96);

/**
 * @generated from message qdrant.CountResponse
 */
export type CountResponse = Message<"qdrant.CountResponse"> & {
  /**
   * @generated from field: qdrant.CountResult result = 1;
   */
  result?: CountResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.CountResponse.
 * Use `create(CountResponseSchema)` to create a new message.
 */
export const CountResponseSchema: GenMessage<CountResponse> = /*@__PURE__*/
  messageDesc(file_points, 97);

/**
 * @generated from message qdrant.ScrollResponse
 */
export type ScrollResponse = Message<"qdrant.ScrollResponse"> & {
  /**
   * Use this offset for the next query
   *
   * @generated from field: optional qdrant.PointId next_page_offset = 1;
   */
  nextPageOffset?: PointId;

  /**
   * @generated from field: repeated qdrant.RetrievedPoint result = 2;
   */
  result: RetrievedPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 3;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 4;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.ScrollResponse.
 * Use `create(ScrollResponseSchema)` to create a new message.
 */
export const ScrollResponseSchema: GenMessage<ScrollResponse> = /*@__PURE__*/
  messageDesc(file_points, 98);

/**
 * @generated from message qdrant.CountResult
 */
export type CountResult = Message<"qdrant.CountResult"> & {
  /**
   * @generated from field: uint64 count = 1;
   */
  count: bigint;
};

/**
 * Describes the message qdrant.CountResult.
 * Use `create(CountResultSchema)` to create a new message.
 */
export const CountResultSchema: GenMessage<CountResult> = /*@__PURE__*/
  messageDesc(file_points, 99);

/**
 * @generated from message qdrant.RetrievedPoint
 */
export type RetrievedPoint = Message<"qdrant.RetrievedPoint"> & {
  /**
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * @generated from field: map<string, qdrant.Value> payload = 2;
   */
  payload: { [key: string]: Value };

  /**
   * @generated from field: optional qdrant.VectorsOutput vectors = 4;
   */
  vectors?: VectorsOutput;

  /**
   * Shard key
   *
   * @generated from field: optional qdrant.ShardKey shard_key = 5;
   */
  shardKey?: ShardKey;

  /**
   * Order-by value
   *
   * @generated from field: optional qdrant.OrderValue order_value = 6;
   */
  orderValue?: OrderValue;
};

/**
 * Describes the message qdrant.RetrievedPoint.
 * Use `create(RetrievedPointSchema)` to create a new message.
 */
export const RetrievedPointSchema: GenMessage<RetrievedPoint> = /*@__PURE__*/
  messageDesc(file_points, 100);

/**
 * @generated from message qdrant.GetResponse
 */
export type GetResponse = Message<"qdrant.GetResponse"> & {
  /**
   * @generated from field: repeated qdrant.RetrievedPoint result = 1;
   */
  result: RetrievedPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.GetResponse.
 * Use `create(GetResponseSchema)` to create a new message.
 */
export const GetResponseSchema: GenMessage<GetResponse> = /*@__PURE__*/
  messageDesc(file_points, 101);

/**
 * @generated from message qdrant.RecommendResponse
 */
export type RecommendResponse = Message<"qdrant.RecommendResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.RecommendResponse.
 * Use `create(RecommendResponseSchema)` to create a new message.
 */
export const RecommendResponseSchema: GenMessage<RecommendResponse> = /*@__PURE__*/
  messageDesc(file_points, 102);

/**
 * @generated from message qdrant.RecommendBatchResponse
 */
export type RecommendBatchResponse = Message<"qdrant.RecommendBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.RecommendBatchResponse.
 * Use `create(RecommendBatchResponseSchema)` to create a new message.
 */
export const RecommendBatchResponseSchema: GenMessage<RecommendBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 103);

/**
 * @generated from message qdrant.DiscoverResponse
 */
export type DiscoverResponse = Message<"qdrant.DiscoverResponse"> & {
  /**
   * @generated from field: repeated qdrant.ScoredPoint result = 1;
   */
  result: ScoredPoint[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.DiscoverResponse.
 * Use `create(DiscoverResponseSchema)` to create a new message.
 */
export const DiscoverResponseSchema: GenMessage<DiscoverResponse> = /*@__PURE__*/
  messageDesc(file_points, 104);

/**
 * @generated from message qdrant.DiscoverBatchResponse
 */
export type DiscoverBatchResponse = Message<"qdrant.DiscoverBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.BatchResult result = 1;
   */
  result: BatchResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.DiscoverBatchResponse.
 * Use `create(DiscoverBatchResponseSchema)` to create a new message.
 */
export const DiscoverBatchResponseSchema: GenMessage<DiscoverBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 105);

/**
 * @generated from message qdrant.RecommendGroupsResponse
 */
export type RecommendGroupsResponse = Message<"qdrant.RecommendGroupsResponse"> & {
  /**
   * @generated from field: qdrant.GroupsResult result = 1;
   */
  result?: GroupsResult;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.RecommendGroupsResponse.
 * Use `create(RecommendGroupsResponseSchema)` to create a new message.
 */
export const RecommendGroupsResponseSchema: GenMessage<RecommendGroupsResponse> = /*@__PURE__*/
  messageDesc(file_points, 106);

/**
 * @generated from message qdrant.UpdateBatchResponse
 */
export type UpdateBatchResponse = Message<"qdrant.UpdateBatchResponse"> & {
  /**
   * @generated from field: repeated qdrant.UpdateResult result = 1;
   */
  result: UpdateResult[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.UpdateBatchResponse.
 * Use `create(UpdateBatchResponseSchema)` to create a new message.
 */
export const UpdateBatchResponseSchema: GenMessage<UpdateBatchResponse> = /*@__PURE__*/
  messageDesc(file_points, 107);

/**
 * @generated from message qdrant.FacetResponse
 */
export type FacetResponse = Message<"qdrant.FacetResponse"> & {
  /**
   * @generated from field: repeated qdrant.FacetHit hits = 1;
   */
  hits: FacetHit[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.FacetResponse.
 * Use `create(FacetResponseSchema)` to create a new message.
 */
export const FacetResponseSchema: GenMessage<FacetResponse> = /*@__PURE__*/
  messageDesc(file_points, 108);

/**
 * @generated from message qdrant.SearchMatrixPairsResponse
 */
export type SearchMatrixPairsResponse = Message<"qdrant.SearchMatrixPairsResponse"> & {
  /**
   * @generated from field: qdrant.SearchMatrixPairs result = 1;
   */
  result?: SearchMatrixPairs;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchMatrixPairsResponse.
 * Use `create(SearchMatrixPairsResponseSchema)` to create a new message.
 */
export const SearchMatrixPairsResponseSchema: GenMessage<SearchMatrixPairsResponse> = /*@__PURE__*/
  messageDesc(file_points, 109);

/**
 * @generated from message qdrant.SearchMatrixOffsetsResponse
 */
export type SearchMatrixOffsetsResponse = Message<"qdrant.SearchMatrixOffsetsResponse"> & {
  /**
   * @generated from field: qdrant.SearchMatrixOffsets result = 1;
   */
  result?: SearchMatrixOffsets;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;

  /**
   * @generated from field: optional qdrant.Usage usage = 3;
   */
  usage?: Usage;
};

/**
 * Describes the message qdrant.SearchMatrixOffsetsResponse.
 * Use `create(SearchMatrixOffsetsResponseSchema)` to create a new message.
 */
export const SearchMatrixOffsetsResponseSchema: GenMessage<SearchMatrixOffsetsResponse> = /*@__PURE__*/
  messageDesc(file_points, 110);

/**
 * @generated from message qdrant.Filter
 */
export type Filter = Message<"qdrant.Filter"> & {
  /**
   * At least one of those conditions should match
   *
   * @generated from field: repeated qdrant.Condition should = 1;
   */
  should: Condition[];

  /**
   * All conditions must match
   *
   * @generated from field: repeated qdrant.Condition must = 2;
   */
  must: Condition[];

  /**
   * All conditions must NOT match
   *
   * @generated from field: repeated qdrant.Condition must_not = 3;
   */
  mustNot: Condition[];

  /**
   * At least minimum amount of given conditions should match
   *
   * @generated from field: optional qdrant.MinShould min_should = 4;
   */
  minShould?: MinShould;
};

/**
 * Describes the message qdrant.Filter.
 * Use `create(FilterSchema)` to create a new message.
 */
export const FilterSchema: GenMessage<Filter> = /*@__PURE__*/
  messageDesc(file_points, 111);

/**
 * @generated from message qdrant.MinShould
 */
export type MinShould = Message<"qdrant.MinShould"> & {
  /**
   * @generated from field: repeated qdrant.Condition conditions = 1;
   */
  conditions: Condition[];

  /**
   * @generated from field: uint64 min_count = 2;
   */
  minCount: bigint;
};

/**
 * Describes the message qdrant.MinShould.
 * Use `create(MinShouldSchema)` to create a new message.
 */
export const MinShouldSchema: GenMessage<MinShould> = /*@__PURE__*/
  messageDesc(file_points, 112);

/**
 * @generated from message qdrant.Condition
 */
export type Condition = Message<"qdrant.Condition"> & {
  /**
   * @generated from oneof qdrant.Condition.condition_one_of
   */
  conditionOneOf: {
    /**
     * @generated from field: qdrant.FieldCondition field = 1;
     */
    value: FieldCondition;
    case: "field";
  } | {
    /**
     * @generated from field: qdrant.IsEmptyCondition is_empty = 2;
     */
    value: IsEmptyCondition;
    case: "isEmpty";
  } | {
    /**
     * @generated from field: qdrant.HasIdCondition has_id = 3;
     */
    value: HasIdCondition;
    case: "hasId";
  } | {
    /**
     * @generated from field: qdrant.Filter filter = 4;
     */
    value: Filter;
    case: "filter";
  } | {
    /**
     * @generated from field: qdrant.IsNullCondition is_null = 5;
     */
    value: IsNullCondition;
    case: "isNull";
  } | {
    /**
     * @generated from field: qdrant.NestedCondition nested = 6;
     */
    value: NestedCondition;
    case: "nested";
  } | {
    /**
     * @generated from field: qdrant.HasVectorCondition has_vector = 7;
     */
    value: HasVectorCondition;
    case: "hasVector";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Condition.
 * Use `create(ConditionSchema)` to create a new message.
 */
export const ConditionSchema: GenMessage<Condition> = /*@__PURE__*/
  messageDesc(file_points, 113);

/**
 * @generated from message qdrant.IsEmptyCondition
 */
export type IsEmptyCondition = Message<"qdrant.IsEmptyCondition"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;
};

/**
 * Describes the message qdrant.IsEmptyCondition.
 * Use `create(IsEmptyConditionSchema)` to create a new message.
 */
export const IsEmptyConditionSchema: GenMessage<IsEmptyCondition> = /*@__PURE__*/
  messageDesc(file_points, 114);

/**
 * @generated from message qdrant.IsNullCondition
 */
export type IsNullCondition = Message<"qdrant.IsNullCondition"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;
};

/**
 * Describes the message qdrant.IsNullCondition.
 * Use `create(IsNullConditionSchema)` to create a new message.
 */
export const IsNullConditionSchema: GenMessage<IsNullCondition> = /*@__PURE__*/
  messageDesc(file_points, 115);

/**
 * @generated from message qdrant.HasIdCondition
 */
export type HasIdCondition = Message<"qdrant.HasIdCondition"> & {
  /**
   * @generated from field: repeated qdrant.PointId has_id = 1;
   */
  hasId: PointId[];
};

/**
 * Describes the message qdrant.HasIdCondition.
 * Use `create(HasIdConditionSchema)` to create a new message.
 */
export const HasIdConditionSchema: GenMessage<HasIdCondition> = /*@__PURE__*/
  messageDesc(file_points, 116);

/**
 * @generated from message qdrant.HasVectorCondition
 */
export type HasVectorCondition = Message<"qdrant.HasVectorCondition"> & {
  /**
   * @generated from field: string has_vector = 1;
   */
  hasVector: string;
};

/**
 * Describes the message qdrant.HasVectorCondition.
 * Use `create(HasVectorConditionSchema)` to create a new message.
 */
export const HasVectorConditionSchema: GenMessage<HasVectorCondition> = /*@__PURE__*/
  messageDesc(file_points, 117);

/**
 * @generated from message qdrant.NestedCondition
 */
export type NestedCondition = Message<"qdrant.NestedCondition"> & {
  /**
   * Path to nested object
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Filter condition
   *
   * @generated from field: qdrant.Filter filter = 2;
   */
  filter?: Filter;
};

/**
 * Describes the message qdrant.NestedCondition.
 * Use `create(NestedConditionSchema)` to create a new message.
 */
export const NestedConditionSchema: GenMessage<NestedCondition> = /*@__PURE__*/
  messageDesc(file_points, 118);

/**
 * @generated from message qdrant.FieldCondition
 */
export type FieldCondition = Message<"qdrant.FieldCondition"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Check if point has field with a given value
   *
   * @generated from field: qdrant.Match match = 2;
   */
  match?: Match;

  /**
   * Check if points value lies in a given range
   *
   * @generated from field: qdrant.Range range = 3;
   */
  range?: Range;

  /**
   * Check if points geolocation lies in a given area
   *
   * @generated from field: qdrant.GeoBoundingBox geo_bounding_box = 4;
   */
  geoBoundingBox?: GeoBoundingBox;

  /**
   * Check if geo point is within a given radius
   *
   * @generated from field: qdrant.GeoRadius geo_radius = 5;
   */
  geoRadius?: GeoRadius;

  /**
   * Check number of values for a specific field
   *
   * @generated from field: qdrant.ValuesCount values_count = 6;
   */
  valuesCount?: ValuesCount;

  /**
   * Check if geo point is within a given polygon
   *
   * @generated from field: qdrant.GeoPolygon geo_polygon = 7;
   */
  geoPolygon?: GeoPolygon;

  /**
   * Check if datetime is within a given range
   *
   * @generated from field: qdrant.DatetimeRange datetime_range = 8;
   */
  datetimeRange?: DatetimeRange;

  /**
   * Check if field is empty
   *
   * @generated from field: optional bool is_empty = 9;
   */
  isEmpty?: boolean;

  /**
   * Check if field is null
   *
   * @generated from field: optional bool is_null = 10;
   */
  isNull?: boolean;
};

/**
 * Describes the message qdrant.FieldCondition.
 * Use `create(FieldConditionSchema)` to create a new message.
 */
export const FieldConditionSchema: GenMessage<FieldCondition> = /*@__PURE__*/
  messageDesc(file_points, 119);

/**
 * @generated from message qdrant.Match
 */
export type Match = Message<"qdrant.Match"> & {
  /**
   * @generated from oneof qdrant.Match.match_value
   */
  matchValue: {
    /**
     * Match string keyword
     *
     * @generated from field: string keyword = 1;
     */
    value: string;
    case: "keyword";
  } | {
    /**
     * Match integer
     *
     * @generated from field: int64 integer = 2;
     */
    value: bigint;
    case: "integer";
  } | {
    /**
     * Match boolean
     *
     * @generated from field: bool boolean = 3;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * Match text
     *
     * @generated from field: string text = 4;
     */
    value: string;
    case: "text";
  } | {
    /**
     * Match multiple keywords
     *
     * @generated from field: qdrant.RepeatedStrings keywords = 5;
     */
    value: RepeatedStrings;
    case: "keywords";
  } | {
    /**
     * Match multiple integers
     *
     * @generated from field: qdrant.RepeatedIntegers integers = 6;
     */
    value: RepeatedIntegers;
    case: "integers";
  } | {
    /**
     * Match any other value except those integers
     *
     * @generated from field: qdrant.RepeatedIntegers except_integers = 7;
     */
    value: RepeatedIntegers;
    case: "exceptIntegers";
  } | {
    /**
     * Match any other value except those keywords
     *
     * @generated from field: qdrant.RepeatedStrings except_keywords = 8;
     */
    value: RepeatedStrings;
    case: "exceptKeywords";
  } | {
    /**
     * Match phrase text
     *
     * @generated from field: string phrase = 9;
     */
    value: string;
    case: "phrase";
  } | {
    /**
     * Match any word in the text
     *
     * @generated from field: string text_any = 10;
     */
    value: string;
    case: "textAny";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.Match.
 * Use `create(MatchSchema)` to create a new message.
 */
export const MatchSchema: GenMessage<Match> = /*@__PURE__*/
  messageDesc(file_points, 120);

/**
 * @generated from message qdrant.RepeatedStrings
 */
export type RepeatedStrings = Message<"qdrant.RepeatedStrings"> & {
  /**
   * @generated from field: repeated string strings = 1;
   */
  strings: string[];
};

/**
 * Describes the message qdrant.RepeatedStrings.
 * Use `create(RepeatedStringsSchema)` to create a new message.
 */
export const RepeatedStringsSchema: GenMessage<RepeatedStrings> = /*@__PURE__*/
  messageDesc(file_points, 121);

/**
 * @generated from message qdrant.RepeatedIntegers
 */
export type RepeatedIntegers = Message<"qdrant.RepeatedIntegers"> & {
  /**
   * @generated from field: repeated int64 integers = 1;
   */
  integers: bigint[];
};

/**
 * Describes the message qdrant.RepeatedIntegers.
 * Use `create(RepeatedIntegersSchema)` to create a new message.
 */
export const RepeatedIntegersSchema: GenMessage<RepeatedIntegers> = /*@__PURE__*/
  messageDesc(file_points, 122);

/**
 * @generated from message qdrant.Range
 */
export type Range = Message<"qdrant.Range"> & {
  /**
   * @generated from field: optional double lt = 1;
   */
  lt?: number;

  /**
   * @generated from field: optional double gt = 2;
   */
  gt?: number;

  /**
   * @generated from field: optional double gte = 3;
   */
  gte?: number;

  /**
   * @generated from field: optional double lte = 4;
   */
  lte?: number;
};

/**
 * Describes the message qdrant.Range.
 * Use `create(RangeSchema)` to create a new message.
 */
export const RangeSchema: GenMessage<Range> = /*@__PURE__*/
  messageDesc(file_points, 123);

/**
 * @generated from message qdrant.DatetimeRange
 */
export type DatetimeRange = Message<"qdrant.DatetimeRange"> & {
  /**
   * @generated from field: optional google.protobuf.Timestamp lt = 1;
   */
  lt?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp gt = 2;
   */
  gt?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp gte = 3;
   */
  gte?: Timestamp;

  /**
   * @generated from field: optional google.protobuf.Timestamp lte = 4;
   */
  lte?: Timestamp;
};

/**
 * Describes the message qdrant.DatetimeRange.
 * Use `create(DatetimeRangeSchema)` to create a new message.
 */
export const DatetimeRangeSchema: GenMessage<DatetimeRange> = /*@__PURE__*/
  messageDesc(file_points, 124);

/**
 * @generated from message qdrant.GeoBoundingBox
 */
export type GeoBoundingBox = Message<"qdrant.GeoBoundingBox"> & {
  /**
   * north-west corner
   *
   * @generated from field: qdrant.GeoPoint top_left = 1;
   */
  topLeft?: GeoPoint;

  /**
   * south-east corner
   *
   * @generated from field: qdrant.GeoPoint bottom_right = 2;
   */
  bottomRight?: GeoPoint;
};

/**
 * Describes the message qdrant.GeoBoundingBox.
 * Use `create(GeoBoundingBoxSchema)` to create a new message.
 */
export const GeoBoundingBoxSchema: GenMessage<GeoBoundingBox> = /*@__PURE__*/
  messageDesc(file_points, 125);

/**
 * @generated from message qdrant.GeoRadius
 */
export type GeoRadius = Message<"qdrant.GeoRadius"> & {
  /**
   * Center of the circle
   *
   * @generated from field: qdrant.GeoPoint center = 1;
   */
  center?: GeoPoint;

  /**
   * In meters
   *
   * @generated from field: float radius = 2;
   */
  radius: number;
};

/**
 * Describes the message qdrant.GeoRadius.
 * Use `create(GeoRadiusSchema)` to create a new message.
 */
export const GeoRadiusSchema: GenMessage<GeoRadius> = /*@__PURE__*/
  messageDesc(file_points, 126);

/**
 * @generated from message qdrant.GeoLineString
 */
export type GeoLineString = Message<"qdrant.GeoLineString"> & {
  /**
   * Ordered sequence of GeoPoints representing the line
   *
   * @generated from field: repeated qdrant.GeoPoint points = 1;
   */
  points: GeoPoint[];
};

/**
 * Describes the message qdrant.GeoLineString.
 * Use `create(GeoLineStringSchema)` to create a new message.
 */
export const GeoLineStringSchema: GenMessage<GeoLineString> = /*@__PURE__*/
  messageDesc(file_points, 127);

/**
 * For a valid GeoPolygon, both the exterior and interior GeoLineStrings must consist of a minimum of 4 points.
 * Additionally, the first and last points of each GeoLineString must be the same.
 *
 * @generated from message qdrant.GeoPolygon
 */
export type GeoPolygon = Message<"qdrant.GeoPolygon"> & {
  /**
   * The exterior line bounds the surface
   *
   * @generated from field: qdrant.GeoLineString exterior = 1;
   */
  exterior?: GeoLineString;

  /**
   * Interior lines (if present) bound holes within the surface
   *
   * @generated from field: repeated qdrant.GeoLineString interiors = 2;
   */
  interiors: GeoLineString[];
};

/**
 * Describes the message qdrant.GeoPolygon.
 * Use `create(GeoPolygonSchema)` to create a new message.
 */
export const GeoPolygonSchema: GenMessage<GeoPolygon> = /*@__PURE__*/
  messageDesc(file_points, 128);

/**
 * @generated from message qdrant.ValuesCount
 */
export type ValuesCount = Message<"qdrant.ValuesCount"> & {
  /**
   * @generated from field: optional uint64 lt = 1;
   */
  lt?: bigint;

  /**
   * @generated from field: optional uint64 gt = 2;
   */
  gt?: bigint;

  /**
   * @generated from field: optional uint64 gte = 3;
   */
  gte?: bigint;

  /**
   * @generated from field: optional uint64 lte = 4;
   */
  lte?: bigint;
};

/**
 * Describes the message qdrant.ValuesCount.
 * Use `create(ValuesCountSchema)` to create a new message.
 */
export const ValuesCountSchema: GenMessage<ValuesCount> = /*@__PURE__*/
  messageDesc(file_points, 129);

/**
 * @generated from message qdrant.PointsSelector
 */
export type PointsSelector = Message<"qdrant.PointsSelector"> & {
  /**
   * @generated from oneof qdrant.PointsSelector.points_selector_one_of
   */
  pointsSelectorOneOf: {
    /**
     * @generated from field: qdrant.PointsIdsList points = 1;
     */
    value: PointsIdsList;
    case: "points";
  } | {
    /**
     * @generated from field: qdrant.Filter filter = 2;
     */
    value: Filter;
    case: "filter";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.PointsSelector.
 * Use `create(PointsSelectorSchema)` to create a new message.
 */
export const PointsSelectorSchema: GenMessage<PointsSelector> = /*@__PURE__*/
  messageDesc(file_points, 130);

/**
 * @generated from message qdrant.PointsIdsList
 */
export type PointsIdsList = Message<"qdrant.PointsIdsList"> & {
  /**
   * @generated from field: repeated qdrant.PointId ids = 1;
   */
  ids: PointId[];
};

/**
 * Describes the message qdrant.PointsIdsList.
 * Use `create(PointsIdsListSchema)` to create a new message.
 */
export const PointsIdsListSchema: GenMessage<PointsIdsList> = /*@__PURE__*/
  messageDesc(file_points, 131);

/**
 * @generated from message qdrant.PointStruct
 */
export type PointStruct = Message<"qdrant.PointStruct"> & {
  /**
   * @generated from field: qdrant.PointId id = 1;
   */
  id?: PointId;

  /**
   * @generated from field: map<string, qdrant.Value> payload = 3;
   */
  payload: { [key: string]: Value };

  /**
   * @generated from field: optional qdrant.Vectors vectors = 4;
   */
  vectors?: Vectors;
};

/**
 * Describes the message qdrant.PointStruct.
 * Use `create(PointStructSchema)` to create a new message.
 */
export const PointStructSchema: GenMessage<PointStruct> = /*@__PURE__*/
  messageDesc(file_points, 132);

/**
 * @generated from message qdrant.GeoPoint
 */
export type GeoPoint = Message<"qdrant.GeoPoint"> & {
  /**
   * @generated from field: double lon = 1;
   */
  lon: number;

  /**
   * @generated from field: double lat = 2;
   */
  lat: number;
};

/**
 * Describes the message qdrant.GeoPoint.
 * Use `create(GeoPointSchema)` to create a new message.
 */
export const GeoPointSchema: GenMessage<GeoPoint> = /*@__PURE__*/
  messageDesc(file_points, 133);

/**
 * ---------------------------------------------
 * ----------- Measurements collector ----------
 * ---------------------------------------------
 *
 * @generated from message qdrant.Usage
 */
export type Usage = Message<"qdrant.Usage"> & {
  /**
   * @generated from field: optional qdrant.HardwareUsage hardware = 1;
   */
  hardware?: HardwareUsage;

  /**
   * @generated from field: optional qdrant.InferenceUsage inference = 2;
   */
  inference?: InferenceUsage;
};

/**
 * Describes the message qdrant.Usage.
 * Use `create(UsageSchema)` to create a new message.
 */
export const UsageSchema: GenMessage<Usage> = /*@__PURE__*/
  messageDesc(file_points, 134);

/**
 * @generated from message qdrant.InferenceUsage
 */
export type InferenceUsage = Message<"qdrant.InferenceUsage"> & {
  /**
   * @generated from field: map<string, qdrant.ModelUsage> models = 1;
   */
  models: { [key: string]: ModelUsage };
};

/**
 * Describes the message qdrant.InferenceUsage.
 * Use `create(InferenceUsageSchema)` to create a new message.
 */
export const InferenceUsageSchema: GenMessage<InferenceUsage> = /*@__PURE__*/
  messageDesc(file_points, 135);

/**
 * @generated from message qdrant.ModelUsage
 */
export type ModelUsage = Message<"qdrant.ModelUsage"> & {
  /**
   * @generated from field: uint64 tokens = 1;
   */
  tokens: bigint;
};

/**
 * Describes the message qdrant.ModelUsage.
 * Use `create(ModelUsageSchema)` to create a new message.
 */
export const ModelUsageSchema: GenMessage<ModelUsage> = /*@__PURE__*/
  messageDesc(file_points, 136);

/**
 * @generated from message qdrant.HardwareUsage
 */
export type HardwareUsage = Message<"qdrant.HardwareUsage"> & {
  /**
   * @generated from field: uint64 cpu = 1;
   */
  cpu: bigint;

  /**
   * @generated from field: uint64 payload_io_read = 2;
   */
  payloadIoRead: bigint;

  /**
   * @generated from field: uint64 payload_io_write = 3;
   */
  payloadIoWrite: bigint;

  /**
   * @generated from field: uint64 payload_index_io_read = 4;
   */
  payloadIndexIoRead: bigint;

  /**
   * @generated from field: uint64 payload_index_io_write = 5;
   */
  payloadIndexIoWrite: bigint;

  /**
   * @generated from field: uint64 vector_io_read = 6;
   */
  vectorIoRead: bigint;

  /**
   * @generated from field: uint64 vector_io_write = 7;
   */
  vectorIoWrite: bigint;
};

/**
 * Describes the message qdrant.HardwareUsage.
 * Use `create(HardwareUsageSchema)` to create a new message.
 */
export const HardwareUsageSchema: GenMessage<HardwareUsage> = /*@__PURE__*/
  messageDesc(file_points, 137);

/**
 * @generated from enum qdrant.WriteOrderingType
 */
export enum WriteOrderingType {
  /**
   * Write operations may be reordered, works faster, default
   *
   * @generated from enum value: Weak = 0;
   */
  Weak = 0,

  /**
   * Write operations go through dynamically selected leader, may be inconsistent for a short period of time in case of leader change
   *
   * @generated from enum value: Medium = 1;
   */
  Medium = 1,

  /**
   * Write operations go through the permanent leader, consistent, but may be unavailable if leader is down
   *
   * @generated from enum value: Strong = 2;
   */
  Strong = 2,
}

/**
 * Describes the enum qdrant.WriteOrderingType.
 */
export const WriteOrderingTypeSchema: GenEnum<WriteOrderingType> = /*@__PURE__*/
  enumDesc(file_points, 0);

/**
 * @generated from enum qdrant.ReadConsistencyType
 */
export enum ReadConsistencyType {
  /**
   * Send request to all nodes and return points which are present on all of them
   *
   * @generated from enum value: All = 0;
   */
  All = 0,

  /**
   * Send requests to all nodes and return points which are present on majority of them
   *
   * @generated from enum value: Majority = 1;
   */
  Majority = 1,

  /**
   * Send requests to half + 1 nodes, return points which are present on all of them
   *
   * @generated from enum value: Quorum = 2;
   */
  Quorum = 2,
}

/**
 * Describes the enum qdrant.ReadConsistencyType.
 */
export const ReadConsistencyTypeSchema: GenEnum<ReadConsistencyType> = /*@__PURE__*/
  enumDesc(file_points, 1);

/**
 * @generated from enum qdrant.FieldType
 */
export enum FieldType {
  /**
   * @generated from enum value: FieldTypeKeyword = 0;
   */
  FieldTypeKeyword = 0,

  /**
   * @generated from enum value: FieldTypeInteger = 1;
   */
  FieldTypeInteger = 1,

  /**
   * @generated from enum value: FieldTypeFloat = 2;
   */
  FieldTypeFloat = 2,

  /**
   * @generated from enum value: FieldTypeGeo = 3;
   */
  FieldTypeGeo = 3,

  /**
   * @generated from enum value: FieldTypeText = 4;
   */
  FieldTypeText = 4,

  /**
   * @generated from enum value: FieldTypeBool = 5;
   */
  FieldTypeBool = 5,

  /**
   * @generated from enum value: FieldTypeDatetime = 6;
   */
  FieldTypeDatetime = 6,

  /**
   * @generated from enum value: FieldTypeUuid = 7;
   */
  FieldTypeUuid = 7,
}

/**
 * Describes the enum qdrant.FieldType.
 */
export const FieldTypeSchema: GenEnum<FieldType> = /*@__PURE__*/
  enumDesc(file_points, 2);

/**
 * @generated from enum qdrant.Direction
 */
export enum Direction {
  /**
   * @generated from enum value: Asc = 0;
   */
  Asc = 0,

  /**
   * @generated from enum value: Desc = 1;
   */
  Desc = 1,
}

/**
 * Describes the enum qdrant.Direction.
 */
export const DirectionSchema: GenEnum<Direction> = /*@__PURE__*/
  enumDesc(file_points, 3);

/**
 * How to use positive and negative vectors to find the results, default is `AverageVector`.
 *
 * @generated from enum qdrant.RecommendStrategy
 */
export enum RecommendStrategy {
  /**
   * Average positive and negative vectors and create a single query with the formula
   * `query = avg_pos + avg_pos - avg_neg`. Then performs normal search.
   *
   * @generated from enum value: AverageVector = 0;
   */
  AverageVector = 0,

  /**
   * Uses custom search objective. Each candidate is compared against all
   * examples, its score is then chosen from the `max(max_pos_score, max_neg_score)`.
   * If the `max_neg_score` is chosen then it is squared and negated.
   *
   * @generated from enum value: BestScore = 1;
   */
  BestScore = 1,

  /**
   * Uses custom search objective. Compares against all inputs, sums all the scores.
   * Scores against positive vectors are added, against negatives are subtracted.
   *
   * @generated from enum value: SumScores = 2;
   */
  SumScores = 2,
}

/**
 * Describes the enum qdrant.RecommendStrategy.
 */
export const RecommendStrategySchema: GenEnum<RecommendStrategy> = /*@__PURE__*/
  enumDesc(file_points, 4);

/**
 * @generated from enum qdrant.Fusion
 */
export enum Fusion {
  /**
   * Reciprocal Rank Fusion (with default parameters)
   *
   * @generated from enum value: RRF = 0;
   */
  RRF = 0,

  /**
   * Distribution-Based Score Fusion
   *
   * @generated from enum value: DBSF = 1;
   */
  DBSF = 1,
}

/**
 * Describes the enum qdrant.Fusion.
 */
export const FusionSchema: GenEnum<Fusion> = /*@__PURE__*/
  enumDesc(file_points, 5);

/**
 * Sample points from the collection
 *
 * Available sampling methods:
 *
 * * `random` - Random sampling
 *
 * @generated from enum qdrant.Sample
 */
export enum Sample {
  /**
   * @generated from enum value: Random = 0;
   */
  Random = 0,
}

/**
 * Describes the enum qdrant.Sample.
 */
export const SampleSchema: GenEnum<Sample> = /*@__PURE__*/
  enumDesc(file_points, 6);

/**
 * @generated from enum qdrant.UpdateStatus
 */
export enum UpdateStatus {
  /**
   * @generated from enum value: UnknownUpdateStatus = 0;
   */
  UnknownUpdateStatus = 0,

  /**
   * Update is received, but not processed yet
   *
   * @generated from enum value: Acknowledged = 1;
   */
  Acknowledged = 1,

  /**
   * Update is applied and ready for search
   *
   * @generated from enum value: Completed = 2;
   */
  Completed = 2,

  /**
   * Internal: update is rejected due to an outdated clock
   *
   * @generated from enum value: ClockRejected = 3;
   */
  ClockRejected = 3,
}

/**
 * Describes the enum qdrant.UpdateStatus.
 */
export const UpdateStatusSchema: GenEnum<UpdateStatus> = /*@__PURE__*/
  enumDesc(file_points, 7);

