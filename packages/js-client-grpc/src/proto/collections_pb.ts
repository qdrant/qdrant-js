// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=js"
// @generated from file collections.proto (package qdrant, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Value } from "./json_with_int_pb.js";
import { file_json_with_int } from "./json_with_int_pb.js";
import type { Filter } from "./common_pb.js";
import { file_common } from "./common_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file collections.proto.
 */
export const file_collections: GenFile = /*@__PURE__*/
  fileDesc("ChFjb2xsZWN0aW9ucy5wcm90bxIGcWRyYW50IoMDCgxWZWN0b3JQYXJhbXMSDAoEc2l6ZRgBIAEoBBIiCghkaXN0YW5jZRgCIAEoDjIQLnFkcmFudC5EaXN0YW5jZRIwCgtobnN3X2NvbmZpZxgDIAEoCzIWLnFkcmFudC5IbnN3Q29uZmlnRGlmZkgAiAEBEjwKE3F1YW50aXphdGlvbl9jb25maWcYBCABKAsyGi5xZHJhbnQuUXVhbnRpemF0aW9uQ29uZmlnSAGIAQESFAoHb25fZGlzaxgFIAEoCEgCiAEBEicKCGRhdGF0eXBlGAYgASgOMhAucWRyYW50LkRhdGF0eXBlSAOIAQESOgoSbXVsdGl2ZWN0b3JfY29uZmlnGAcgASgLMhkucWRyYW50Lk11bHRpVmVjdG9yQ29uZmlnSASIAQFCDgoMX2huc3dfY29uZmlnQhYKFF9xdWFudGl6YXRpb25fY29uZmlnQgoKCF9vbl9kaXNrQgsKCV9kYXRhdHlwZUIVChNfbXVsdGl2ZWN0b3JfY29uZmlnItABChBWZWN0b3JQYXJhbXNEaWZmEjAKC2huc3dfY29uZmlnGAEgASgLMhYucWRyYW50Lkhuc3dDb25maWdEaWZmSACIAQESQAoTcXVhbnRpemF0aW9uX2NvbmZpZxgCIAEoCzIeLnFkcmFudC5RdWFudGl6YXRpb25Db25maWdEaWZmSAGIAQESFAoHb25fZGlzaxgDIAEoCEgCiAEBQg4KDF9obnN3X2NvbmZpZ0IWChRfcXVhbnRpemF0aW9uX2NvbmZpZ0IKCghfb25fZGlzayKCAQoPVmVjdG9yUGFyYW1zTWFwEi0KA21hcBgBIAMoCzIgLnFkcmFudC5WZWN0b3JQYXJhbXNNYXAuTWFwRW50cnkaQAoITWFwRW50cnkSCwoDa2V5GAEgASgJEiMKBXZhbHVlGAIgASgLMhQucWRyYW50LlZlY3RvclBhcmFtczoCOAEijgEKE1ZlY3RvclBhcmFtc0RpZmZNYXASMQoDbWFwGAEgAygLMiQucWRyYW50LlZlY3RvclBhcmFtc0RpZmZNYXAuTWFwRW50cnkaRAoITWFwRW50cnkSCwoDa2V5GAEgASgJEicKBXZhbHVlGAIgASgLMhgucWRyYW50LlZlY3RvclBhcmFtc0RpZmY6AjgBInAKDVZlY3RvcnNDb25maWcSJgoGcGFyYW1zGAEgASgLMhQucWRyYW50LlZlY3RvclBhcmFtc0gAEi0KCnBhcmFtc19tYXAYAiABKAsyFy5xZHJhbnQuVmVjdG9yUGFyYW1zTWFwSABCCAoGY29uZmlnInwKEVZlY3RvcnNDb25maWdEaWZmEioKBnBhcmFtcxgBIAEoCzIYLnFkcmFudC5WZWN0b3JQYXJhbXNEaWZmSAASMQoKcGFyYW1zX21hcBgCIAEoCzIbLnFkcmFudC5WZWN0b3JQYXJhbXNEaWZmTWFwSABCCAoGY29uZmlnIoMBChJTcGFyc2VWZWN0b3JQYXJhbXMSLQoFaW5kZXgYASABKAsyGS5xZHJhbnQuU3BhcnNlSW5kZXhDb25maWdIAIgBARInCghtb2RpZmllchgCIAEoDjIQLnFkcmFudC5Nb2RpZmllckgBiAEBQggKBl9pbmRleEILCglfbW9kaWZpZXIijgEKElNwYXJzZVZlY3RvckNvbmZpZxIwCgNtYXAYASADKAsyIy5xZHJhbnQuU3BhcnNlVmVjdG9yQ29uZmlnLk1hcEVudHJ5GkYKCE1hcEVudHJ5EgsKA2tleRgBIAEoCRIpCgV2YWx1ZRgCIAEoCzIaLnFkcmFudC5TcGFyc2VWZWN0b3JQYXJhbXM6AjgBIkYKEU11bHRpVmVjdG9yQ29uZmlnEjEKCmNvbXBhcmF0b3IYASABKA4yHS5xZHJhbnQuTXVsdGlWZWN0b3JDb21wYXJhdG9yIjMKGEdldENvbGxlY3Rpb25JbmZvUmVxdWVzdBIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkiMgoXQ29sbGVjdGlvbkV4aXN0c1JlcXVlc3QSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJIiIKEENvbGxlY3Rpb25FeGlzdHMSDgoGZXhpc3RzGAEgASgIIlIKGENvbGxlY3Rpb25FeGlzdHNSZXNwb25zZRIoCgZyZXN1bHQYASABKAsyGC5xZHJhbnQuQ29sbGVjdGlvbkV4aXN0cxIMCgR0aW1lGAIgASgBIhgKFkxpc3RDb2xsZWN0aW9uc1JlcXVlc3QiJQoVQ29sbGVjdGlvbkRlc2NyaXB0aW9uEgwKBG5hbWUYASABKAkiUQoZR2V0Q29sbGVjdGlvbkluZm9SZXNwb25zZRImCgZyZXN1bHQYASABKAsyFi5xZHJhbnQuQ29sbGVjdGlvbkluZm8SDAoEdGltZRgCIAEoASJbChdMaXN0Q29sbGVjdGlvbnNSZXNwb25zZRIyCgtjb2xsZWN0aW9ucxgBIAMoCzIdLnFkcmFudC5Db2xsZWN0aW9uRGVzY3JpcHRpb24SDAoEdGltZRgCIAEoASKEAQoWTWF4T3B0aW1pemF0aW9uVGhyZWFkcxIPCgV2YWx1ZRgBIAEoBEgAEjkKB3NldHRpbmcYAiABKA4yJi5xZHJhbnQuTWF4T3B0aW1pemF0aW9uVGhyZWFkcy5TZXR0aW5nSAAiEwoHU2V0dGluZxIICgRBdXRvEABCCQoHdmFyaWFudCIsCg9PcHRpbWl6ZXJTdGF0dXMSCgoCb2sYASABKAgSDQoFZXJyb3IYAiABKAkiJAoRQ29sbGVjdGlvbldhcm5pbmcSDwoHbWVzc2FnZRgBIAEoCSLAAgoOSG5zd0NvbmZpZ0RpZmYSDgoBbRgBIAEoBEgAiAEBEhkKDGVmX2NvbnN0cnVjdBgCIAEoBEgBiAEBEiAKE2Z1bGxfc2Nhbl90aHJlc2hvbGQYAyABKARIAogBARIhChRtYXhfaW5kZXhpbmdfdGhyZWFkcxgEIAEoBEgDiAEBEhQKB29uX2Rpc2sYBSABKAhIBIgBARIWCglwYXlsb2FkX20YBiABKARIBYgBARIbCg5pbmxpbmVfc3RvcmFnZRgHIAEoCEgGiAEBQgQKAl9tQg8KDV9lZl9jb25zdHJ1Y3RCFgoUX2Z1bGxfc2Nhbl90aHJlc2hvbGRCFwoVX21heF9pbmRleGluZ190aHJlYWRzQgoKCF9vbl9kaXNrQgwKCl9wYXlsb2FkX21CEQoPX2lubGluZV9zdG9yYWdlIqUBChFTcGFyc2VJbmRleENvbmZpZxIgChNmdWxsX3NjYW5fdGhyZXNob2xkGAEgASgESACIAQESFAoHb25fZGlzaxgCIAEoCEgBiAEBEicKCGRhdGF0eXBlGAMgASgOMhAucWRyYW50LkRhdGF0eXBlSAKIAQFCFgoUX2Z1bGxfc2Nhbl90aHJlc2hvbGRCCgoIX29uX2Rpc2tCCwoJX2RhdGF0eXBlIq8BCg1XYWxDb25maWdEaWZmEhwKD3dhbF9jYXBhY2l0eV9tYhgBIAEoBEgAiAEBEh8KEndhbF9zZWdtZW50c19haGVhZBgCIAEoBEgBiAEBEh4KEXdhbF9yZXRhaW5fY2xvc2VkGAMgASgESAKIAQFCEgoQX3dhbF9jYXBhY2l0eV9tYkIVChNfd2FsX3NlZ21lbnRzX2FoZWFkQhQKEl93YWxfcmV0YWluX2Nsb3NlZCLmBAoUT3B0aW1pemVyc0NvbmZpZ0RpZmYSHgoRZGVsZXRlZF90aHJlc2hvbGQYASABKAFIAIgBARIlChh2YWN1dW1fbWluX3ZlY3Rvcl9udW1iZXIYAiABKARIAYgBARIjChZkZWZhdWx0X3NlZ21lbnRfbnVtYmVyGAMgASgESAKIAQESHQoQbWF4X3NlZ21lbnRfc2l6ZRgEIAEoBEgDiAEBEh0KEG1lbW1hcF90aHJlc2hvbGQYBSABKARIBIgBARIfChJpbmRleGluZ190aHJlc2hvbGQYBiABKARIBYgBARIfChJmbHVzaF9pbnRlcnZhbF9zZWMYByABKARIBogBARIwCiNkZXByZWNhdGVkX21heF9vcHRpbWl6YXRpb25fdGhyZWFkcxgIIAEoBEgHiAEBEkUKGG1heF9vcHRpbWl6YXRpb25fdGhyZWFkcxgJIAEoCzIeLnFkcmFudC5NYXhPcHRpbWl6YXRpb25UaHJlYWRzSAiIAQFCFAoSX2RlbGV0ZWRfdGhyZXNob2xkQhsKGV92YWN1dW1fbWluX3ZlY3Rvcl9udW1iZXJCGQoXX2RlZmF1bHRfc2VnbWVudF9udW1iZXJCEwoRX21heF9zZWdtZW50X3NpemVCEwoRX21lbW1hcF90aHJlc2hvbGRCFQoTX2luZGV4aW5nX3RocmVzaG9sZEIVChNfZmx1c2hfaW50ZXJ2YWxfc2VjQiYKJF9kZXByZWNhdGVkX21heF9vcHRpbWl6YXRpb25fdGhyZWFkc0IbChlfbWF4X29wdGltaXphdGlvbl90aHJlYWRzIogBChJTY2FsYXJRdWFudGl6YXRpb24SJgoEdHlwZRgBIAEoDjIYLnFkcmFudC5RdWFudGl6YXRpb25UeXBlEhUKCHF1YW50aWxlGAIgASgCSACIAQESFwoKYWx3YXlzX3JhbRgDIAEoCEgBiAEBQgsKCV9xdWFudGlsZUINCgtfYWx3YXlzX3JhbSJsChNQcm9kdWN0UXVhbnRpemF0aW9uEi0KC2NvbXByZXNzaW9uGAEgASgOMhgucWRyYW50LkNvbXByZXNzaW9uUmF0aW8SFwoKYWx3YXlzX3JhbRgCIAEoCEgAiAEBQg0KC19hbHdheXNfcmFtIrYBCh9CaW5hcnlRdWFudGl6YXRpb25RdWVyeUVuY29kaW5nEkIKB3NldHRpbmcYBCABKA4yLy5xZHJhbnQuQmluYXJ5UXVhbnRpemF0aW9uUXVlcnlFbmNvZGluZy5TZXR0aW5nSAAiRAoHU2V0dGluZxILCgdEZWZhdWx0EAASCgoGQmluYXJ5EAESDwoLU2NhbGFyNEJpdHMQAhIPCgtTY2FsYXI4Qml0cxADQgkKB3ZhcmlhbnQi3QEKEkJpbmFyeVF1YW50aXphdGlvbhIXCgphbHdheXNfcmFtGAEgASgISACIAQESOQoIZW5jb2RpbmcYAiABKA4yIi5xZHJhbnQuQmluYXJ5UXVhbnRpemF0aW9uRW5jb2RpbmdIAYgBARJECg5xdWVyeV9lbmNvZGluZxgDIAEoCzInLnFkcmFudC5CaW5hcnlRdWFudGl6YXRpb25RdWVyeUVuY29kaW5nSAKIAQFCDQoLX2Fsd2F5c19yYW1CCwoJX2VuY29kaW5nQhEKD19xdWVyeV9lbmNvZGluZyKwAQoSUXVhbnRpemF0aW9uQ29uZmlnEiwKBnNjYWxhchgBIAEoCzIaLnFkcmFudC5TY2FsYXJRdWFudGl6YXRpb25IABIuCgdwcm9kdWN0GAIgASgLMhsucWRyYW50LlByb2R1Y3RRdWFudGl6YXRpb25IABIsCgZiaW5hcnkYAyABKAsyGi5xZHJhbnQuQmluYXJ5UXVhbnRpemF0aW9uSABCDgoMcXVhbnRpemF0aW9uIgoKCERpc2FibGVkItoBChZRdWFudGl6YXRpb25Db25maWdEaWZmEiwKBnNjYWxhchgBIAEoCzIaLnFkcmFudC5TY2FsYXJRdWFudGl6YXRpb25IABIuCgdwcm9kdWN0GAIgASgLMhsucWRyYW50LlByb2R1Y3RRdWFudGl6YXRpb25IABIkCghkaXNhYmxlZBgDIAEoCzIQLnFkcmFudC5EaXNhYmxlZEgAEiwKBmJpbmFyeRgEIAEoCzIaLnFkcmFudC5CaW5hcnlRdWFudGl6YXRpb25IAEIOCgxxdWFudGl6YXRpb24iuQkKEFN0cmljdE1vZGVDb25maWcSFAoHZW5hYmxlZBgBIAEoCEgAiAEBEhwKD21heF9xdWVyeV9saW1pdBgCIAEoDUgBiAEBEhgKC21heF90aW1lb3V0GAMgASgNSAKIAQESKQocdW5pbmRleGVkX2ZpbHRlcmluZ19yZXRyaWV2ZRgEIAEoCEgDiAEBEicKGnVuaW5kZXhlZF9maWx0ZXJpbmdfdXBkYXRlGAUgASgISASIAQESHwoSc2VhcmNoX21heF9obnN3X2VmGAYgASgNSAWIAQESHwoSc2VhcmNoX2FsbG93X2V4YWN0GAcgASgISAaIAQESJAoXc2VhcmNoX21heF9vdmVyc2FtcGxpbmcYCCABKAJIB4gBARIhChR1cHNlcnRfbWF4X2JhdGNoc2l6ZRgJIAEoBEgIiAEBEi0KIG1heF9jb2xsZWN0aW9uX3ZlY3Rvcl9zaXplX2J5dGVzGAogASgESAmIAQESHAoPcmVhZF9yYXRlX2xpbWl0GAsgASgNSAqIAQESHQoQd3JpdGVfcmF0ZV9saW1pdBgMIAEoDUgLiAEBEi4KIW1heF9jb2xsZWN0aW9uX3BheWxvYWRfc2l6ZV9ieXRlcxgNIAEoBEgMiAEBEiIKFWZpbHRlcl9tYXhfY29uZGl0aW9ucxgOIAEoBEgNiAEBEh8KEmNvbmRpdGlvbl9tYXhfc2l6ZRgPIAEoBEgOiAEBEkQKEm11bHRpdmVjdG9yX2NvbmZpZxgQIAEoCzIjLnFkcmFudC5TdHJpY3RNb2RlTXVsdGl2ZWN0b3JDb25maWdID4gBARI6Cg1zcGFyc2VfY29uZmlnGBEgASgLMh4ucWRyYW50LlN0cmljdE1vZGVTcGFyc2VDb25maWdIEIgBARIdChBtYXhfcG9pbnRzX2NvdW50GBIgASgESBGIAQESJAoXbWF4X3BheWxvYWRfaW5kZXhfY291bnQYEyABKARIEogBAUIKCghfZW5hYmxlZEISChBfbWF4X3F1ZXJ5X2xpbWl0Qg4KDF9tYXhfdGltZW91dEIfCh1fdW5pbmRleGVkX2ZpbHRlcmluZ19yZXRyaWV2ZUIdChtfdW5pbmRleGVkX2ZpbHRlcmluZ191cGRhdGVCFQoTX3NlYXJjaF9tYXhfaG5zd19lZkIVChNfc2VhcmNoX2FsbG93X2V4YWN0QhoKGF9zZWFyY2hfbWF4X292ZXJzYW1wbGluZ0IXChVfdXBzZXJ0X21heF9iYXRjaHNpemVCIwohX21heF9jb2xsZWN0aW9uX3ZlY3Rvcl9zaXplX2J5dGVzQhIKEF9yZWFkX3JhdGVfbGltaXRCEwoRX3dyaXRlX3JhdGVfbGltaXRCJAoiX21heF9jb2xsZWN0aW9uX3BheWxvYWRfc2l6ZV9ieXRlc0IYChZfZmlsdGVyX21heF9jb25kaXRpb25zQhUKE19jb25kaXRpb25fbWF4X3NpemVCFQoTX211bHRpdmVjdG9yX2NvbmZpZ0IQCg5fc3BhcnNlX2NvbmZpZ0ITChFfbWF4X3BvaW50c19jb3VudEIaChhfbWF4X3BheWxvYWRfaW5kZXhfY291bnQisAEKFlN0cmljdE1vZGVTcGFyc2VDb25maWcSRwoNc3BhcnNlX2NvbmZpZxgBIAMoCzIwLnFkcmFudC5TdHJpY3RNb2RlU3BhcnNlQ29uZmlnLlNwYXJzZUNvbmZpZ0VudHJ5Gk0KEVNwYXJzZUNvbmZpZ0VudHJ5EgsKA2tleRgBIAEoCRInCgV2YWx1ZRgCIAEoCzIYLnFkcmFudC5TdHJpY3RNb2RlU3BhcnNlOgI4ASI6ChBTdHJpY3RNb2RlU3BhcnNlEhcKCm1heF9sZW5ndGgYCiABKARIAIgBAUINCgtfbWF4X2xlbmd0aCLOAQobU3RyaWN0TW9kZU11bHRpdmVjdG9yQ29uZmlnElYKEm11bHRpdmVjdG9yX2NvbmZpZxgBIAMoCzI6LnFkcmFudC5TdHJpY3RNb2RlTXVsdGl2ZWN0b3JDb25maWcuTXVsdGl2ZWN0b3JDb25maWdFbnRyeRpXChZNdWx0aXZlY3RvckNvbmZpZ0VudHJ5EgsKA2tleRgBIAEoCRIsCgV2YWx1ZRgCIAEoCzIdLnFkcmFudC5TdHJpY3RNb2RlTXVsdGl2ZWN0b3I6AjgBIkEKFVN0cmljdE1vZGVNdWx0aXZlY3RvchIYCgttYXhfdmVjdG9ycxgBIAEoBEgAiAEBQg4KDF9tYXhfdmVjdG9ycyKbCAoQQ3JlYXRlQ29sbGVjdGlvbhIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSMAoLaG5zd19jb25maWcYBCABKAsyFi5xZHJhbnQuSG5zd0NvbmZpZ0RpZmZIAIgBARIuCgp3YWxfY29uZmlnGAUgASgLMhUucWRyYW50LldhbENvbmZpZ0RpZmZIAYgBARI8ChFvcHRpbWl6ZXJzX2NvbmZpZxgGIAEoCzIcLnFkcmFudC5PcHRpbWl6ZXJzQ29uZmlnRGlmZkgCiAEBEhkKDHNoYXJkX251bWJlchgHIAEoDUgDiAEBEhwKD29uX2Rpc2tfcGF5bG9hZBgIIAEoCEgEiAEBEhQKB3RpbWVvdXQYCSABKARIBYgBARIyCg52ZWN0b3JzX2NvbmZpZxgKIAEoCzIVLnFkcmFudC5WZWN0b3JzQ29uZmlnSAaIAQESHwoScmVwbGljYXRpb25fZmFjdG9yGAsgASgNSAeIAQESJQoYd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yGAwgASgNSAiIAQESPAoTcXVhbnRpemF0aW9uX2NvbmZpZxgOIAEoCzIaLnFkcmFudC5RdWFudGl6YXRpb25Db25maWdICYgBARI0Cg9zaGFyZGluZ19tZXRob2QYDyABKA4yFi5xZHJhbnQuU2hhcmRpbmdNZXRob2RICogBARI+ChVzcGFyc2VfdmVjdG9yc19jb25maWcYECABKAsyGi5xZHJhbnQuU3BhcnNlVmVjdG9yQ29uZmlnSAuIAQESOQoSc3RyaWN0X21vZGVfY29uZmlnGBEgASgLMhgucWRyYW50LlN0cmljdE1vZGVDb25maWdIDIgBARI4CghtZXRhZGF0YRgSIAMoCzImLnFkcmFudC5DcmVhdGVDb2xsZWN0aW9uLk1ldGFkYXRhRW50cnkaPgoNTWV0YWRhdGFFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBQg4KDF9obnN3X2NvbmZpZ0INCgtfd2FsX2NvbmZpZ0IUChJfb3B0aW1pemVyc19jb25maWdCDwoNX3NoYXJkX251bWJlckISChBfb25fZGlza19wYXlsb2FkQgoKCF90aW1lb3V0QhEKD192ZWN0b3JzX2NvbmZpZ0IVChNfcmVwbGljYXRpb25fZmFjdG9yQhsKGV93cml0ZV9jb25zaXN0ZW5jeV9mYWN0b3JCFgoUX3F1YW50aXphdGlvbl9jb25maWdCEgoQX3NoYXJkaW5nX21ldGhvZEIYChZfc3BhcnNlX3ZlY3RvcnNfY29uZmlnQhUKE19zdHJpY3RfbW9kZV9jb25maWdKBAgCEANKBAgDEARKBAgNEA4i7AUKEFVwZGF0ZUNvbGxlY3Rpb24SFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEjwKEW9wdGltaXplcnNfY29uZmlnGAIgASgLMhwucWRyYW50Lk9wdGltaXplcnNDb25maWdEaWZmSACIAQESFAoHdGltZW91dBgDIAEoBEgBiAEBEjEKBnBhcmFtcxgEIAEoCzIcLnFkcmFudC5Db2xsZWN0aW9uUGFyYW1zRGlmZkgCiAEBEjAKC2huc3dfY29uZmlnGAUgASgLMhYucWRyYW50Lkhuc3dDb25maWdEaWZmSAOIAQESNgoOdmVjdG9yc19jb25maWcYBiABKAsyGS5xZHJhbnQuVmVjdG9yc0NvbmZpZ0RpZmZIBIgBARJAChNxdWFudGl6YXRpb25fY29uZmlnGAcgASgLMh4ucWRyYW50LlF1YW50aXphdGlvbkNvbmZpZ0RpZmZIBYgBARI+ChVzcGFyc2VfdmVjdG9yc19jb25maWcYCCABKAsyGi5xZHJhbnQuU3BhcnNlVmVjdG9yQ29uZmlnSAaIAQESOQoSc3RyaWN0X21vZGVfY29uZmlnGAkgASgLMhgucWRyYW50LlN0cmljdE1vZGVDb25maWdIB4gBARI4CghtZXRhZGF0YRgKIAMoCzImLnFkcmFudC5VcGRhdGVDb2xsZWN0aW9uLk1ldGFkYXRhRW50cnkaPgoNTWV0YWRhdGFFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBQhQKEl9vcHRpbWl6ZXJzX2NvbmZpZ0IKCghfdGltZW91dEIJCgdfcGFyYW1zQg4KDF9obnN3X2NvbmZpZ0IRCg9fdmVjdG9yc19jb25maWdCFgoUX3F1YW50aXphdGlvbl9jb25maWdCGAoWX3NwYXJzZV92ZWN0b3JzX2NvbmZpZ0IVChNfc3RyaWN0X21vZGVfY29uZmlnIk0KEERlbGV0ZUNvbGxlY3Rpb24SFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhQKB3RpbWVvdXQYAiABKARIAIgBAUIKCghfdGltZW91dCI7ChtDb2xsZWN0aW9uT3BlcmF0aW9uUmVzcG9uc2USDgoGcmVzdWx0GAEgASgIEgwKBHRpbWUYAiABKAEi7gMKEENvbGxlY3Rpb25QYXJhbXMSFAoMc2hhcmRfbnVtYmVyGAMgASgNEhcKD29uX2Rpc2tfcGF5bG9hZBgEIAEoCBIyCg52ZWN0b3JzX2NvbmZpZxgFIAEoCzIVLnFkcmFudC5WZWN0b3JzQ29uZmlnSACIAQESHwoScmVwbGljYXRpb25fZmFjdG9yGAYgASgNSAGIAQESJQoYd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yGAcgASgNSAKIAQESIAoTcmVhZF9mYW5fb3V0X2ZhY3RvchgIIAEoDUgDiAEBEjQKD3NoYXJkaW5nX21ldGhvZBgJIAEoDjIWLnFkcmFudC5TaGFyZGluZ01ldGhvZEgEiAEBEj4KFXNwYXJzZV92ZWN0b3JzX2NvbmZpZxgKIAEoCzIaLnFkcmFudC5TcGFyc2VWZWN0b3JDb25maWdIBYgBAUIRCg9fdmVjdG9yc19jb25maWdCFQoTX3JlcGxpY2F0aW9uX2ZhY3RvckIbChlfd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yQhYKFF9yZWFkX2Zhbl9vdXRfZmFjdG9yQhIKEF9zaGFyZGluZ19tZXRob2RCGAoWX3NwYXJzZV92ZWN0b3JzX2NvbmZpZ0oECAEQAkoECAIQAyL+AQoUQ29sbGVjdGlvblBhcmFtc0RpZmYSHwoScmVwbGljYXRpb25fZmFjdG9yGAEgASgNSACIAQESJQoYd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yGAIgASgNSAGIAQESHAoPb25fZGlza19wYXlsb2FkGAMgASgISAKIAQESIAoTcmVhZF9mYW5fb3V0X2ZhY3RvchgEIAEoDUgDiAEBQhUKE19yZXBsaWNhdGlvbl9mYWN0b3JCGwoZX3dyaXRlX2NvbnNpc3RlbmN5X2ZhY3RvckISChBfb25fZGlza19wYXlsb2FkQhYKFF9yZWFkX2Zhbl9vdXRfZmFjdG9yIu4DChBDb2xsZWN0aW9uQ29uZmlnEigKBnBhcmFtcxgBIAEoCzIYLnFkcmFudC5Db2xsZWN0aW9uUGFyYW1zEisKC2huc3dfY29uZmlnGAIgASgLMhYucWRyYW50Lkhuc3dDb25maWdEaWZmEjYKEG9wdGltaXplcl9jb25maWcYAyABKAsyHC5xZHJhbnQuT3B0aW1pemVyc0NvbmZpZ0RpZmYSKQoKd2FsX2NvbmZpZxgEIAEoCzIVLnFkcmFudC5XYWxDb25maWdEaWZmEjwKE3F1YW50aXphdGlvbl9jb25maWcYBSABKAsyGi5xZHJhbnQuUXVhbnRpemF0aW9uQ29uZmlnSACIAQESOQoSc3RyaWN0X21vZGVfY29uZmlnGAYgASgLMhgucWRyYW50LlN0cmljdE1vZGVDb25maWdIAYgBARI4CghtZXRhZGF0YRgHIAMoCzImLnFkcmFudC5Db2xsZWN0aW9uQ29uZmlnLk1ldGFkYXRhRW50cnkaPgoNTWV0YWRhdGFFbnRyeRILCgNrZXkYASABKAkSHAoFdmFsdWUYAiABKAsyDS5xZHJhbnQuVmFsdWU6AjgBQhYKFF9xdWFudGl6YXRpb25fY29uZmlnQhUKE19zdHJpY3RfbW9kZV9jb25maWciXAoSS2V5d29yZEluZGV4UGFyYW1zEhYKCWlzX3RlbmFudBgBIAEoCEgAiAEBEhQKB29uX2Rpc2sYAiABKAhIAYgBAUIMCgpfaXNfdGVuYW50QgoKCF9vbl9kaXNrIqABChJJbnRlZ2VySW5kZXhQYXJhbXMSEwoGbG9va3VwGAEgASgISACIAQESEgoFcmFuZ2UYAiABKAhIAYgBARIZCgxpc19wcmluY2lwYWwYAyABKAhIAogBARIUCgdvbl9kaXNrGAQgASgISAOIAQFCCQoHX2xvb2t1cEIICgZfcmFuZ2VCDwoNX2lzX3ByaW5jaXBhbEIKCghfb25fZGlzayJgChBGbG9hdEluZGV4UGFyYW1zEhQKB29uX2Rpc2sYASABKAhIAIgBARIZCgxpc19wcmluY2lwYWwYAiABKAhIAYgBAUIKCghfb25fZGlza0IPCg1faXNfcHJpbmNpcGFsIjIKDkdlb0luZGV4UGFyYW1zEhQKB29uX2Rpc2sYASABKAhIAIgBAUIKCghfb25fZGlzayIxCgxTdG9wd29yZHNTZXQSEQoJbGFuZ3VhZ2VzGAEgAygJEg4KBmN1c3RvbRgCIAMoCSK4AwoPVGV4dEluZGV4UGFyYW1zEigKCXRva2VuaXplchgBIAEoDjIVLnFkcmFudC5Ub2tlbml6ZXJUeXBlEhYKCWxvd2VyY2FzZRgCIAEoCEgAiAEBEhoKDW1pbl90b2tlbl9sZW4YAyABKARIAYgBARIaCg1tYXhfdG9rZW5fbGVuGAQgASgESAKIAQESFAoHb25fZGlzaxgFIAEoCEgDiAEBEiwKCXN0b3B3b3JkcxgGIAEoCzIULnFkcmFudC5TdG9wd29yZHNTZXRIBIgBARIcCg9waHJhc2VfbWF0Y2hpbmcYByABKAhIBYgBARIvCgdzdGVtbWVyGAggASgLMhkucWRyYW50LlN0ZW1taW5nQWxnb3JpdGhtSAaIAQESGgoNYXNjaWlfZm9sZGluZxgJIAEoCEgHiAEBQgwKCl9sb3dlcmNhc2VCEAoOX21pbl90b2tlbl9sZW5CEAoOX21heF90b2tlbl9sZW5CCgoIX29uX2Rpc2tCDAoKX3N0b3B3b3Jkc0ISChBfcGhyYXNlX21hdGNoaW5nQgoKCF9zdGVtbWVyQhAKDl9hc2NpaV9mb2xkaW5nIlIKEVN0ZW1taW5nQWxnb3JpdGhtEioKCHNub3diYWxsGAEgASgLMhYucWRyYW50LlNub3diYWxsUGFyYW1zSABCEQoPc3RlbW1pbmdfcGFyYW1zIiIKDlNub3diYWxsUGFyYW1zEhAKCGxhbmd1YWdlGAEgASgJIjMKD0Jvb2xJbmRleFBhcmFtcxIUCgdvbl9kaXNrGAEgASgISACIAQFCCgoIX29uX2Rpc2siYwoTRGF0ZXRpbWVJbmRleFBhcmFtcxIUCgdvbl9kaXNrGAEgASgISACIAQESGQoMaXNfcHJpbmNpcGFsGAIgASgISAGIAQFCCgoIX29uX2Rpc2tCDwoNX2lzX3ByaW5jaXBhbCJZCg9VdWlkSW5kZXhQYXJhbXMSFgoJaXNfdGVuYW50GAEgASgISACIAQESFAoHb25fZGlzaxgCIAEoCEgBiAEBQgwKCl9pc190ZW5hbnRCCgoIX29uX2Rpc2si6AMKElBheWxvYWRJbmRleFBhcmFtcxI6ChRrZXl3b3JkX2luZGV4X3BhcmFtcxgDIAEoCzIaLnFkcmFudC5LZXl3b3JkSW5kZXhQYXJhbXNIABI6ChRpbnRlZ2VyX2luZGV4X3BhcmFtcxgCIAEoCzIaLnFkcmFudC5JbnRlZ2VySW5kZXhQYXJhbXNIABI2ChJmbG9hdF9pbmRleF9wYXJhbXMYBCABKAsyGC5xZHJhbnQuRmxvYXRJbmRleFBhcmFtc0gAEjIKEGdlb19pbmRleF9wYXJhbXMYBSABKAsyFi5xZHJhbnQuR2VvSW5kZXhQYXJhbXNIABI0ChF0ZXh0X2luZGV4X3BhcmFtcxgBIAEoCzIXLnFkcmFudC5UZXh0SW5kZXhQYXJhbXNIABI0ChFib29sX2luZGV4X3BhcmFtcxgGIAEoCzIXLnFkcmFudC5Cb29sSW5kZXhQYXJhbXNIABI8ChVkYXRldGltZV9pbmRleF9wYXJhbXMYByABKAsyGy5xZHJhbnQuRGF0ZXRpbWVJbmRleFBhcmFtc0gAEjQKEXV1aWRfaW5kZXhfcGFyYW1zGAggASgLMhcucWRyYW50LlV1aWRJbmRleFBhcmFtc0gAQg4KDGluZGV4X3BhcmFtcyKdAQoRUGF5bG9hZFNjaGVtYUluZm8SLAoJZGF0YV90eXBlGAEgASgOMhkucWRyYW50LlBheWxvYWRTY2hlbWFUeXBlEi8KBnBhcmFtcxgCIAEoCzIaLnFkcmFudC5QYXlsb2FkSW5kZXhQYXJhbXNIAIgBARITCgZwb2ludHMYAyABKARIAYgBAUIJCgdfcGFyYW1zQgkKB19wb2ludHMi7AMKDkNvbGxlY3Rpb25JbmZvEigKBnN0YXR1cxgBIAEoDjIYLnFkcmFudC5Db2xsZWN0aW9uU3RhdHVzEjEKEG9wdGltaXplcl9zdGF0dXMYAiABKAsyFy5xZHJhbnQuT3B0aW1pemVyU3RhdHVzEhYKDnNlZ21lbnRzX2NvdW50GAQgASgEEigKBmNvbmZpZxgHIAEoCzIYLnFkcmFudC5Db2xsZWN0aW9uQ29uZmlnEkEKDnBheWxvYWRfc2NoZW1hGAggAygLMikucWRyYW50LkNvbGxlY3Rpb25JbmZvLlBheWxvYWRTY2hlbWFFbnRyeRIZCgxwb2ludHNfY291bnQYCSABKARIAIgBARIiChVpbmRleGVkX3ZlY3RvcnNfY291bnQYCiABKARIAYgBARIrCgh3YXJuaW5ncxgLIAMoCzIZLnFkcmFudC5Db2xsZWN0aW9uV2FybmluZxpPChJQYXlsb2FkU2NoZW1hRW50cnkSCwoDa2V5GAEgASgJEigKBXZhbHVlGAIgASgLMhkucWRyYW50LlBheWxvYWRTY2hlbWFJbmZvOgI4AUIPCg1fcG9pbnRzX2NvdW50QhgKFl9pbmRleGVkX3ZlY3RvcnNfY291bnRKBAgDEARKBAgFEAZKBAgGEAciWwoNQ2hhbmdlQWxpYXNlcxIoCgdhY3Rpb25zGAEgAygLMhcucWRyYW50LkFsaWFzT3BlcmF0aW9ucxIUCgd0aW1lb3V0GAIgASgESACIAQFCCgoIX3RpbWVvdXQiogEKD0FsaWFzT3BlcmF0aW9ucxIrCgxjcmVhdGVfYWxpYXMYASABKAsyEy5xZHJhbnQuQ3JlYXRlQWxpYXNIABIrCgxyZW5hbWVfYWxpYXMYAiABKAsyEy5xZHJhbnQuUmVuYW1lQWxpYXNIABIrCgxkZWxldGVfYWxpYXMYAyABKAsyEy5xZHJhbnQuRGVsZXRlQWxpYXNIAEIICgZhY3Rpb24iOgoLQ3JlYXRlQWxpYXMSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJEhIKCmFsaWFzX25hbWUYAiABKAkiPQoLUmVuYW1lQWxpYXMSFgoOb2xkX2FsaWFzX25hbWUYASABKAkSFgoObmV3X2FsaWFzX25hbWUYAiABKAkiIQoLRGVsZXRlQWxpYXMSEgoKYWxpYXNfbmFtZRgBIAEoCSIUChJMaXN0QWxpYXNlc1JlcXVlc3QiNwocTGlzdENvbGxlY3Rpb25BbGlhc2VzUmVxdWVzdBIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkiPwoQQWxpYXNEZXNjcmlwdGlvbhISCgphbGlhc19uYW1lGAEgASgJEhcKD2NvbGxlY3Rpb25fbmFtZRgCIAEoCSJOChNMaXN0QWxpYXNlc1Jlc3BvbnNlEikKB2FsaWFzZXMYASADKAsyGC5xZHJhbnQuQWxpYXNEZXNjcmlwdGlvbhIMCgR0aW1lGAIgASgBIjcKHENvbGxlY3Rpb25DbHVzdGVySW5mb1JlcXVlc3QSFwoPY29sbGVjdGlvbl9uYW1lGAEgASgJIjYKCFNoYXJkS2V5EhEKB2tleXdvcmQYASABKAlIABIQCgZudW1iZXIYAiABKARIAEIFCgNrZXkilQEKDkxvY2FsU2hhcmRJbmZvEhAKCHNoYXJkX2lkGAEgASgNEhQKDHBvaW50c19jb3VudBgCIAEoBBIjCgVzdGF0ZRgDIAEoDjIULnFkcmFudC5SZXBsaWNhU3RhdGUSKAoJc2hhcmRfa2V5GAQgASgLMhAucWRyYW50LlNoYXJkS2V5SACIAQFCDAoKX3NoYXJkX2tleSKRAQoPUmVtb3RlU2hhcmRJbmZvEhAKCHNoYXJkX2lkGAEgASgNEg8KB3BlZXJfaWQYAiABKAQSIwoFc3RhdGUYAyABKA4yFC5xZHJhbnQuUmVwbGljYVN0YXRlEigKCXNoYXJkX2tleRgEIAEoCzIQLnFkcmFudC5TaGFyZEtleUgAiAEBQgwKCl9zaGFyZF9rZXkidwoRU2hhcmRUcmFuc2ZlckluZm8SEAoIc2hhcmRfaWQYASABKA0SGAoLdG9fc2hhcmRfaWQYBSABKA1IAIgBARIMCgRmcm9tGAIgASgEEgoKAnRvGAMgASgEEgwKBHN5bmMYBCABKAhCDgoMX3RvX3NoYXJkX2lkIpsBCg5SZXNoYXJkaW5nSW5mbxIQCghzaGFyZF9pZBgBIAEoDRIPCgdwZWVyX2lkGAIgASgEEigKCXNoYXJkX2tleRgDIAEoCzIQLnFkcmFudC5TaGFyZEtleUgAiAEBEi4KCWRpcmVjdGlvbhgEIAEoDjIbLnFkcmFudC5SZXNoYXJkaW5nRGlyZWN0aW9uQgwKCl9zaGFyZF9rZXkijgIKHUNvbGxlY3Rpb25DbHVzdGVySW5mb1Jlc3BvbnNlEg8KB3BlZXJfaWQYASABKAQSEwoLc2hhcmRfY291bnQYAiABKAQSLAoMbG9jYWxfc2hhcmRzGAMgAygLMhYucWRyYW50LkxvY2FsU2hhcmRJbmZvEi4KDXJlbW90ZV9zaGFyZHMYBCADKAsyFy5xZHJhbnQuUmVtb3RlU2hhcmRJbmZvEjIKD3NoYXJkX3RyYW5zZmVycxgFIAMoCzIZLnFkcmFudC5TaGFyZFRyYW5zZmVySW5mbxI1ChVyZXNoYXJkaW5nX29wZXJhdGlvbnMYBiADKAsyFi5xZHJhbnQuUmVzaGFyZGluZ0luZm8irgEKCU1vdmVTaGFyZBIQCghzaGFyZF9pZBgBIAEoDRIYCgt0b19zaGFyZF9pZBgFIAEoDUgAiAEBEhQKDGZyb21fcGVlcl9pZBgCIAEoBBISCgp0b19wZWVyX2lkGAMgASgEEjAKBm1ldGhvZBgEIAEoDjIbLnFkcmFudC5TaGFyZFRyYW5zZmVyTWV0aG9kSAGIAQFCDgoMX3RvX3NoYXJkX2lkQgkKB19tZXRob2QiswEKDlJlcGxpY2F0ZVNoYXJkEhAKCHNoYXJkX2lkGAEgASgNEhgKC3RvX3NoYXJkX2lkGAUgASgNSACIAQESFAoMZnJvbV9wZWVyX2lkGAIgASgEEhIKCnRvX3BlZXJfaWQYAyABKAQSMAoGbWV0aG9kGAQgASgOMhsucWRyYW50LlNoYXJkVHJhbnNmZXJNZXRob2RIAYgBAUIOCgxfdG9fc2hhcmRfaWRCCQoHX21ldGhvZCJ6ChJBYm9ydFNoYXJkVHJhbnNmZXISEAoIc2hhcmRfaWQYASABKA0SGAoLdG9fc2hhcmRfaWQYBCABKA1IAIgBARIUCgxmcm9tX3BlZXJfaWQYAiABKAQSEgoKdG9fcGVlcl9pZBgDIAEoBEIOCgxfdG9fc2hhcmRfaWQipAEKD1Jlc3RhcnRUcmFuc2ZlchIQCghzaGFyZF9pZBgBIAEoDRIYCgt0b19zaGFyZF9pZBgFIAEoDUgAiAEBEhQKDGZyb21fcGVlcl9pZBgCIAEoBBISCgp0b19wZWVyX2lkGAMgASgEEisKBm1ldGhvZBgEIAEoDjIbLnFkcmFudC5TaGFyZFRyYW5zZmVyTWV0aG9kQg4KDF90b19zaGFyZF9pZCKTAQoPUmVwbGljYXRlUG9pbnRzEigKDmZyb21fc2hhcmRfa2V5GAEgASgLMhAucWRyYW50LlNoYXJkS2V5EiYKDHRvX3NoYXJkX2tleRgCIAEoCzIQLnFkcmFudC5TaGFyZEtleRIjCgZmaWx0ZXIYAyABKAsyDi5xZHJhbnQuRmlsdGVySACIAQFCCQoHX2ZpbHRlciIsCgdSZXBsaWNhEhAKCHNoYXJkX2lkGAEgASgNEg8KB3BlZXJfaWQYAiABKAQi8gEKDkNyZWF0ZVNoYXJkS2V5EiMKCXNoYXJkX2tleRgBIAEoCzIQLnFkcmFudC5TaGFyZEtleRIaCg1zaGFyZHNfbnVtYmVyGAIgASgNSACIAQESHwoScmVwbGljYXRpb25fZmFjdG9yGAMgASgNSAGIAQESEQoJcGxhY2VtZW50GAQgAygEEjAKDWluaXRpYWxfc3RhdGUYBSABKA4yFC5xZHJhbnQuUmVwbGljYVN0YXRlSAKIAQFCEAoOX3NoYXJkc19udW1iZXJCFQoTX3JlcGxpY2F0aW9uX2ZhY3RvckIQCg5faW5pdGlhbF9zdGF0ZSI1Cg5EZWxldGVTaGFyZEtleRIjCglzaGFyZF9rZXkYASABKAsyEC5xZHJhbnQuU2hhcmRLZXki+gMKI1VwZGF0ZUNvbGxlY3Rpb25DbHVzdGVyU2V0dXBSZXF1ZXN0EhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRInCgptb3ZlX3NoYXJkGAIgASgLMhEucWRyYW50Lk1vdmVTaGFyZEgAEjEKD3JlcGxpY2F0ZV9zaGFyZBgDIAEoCzIWLnFkcmFudC5SZXBsaWNhdGVTaGFyZEgAEjQKDmFib3J0X3RyYW5zZmVyGAQgASgLMhoucWRyYW50LkFib3J0U2hhcmRUcmFuc2ZlckgAEicKDGRyb3BfcmVwbGljYRgFIAEoCzIPLnFkcmFudC5SZXBsaWNhSAASMgoQY3JlYXRlX3NoYXJkX2tleRgHIAEoCzIWLnFkcmFudC5DcmVhdGVTaGFyZEtleUgAEjIKEGRlbGV0ZV9zaGFyZF9rZXkYCCABKAsyFi5xZHJhbnQuRGVsZXRlU2hhcmRLZXlIABIzChByZXN0YXJ0X3RyYW5zZmVyGAkgASgLMhcucWRyYW50LlJlc3RhcnRUcmFuc2ZlckgAEjMKEHJlcGxpY2F0ZV9wb2ludHMYCiABKAsyFy5xZHJhbnQuUmVwbGljYXRlUG9pbnRzSAASFAoHdGltZW91dBgGIAEoBEgBiAEBQgsKCW9wZXJhdGlvbkIKCghfdGltZW91dCI2CiRVcGRhdGVDb2xsZWN0aW9uQ2x1c3RlclNldHVwUmVzcG9uc2USDgoGcmVzdWx0GAEgASgIInsKFUNyZWF0ZVNoYXJkS2V5UmVxdWVzdBIXCg9jb2xsZWN0aW9uX25hbWUYASABKAkSJwoHcmVxdWVzdBgCIAEoCzIWLnFkcmFudC5DcmVhdGVTaGFyZEtleRIUCgd0aW1lb3V0GAMgASgESACIAQFCCgoIX3RpbWVvdXQiewoVRGVsZXRlU2hhcmRLZXlSZXF1ZXN0EhcKD2NvbGxlY3Rpb25fbmFtZRgBIAEoCRInCgdyZXF1ZXN0GAIgASgLMhYucWRyYW50LkRlbGV0ZVNoYXJkS2V5EhQKB3RpbWVvdXQYAyABKARIAIgBAUIKCghfdGltZW91dCIoChZDcmVhdGVTaGFyZEtleVJlc3BvbnNlEg4KBnJlc3VsdBgBIAEoCCIoChZEZWxldGVTaGFyZEtleVJlc3BvbnNlEg4KBnJlc3VsdBgBIAEoCCo8CghEYXRhdHlwZRILCgdEZWZhdWx0EAASCwoHRmxvYXQzMhABEgkKBVVpbnQ4EAISCwoHRmxvYXQxNhADKh0KCE1vZGlmaWVyEggKBE5vbmUQABIHCgNJZGYQASojChVNdWx0aVZlY3RvckNvbXBhcmF0b3ISCgoGTWF4U2ltEAAqTwoIRGlzdGFuY2USEwoPVW5rbm93bkRpc3RhbmNlEAASCgoGQ29zaW5lEAESCgoGRXVjbGlkEAISBwoDRG90EAMSDQoJTWFuaGF0dGFuEAQqWQoQQ29sbGVjdGlvblN0YXR1cxIbChdVbmtub3duQ29sbGVjdGlvblN0YXR1cxAAEgkKBUdyZWVuEAESCgoGWWVsbG93EAISBwoDUmVkEAMSCAoER3JleRAEKn4KEVBheWxvYWRTY2hlbWFUeXBlEg8KC1Vua25vd25UeXBlEAASCwoHS2V5d29yZBABEgsKB0ludGVnZXIQAhIJCgVGbG9hdBADEgcKA0dlbxAEEggKBFRleHQQBRIICgRCb29sEAYSDAoIRGF0ZXRpbWUQBxIICgRVdWlkEAgqNQoQUXVhbnRpemF0aW9uVHlwZRIXChNVbmtub3duUXVhbnRpemF0aW9uEAASCAoESW50OBABKj0KEENvbXByZXNzaW9uUmF0aW8SBgoCeDQQABIGCgJ4OBABEgcKA3gxNhACEgcKA3gzMhADEgcKA3g2NBAEKkkKGkJpbmFyeVF1YW50aXphdGlvbkVuY29kaW5nEgoKBk9uZUJpdBAAEgsKB1R3b0JpdHMQARISCg5PbmVBbmRIYWxmQml0cxACKiYKDlNoYXJkaW5nTWV0aG9kEggKBEF1dG8QABIKCgZDdXN0b20QASpUCg1Ub2tlbml6ZXJUeXBlEgsKB1Vua25vd24QABIKCgZQcmVmaXgQARIOCgpXaGl0ZXNwYWNlEAISCAoEV29yZBADEhAKDE11bHRpbGluZ3VhbBAEKq0BCgxSZXBsaWNhU3RhdGUSCgoGQWN0aXZlEAASCAoERGVhZBABEgsKB1BhcnRpYWwQAhIQCgxJbml0aWFsaXppbmcQAxIMCghMaXN0ZW5lchAEEhMKD1BhcnRpYWxTbmFwc2hvdBAFEgwKCFJlY292ZXJ5EAYSDgoKUmVzaGFyZGluZxAHEhcKE1Jlc2hhcmRpbmdTY2FsZURvd24QCBIOCgpBY3RpdmVSZWFkEAkqJwoTUmVzaGFyZGluZ0RpcmVjdGlvbhIGCgJVcBAAEggKBERvd24QASphChNTaGFyZFRyYW5zZmVyTWV0aG9kEhEKDVN0cmVhbVJlY29yZHMQABIMCghTbmFwc2hvdBABEgwKCFdhbERlbHRhEAISGwoXUmVzaGFyZGluZ1N0cmVhbVJlY29yZHMQA0IVqgISUWRyYW50LkNsaWVudC5HcnBjYgZwcm90bzM", [file_json_with_int, file_common]);

/**
 * @generated from message qdrant.VectorParams
 */
export type VectorParams = Message<"qdrant.VectorParams"> & {
  /**
   * Size of the vectors
   *
   * @generated from field: uint64 size = 1;
   */
  size: bigint;

  /**
   * Distance function used for comparing vectors
   *
   * @generated from field: qdrant.Distance distance = 2;
   */
  distance: Distance;

  /**
   * Configuration of vector HNSW graph. If omitted - the collection configuration will be used
   *
   * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 3;
   */
  hnswConfig?: HnswConfigDiff;

  /**
   * Configuration of vector quantization config. If omitted - the collection configuration will be used
   *
   * @generated from field: optional qdrant.QuantizationConfig quantization_config = 4;
   */
  quantizationConfig?: QuantizationConfig;

  /**
   * If true - serve vectors from disk. If set to false, the vectors will be loaded in RAM.
   *
   * @generated from field: optional bool on_disk = 5;
   */
  onDisk?: boolean;

  /**
   * Data type of the vectors
   *
   * @generated from field: optional qdrant.Datatype datatype = 6;
   */
  datatype?: Datatype;

  /**
   * Configuration for multi-vector search
   *
   * @generated from field: optional qdrant.MultiVectorConfig multivector_config = 7;
   */
  multivectorConfig?: MultiVectorConfig;
};

/**
 * Describes the message qdrant.VectorParams.
 * Use `create(VectorParamsSchema)` to create a new message.
 */
export const VectorParamsSchema: GenMessage<VectorParams> = /*@__PURE__*/
  messageDesc(file_collections, 0);

/**
 * @generated from message qdrant.VectorParamsDiff
 */
export type VectorParamsDiff = Message<"qdrant.VectorParamsDiff"> & {
  /**
   * Update params for HNSW index. If empty object - it will be unset
   *
   * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 1;
   */
  hnswConfig?: HnswConfigDiff;

  /**
   * Update quantization params. If none - it is left unchanged.
   *
   * @generated from field: optional qdrant.QuantizationConfigDiff quantization_config = 2;
   */
  quantizationConfig?: QuantizationConfigDiff;

  /**
   * If true - serve vectors from disk. If set to false, the vectors will be loaded in RAM.
   *
   * @generated from field: optional bool on_disk = 3;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.VectorParamsDiff.
 * Use `create(VectorParamsDiffSchema)` to create a new message.
 */
export const VectorParamsDiffSchema: GenMessage<VectorParamsDiff> = /*@__PURE__*/
  messageDesc(file_collections, 1);

/**
 * @generated from message qdrant.VectorParamsMap
 */
export type VectorParamsMap = Message<"qdrant.VectorParamsMap"> & {
  /**
   * @generated from field: map<string, qdrant.VectorParams> map = 1;
   */
  map: { [key: string]: VectorParams };
};

/**
 * Describes the message qdrant.VectorParamsMap.
 * Use `create(VectorParamsMapSchema)` to create a new message.
 */
export const VectorParamsMapSchema: GenMessage<VectorParamsMap> = /*@__PURE__*/
  messageDesc(file_collections, 2);

/**
 * @generated from message qdrant.VectorParamsDiffMap
 */
export type VectorParamsDiffMap = Message<"qdrant.VectorParamsDiffMap"> & {
  /**
   * @generated from field: map<string, qdrant.VectorParamsDiff> map = 1;
   */
  map: { [key: string]: VectorParamsDiff };
};

/**
 * Describes the message qdrant.VectorParamsDiffMap.
 * Use `create(VectorParamsDiffMapSchema)` to create a new message.
 */
export const VectorParamsDiffMapSchema: GenMessage<VectorParamsDiffMap> = /*@__PURE__*/
  messageDesc(file_collections, 3);

/**
 * @generated from message qdrant.VectorsConfig
 */
export type VectorsConfig = Message<"qdrant.VectorsConfig"> & {
  /**
   * @generated from oneof qdrant.VectorsConfig.config
   */
  config: {
    /**
     * @generated from field: qdrant.VectorParams params = 1;
     */
    value: VectorParams;
    case: "params";
  } | {
    /**
     * @generated from field: qdrant.VectorParamsMap params_map = 2;
     */
    value: VectorParamsMap;
    case: "paramsMap";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorsConfig.
 * Use `create(VectorsConfigSchema)` to create a new message.
 */
export const VectorsConfigSchema: GenMessage<VectorsConfig> = /*@__PURE__*/
  messageDesc(file_collections, 4);

/**
 * @generated from message qdrant.VectorsConfigDiff
 */
export type VectorsConfigDiff = Message<"qdrant.VectorsConfigDiff"> & {
  /**
   * @generated from oneof qdrant.VectorsConfigDiff.config
   */
  config: {
    /**
     * @generated from field: qdrant.VectorParamsDiff params = 1;
     */
    value: VectorParamsDiff;
    case: "params";
  } | {
    /**
     * @generated from field: qdrant.VectorParamsDiffMap params_map = 2;
     */
    value: VectorParamsDiffMap;
    case: "paramsMap";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.VectorsConfigDiff.
 * Use `create(VectorsConfigDiffSchema)` to create a new message.
 */
export const VectorsConfigDiffSchema: GenMessage<VectorsConfigDiff> = /*@__PURE__*/
  messageDesc(file_collections, 5);

/**
 * @generated from message qdrant.SparseVectorParams
 */
export type SparseVectorParams = Message<"qdrant.SparseVectorParams"> & {
  /**
   * Configuration of sparse index
   *
   * @generated from field: optional qdrant.SparseIndexConfig index = 1;
   */
  index?: SparseIndexConfig;

  /**
   * If set - apply modifier to the vector values
   *
   * @generated from field: optional qdrant.Modifier modifier = 2;
   */
  modifier?: Modifier;
};

/**
 * Describes the message qdrant.SparseVectorParams.
 * Use `create(SparseVectorParamsSchema)` to create a new message.
 */
export const SparseVectorParamsSchema: GenMessage<SparseVectorParams> = /*@__PURE__*/
  messageDesc(file_collections, 6);

/**
 * @generated from message qdrant.SparseVectorConfig
 */
export type SparseVectorConfig = Message<"qdrant.SparseVectorConfig"> & {
  /**
   * @generated from field: map<string, qdrant.SparseVectorParams> map = 1;
   */
  map: { [key: string]: SparseVectorParams };
};

/**
 * Describes the message qdrant.SparseVectorConfig.
 * Use `create(SparseVectorConfigSchema)` to create a new message.
 */
export const SparseVectorConfigSchema: GenMessage<SparseVectorConfig> = /*@__PURE__*/
  messageDesc(file_collections, 7);

/**
 * @generated from message qdrant.MultiVectorConfig
 */
export type MultiVectorConfig = Message<"qdrant.MultiVectorConfig"> & {
  /**
   * Comparator for multi-vector search
   *
   * @generated from field: qdrant.MultiVectorComparator comparator = 1;
   */
  comparator: MultiVectorComparator;
};

/**
 * Describes the message qdrant.MultiVectorConfig.
 * Use `create(MultiVectorConfigSchema)` to create a new message.
 */
export const MultiVectorConfigSchema: GenMessage<MultiVectorConfig> = /*@__PURE__*/
  messageDesc(file_collections, 8);

/**
 * @generated from message qdrant.GetCollectionInfoRequest
 */
export type GetCollectionInfoRequest = Message<"qdrant.GetCollectionInfoRequest"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;
};

/**
 * Describes the message qdrant.GetCollectionInfoRequest.
 * Use `create(GetCollectionInfoRequestSchema)` to create a new message.
 */
export const GetCollectionInfoRequestSchema: GenMessage<GetCollectionInfoRequest> = /*@__PURE__*/
  messageDesc(file_collections, 9);

/**
 * @generated from message qdrant.CollectionExistsRequest
 */
export type CollectionExistsRequest = Message<"qdrant.CollectionExistsRequest"> & {
  /**
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;
};

/**
 * Describes the message qdrant.CollectionExistsRequest.
 * Use `create(CollectionExistsRequestSchema)` to create a new message.
 */
export const CollectionExistsRequestSchema: GenMessage<CollectionExistsRequest> = /*@__PURE__*/
  messageDesc(file_collections, 10);

/**
 * @generated from message qdrant.CollectionExists
 */
export type CollectionExists = Message<"qdrant.CollectionExists"> & {
  /**
   * @generated from field: bool exists = 1;
   */
  exists: boolean;
};

/**
 * Describes the message qdrant.CollectionExists.
 * Use `create(CollectionExistsSchema)` to create a new message.
 */
export const CollectionExistsSchema: GenMessage<CollectionExists> = /*@__PURE__*/
  messageDesc(file_collections, 11);

/**
 * @generated from message qdrant.CollectionExistsResponse
 */
export type CollectionExistsResponse = Message<"qdrant.CollectionExistsResponse"> & {
  /**
   * @generated from field: qdrant.CollectionExists result = 1;
   */
  result?: CollectionExists;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;
};

/**
 * Describes the message qdrant.CollectionExistsResponse.
 * Use `create(CollectionExistsResponseSchema)` to create a new message.
 */
export const CollectionExistsResponseSchema: GenMessage<CollectionExistsResponse> = /*@__PURE__*/
  messageDesc(file_collections, 12);

/**
 * @generated from message qdrant.ListCollectionsRequest
 */
export type ListCollectionsRequest = Message<"qdrant.ListCollectionsRequest"> & {
};

/**
 * Describes the message qdrant.ListCollectionsRequest.
 * Use `create(ListCollectionsRequestSchema)` to create a new message.
 */
export const ListCollectionsRequestSchema: GenMessage<ListCollectionsRequest> = /*@__PURE__*/
  messageDesc(file_collections, 13);

/**
 * @generated from message qdrant.CollectionDescription
 */
export type CollectionDescription = Message<"qdrant.CollectionDescription"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message qdrant.CollectionDescription.
 * Use `create(CollectionDescriptionSchema)` to create a new message.
 */
export const CollectionDescriptionSchema: GenMessage<CollectionDescription> = /*@__PURE__*/
  messageDesc(file_collections, 14);

/**
 * @generated from message qdrant.GetCollectionInfoResponse
 */
export type GetCollectionInfoResponse = Message<"qdrant.GetCollectionInfoResponse"> & {
  /**
   * @generated from field: qdrant.CollectionInfo result = 1;
   */
  result?: CollectionInfo;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;
};

/**
 * Describes the message qdrant.GetCollectionInfoResponse.
 * Use `create(GetCollectionInfoResponseSchema)` to create a new message.
 */
export const GetCollectionInfoResponseSchema: GenMessage<GetCollectionInfoResponse> = /*@__PURE__*/
  messageDesc(file_collections, 15);

/**
 * @generated from message qdrant.ListCollectionsResponse
 */
export type ListCollectionsResponse = Message<"qdrant.ListCollectionsResponse"> & {
  /**
   * @generated from field: repeated qdrant.CollectionDescription collections = 1;
   */
  collections: CollectionDescription[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;
};

/**
 * Describes the message qdrant.ListCollectionsResponse.
 * Use `create(ListCollectionsResponseSchema)` to create a new message.
 */
export const ListCollectionsResponseSchema: GenMessage<ListCollectionsResponse> = /*@__PURE__*/
  messageDesc(file_collections, 16);

/**
 * @generated from message qdrant.MaxOptimizationThreads
 */
export type MaxOptimizationThreads = Message<"qdrant.MaxOptimizationThreads"> & {
  /**
   * @generated from oneof qdrant.MaxOptimizationThreads.variant
   */
  variant: {
    /**
     * @generated from field: uint64 value = 1;
     */
    value: bigint;
    case: "value";
  } | {
    /**
     * @generated from field: qdrant.MaxOptimizationThreads.Setting setting = 2;
     */
    value: MaxOptimizationThreads_Setting;
    case: "setting";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.MaxOptimizationThreads.
 * Use `create(MaxOptimizationThreadsSchema)` to create a new message.
 */
export const MaxOptimizationThreadsSchema: GenMessage<MaxOptimizationThreads> = /*@__PURE__*/
  messageDesc(file_collections, 17);

/**
 * @generated from enum qdrant.MaxOptimizationThreads.Setting
 */
export enum MaxOptimizationThreads_Setting {
  /**
   * @generated from enum value: Auto = 0;
   */
  Auto = 0,
}

/**
 * Describes the enum qdrant.MaxOptimizationThreads.Setting.
 */
export const MaxOptimizationThreads_SettingSchema: GenEnum<MaxOptimizationThreads_Setting> = /*@__PURE__*/
  enumDesc(file_collections, 17, 0);

/**
 * @generated from message qdrant.OptimizerStatus
 */
export type OptimizerStatus = Message<"qdrant.OptimizerStatus"> & {
  /**
   * @generated from field: bool ok = 1;
   */
  ok: boolean;

  /**
   * @generated from field: string error = 2;
   */
  error: string;
};

/**
 * Describes the message qdrant.OptimizerStatus.
 * Use `create(OptimizerStatusSchema)` to create a new message.
 */
export const OptimizerStatusSchema: GenMessage<OptimizerStatus> = /*@__PURE__*/
  messageDesc(file_collections, 18);

/**
 * @generated from message qdrant.CollectionWarning
 */
export type CollectionWarning = Message<"qdrant.CollectionWarning"> & {
  /**
   * @generated from field: string message = 1;
   */
  message: string;
};

/**
 * Describes the message qdrant.CollectionWarning.
 * Use `create(CollectionWarningSchema)` to create a new message.
 */
export const CollectionWarningSchema: GenMessage<CollectionWarning> = /*@__PURE__*/
  messageDesc(file_collections, 19);

/**
 * @generated from message qdrant.HnswConfigDiff
 */
export type HnswConfigDiff = Message<"qdrant.HnswConfigDiff"> & {
  /**
   *
   * Number of edges per node in the index graph. Larger the value - more accurate the search, more space required.
   *
   * @generated from field: optional uint64 m = 1;
   */
  m?: bigint;

  /**
   *
   * Number of neighbours to consider during the index building. Larger the value - more accurate the search, more time required to build the index.
   *
   * @generated from field: optional uint64 ef_construct = 2;
   */
  efConstruct?: bigint;

  /**
   *
   * Minimal size threshold (in KiloBytes) below which full-scan is preferred over HNSW search.
   * This measures the total size of vectors being queried against.
   * When the maximum estimated amount of points that a condition satisfies is smaller than
   * `full_scan_threshold`, the query planner will use full-scan search instead of HNSW index
   * traversal for better performance.
   * Note: 1Kb = 1 vector of size 256
   *
   * @generated from field: optional uint64 full_scan_threshold = 3;
   */
  fullScanThreshold?: bigint;

  /**
   *
   * Number of parallel threads used for background index building.
   * If 0 - automatically select from 8 to 16.
   * Best to keep between 8 and 16 to prevent likelihood of building broken/inefficient HNSW graphs.
   * On small CPUs, less threads are used.
   *
   * @generated from field: optional uint64 max_indexing_threads = 4;
   */
  maxIndexingThreads?: bigint;

  /**
   *
   * Store HNSW index on disk. If set to false, the index will be stored in RAM.
   *
   * @generated from field: optional bool on_disk = 5;
   */
  onDisk?: boolean;

  /**
   *
   * Number of additional payload-aware links per node in the index graph. If not set - regular M parameter will be used.
   *
   * @generated from field: optional uint64 payload_m = 6;
   */
  payloadM?: bigint;

  /**
   *
   * Store copies of original and quantized vectors within the HNSW index file. Default: false.
   * Enabling this option will trade the search speed for disk usage by reducing amount of
   * random seeks during the search.
   * Requires quantized vectors to be enabled. Multi-vectors are not supported.
   *
   * @generated from field: optional bool inline_storage = 7;
   */
  inlineStorage?: boolean;
};

/**
 * Describes the message qdrant.HnswConfigDiff.
 * Use `create(HnswConfigDiffSchema)` to create a new message.
 */
export const HnswConfigDiffSchema: GenMessage<HnswConfigDiff> = /*@__PURE__*/
  messageDesc(file_collections, 20);

/**
 * @generated from message qdrant.SparseIndexConfig
 */
export type SparseIndexConfig = Message<"qdrant.SparseIndexConfig"> & {
  /**
   *
   * Prefer a full scan search upto (excluding) this number of vectors.
   * Note: this is number of vectors, not KiloBytes.
   *
   * @generated from field: optional uint64 full_scan_threshold = 1;
   */
  fullScanThreshold?: bigint;

  /**
   *
   * Store inverted index on disk. If set to false, the index will be stored in RAM.
   *
   * @generated from field: optional bool on_disk = 2;
   */
  onDisk?: boolean;

  /**
   *
   * Datatype used to store weights in the index.
   *
   * @generated from field: optional qdrant.Datatype datatype = 3;
   */
  datatype?: Datatype;
};

/**
 * Describes the message qdrant.SparseIndexConfig.
 * Use `create(SparseIndexConfigSchema)` to create a new message.
 */
export const SparseIndexConfigSchema: GenMessage<SparseIndexConfig> = /*@__PURE__*/
  messageDesc(file_collections, 21);

/**
 * @generated from message qdrant.WalConfigDiff
 */
export type WalConfigDiff = Message<"qdrant.WalConfigDiff"> & {
  /**
   * Size of a single WAL block file
   *
   * @generated from field: optional uint64 wal_capacity_mb = 1;
   */
  walCapacityMb?: bigint;

  /**
   * Number of segments to create in advance
   *
   * @generated from field: optional uint64 wal_segments_ahead = 2;
   */
  walSegmentsAhead?: bigint;

  /**
   * Number of closed segments to retain
   *
   * @generated from field: optional uint64 wal_retain_closed = 3;
   */
  walRetainClosed?: bigint;
};

/**
 * Describes the message qdrant.WalConfigDiff.
 * Use `create(WalConfigDiffSchema)` to create a new message.
 */
export const WalConfigDiffSchema: GenMessage<WalConfigDiff> = /*@__PURE__*/
  messageDesc(file_collections, 22);

/**
 * @generated from message qdrant.OptimizersConfigDiff
 */
export type OptimizersConfigDiff = Message<"qdrant.OptimizersConfigDiff"> & {
  /**
   *
   * The minimal fraction of deleted vectors in a segment, required to perform segment optimization
   *
   * @generated from field: optional double deleted_threshold = 1;
   */
  deletedThreshold?: number;

  /**
   *
   * The minimal number of vectors in a segment, required to perform segment optimization
   *
   * @generated from field: optional uint64 vacuum_min_vector_number = 2;
   */
  vacuumMinVectorNumber?: bigint;

  /**
   *
   * Target amount of segments the optimizer will try to keep.
   * Real amount of segments may vary depending on multiple parameters:
   *
   * - Amount of stored points.
   * - Current write RPS.
   *
   * It is recommended to select the default number of segments as a factor of the number of search threads,
   * so that each segment would be handled evenly by one of the threads.
   *
   * @generated from field: optional uint64 default_segment_number = 3;
   */
  defaultSegmentNumber?: bigint;

  /**
   *
   * Deprecated:
   *
   * Do not create segments larger this size (in kilobytes).
   * Large segments might require disproportionately long indexation times,
   * therefore it makes sense to limit the size of segments.
   *
   * If indexing speed is more important - make this parameter lower.
   * If search speed is more important - make this parameter higher.
   * Note: 1Kb = 1 vector of size 256
   * If not set, will be automatically selected considering the number of available CPUs.
   *
   * @generated from field: optional uint64 max_segment_size = 4;
   */
  maxSegmentSize?: bigint;

  /**
   *
   * Maximum size (in kilobytes) of vectors to store in-memory per segment.
   * Segments larger than this threshold will be stored as read-only memmapped file.
   *
   * Memmap storage is disabled by default, to enable it, set this threshold to a reasonable value.
   *
   * To disable memmap storage, set this to `0`.
   *
   * Note: 1Kb = 1 vector of size 256
   *
   * @generated from field: optional uint64 memmap_threshold = 5;
   */
  memmapThreshold?: bigint;

  /**
   *
   * Maximum size (in kilobytes) of vectors allowed for plain index, exceeding this threshold will enable vector indexing
   *
   * Default value is 20,000, based on <https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md>.
   *
   * To disable vector indexing, set to `0`.
   *
   * Note: 1kB = 1 vector of size 256.
   *
   * @generated from field: optional uint64 indexing_threshold = 6;
   */
  indexingThreshold?: bigint;

  /**
   *
   * Interval between forced flushes.
   *
   * @generated from field: optional uint64 flush_interval_sec = 7;
   */
  flushIntervalSec?: bigint;

  /**
   * Deprecated in favor of `max_optimization_threads`
   *
   * @generated from field: optional uint64 deprecated_max_optimization_threads = 8;
   */
  deprecatedMaxOptimizationThreads?: bigint;

  /**
   *
   * Max number of threads (jobs) for running optimizations per shard.
   * Note: each optimization job will also use `max_indexing_threads` threads by itself for index building.
   * If "auto" - have no limit and choose dynamically to saturate CPU.
   * If 0 - no optimization threads, optimizations will be disabled.
   *
   * @generated from field: optional qdrant.MaxOptimizationThreads max_optimization_threads = 9;
   */
  maxOptimizationThreads?: MaxOptimizationThreads;
};

/**
 * Describes the message qdrant.OptimizersConfigDiff.
 * Use `create(OptimizersConfigDiffSchema)` to create a new message.
 */
export const OptimizersConfigDiffSchema: GenMessage<OptimizersConfigDiff> = /*@__PURE__*/
  messageDesc(file_collections, 23);

/**
 * @generated from message qdrant.ScalarQuantization
 */
export type ScalarQuantization = Message<"qdrant.ScalarQuantization"> & {
  /**
   * Type of quantization
   *
   * @generated from field: qdrant.QuantizationType type = 1;
   */
  type: QuantizationType;

  /**
   * Number of bits to use for quantization
   *
   * @generated from field: optional float quantile = 2;
   */
  quantile?: number;

  /**
   * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
   *
   * @generated from field: optional bool always_ram = 3;
   */
  alwaysRam?: boolean;
};

/**
 * Describes the message qdrant.ScalarQuantization.
 * Use `create(ScalarQuantizationSchema)` to create a new message.
 */
export const ScalarQuantizationSchema: GenMessage<ScalarQuantization> = /*@__PURE__*/
  messageDesc(file_collections, 24);

/**
 * @generated from message qdrant.ProductQuantization
 */
export type ProductQuantization = Message<"qdrant.ProductQuantization"> & {
  /**
   * Compression ratio
   *
   * @generated from field: qdrant.CompressionRatio compression = 1;
   */
  compression: CompressionRatio;

  /**
   * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
   *
   * @generated from field: optional bool always_ram = 2;
   */
  alwaysRam?: boolean;
};

/**
 * Describes the message qdrant.ProductQuantization.
 * Use `create(ProductQuantizationSchema)` to create a new message.
 */
export const ProductQuantizationSchema: GenMessage<ProductQuantization> = /*@__PURE__*/
  messageDesc(file_collections, 25);

/**
 * @generated from message qdrant.BinaryQuantizationQueryEncoding
 */
export type BinaryQuantizationQueryEncoding = Message<"qdrant.BinaryQuantizationQueryEncoding"> & {
  /**
   * @generated from oneof qdrant.BinaryQuantizationQueryEncoding.variant
   */
  variant: {
    /**
     * @generated from field: qdrant.BinaryQuantizationQueryEncoding.Setting setting = 4;
     */
    value: BinaryQuantizationQueryEncoding_Setting;
    case: "setting";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.BinaryQuantizationQueryEncoding.
 * Use `create(BinaryQuantizationQueryEncodingSchema)` to create a new message.
 */
export const BinaryQuantizationQueryEncodingSchema: GenMessage<BinaryQuantizationQueryEncoding> = /*@__PURE__*/
  messageDesc(file_collections, 26);

/**
 * @generated from enum qdrant.BinaryQuantizationQueryEncoding.Setting
 */
export enum BinaryQuantizationQueryEncoding_Setting {
  /**
   * @generated from enum value: Default = 0;
   */
  Default = 0,

  /**
   * @generated from enum value: Binary = 1;
   */
  Binary = 1,

  /**
   * @generated from enum value: Scalar4Bits = 2;
   */
  Scalar4Bits = 2,

  /**
   * @generated from enum value: Scalar8Bits = 3;
   */
  Scalar8Bits = 3,
}

/**
 * Describes the enum qdrant.BinaryQuantizationQueryEncoding.Setting.
 */
export const BinaryQuantizationQueryEncoding_SettingSchema: GenEnum<BinaryQuantizationQueryEncoding_Setting> = /*@__PURE__*/
  enumDesc(file_collections, 26, 0);

/**
 * @generated from message qdrant.BinaryQuantization
 */
export type BinaryQuantization = Message<"qdrant.BinaryQuantization"> & {
  /**
   * If true - quantized vectors always will be stored in RAM, ignoring the config of main storage
   *
   * @generated from field: optional bool always_ram = 1;
   */
  alwaysRam?: boolean;

  /**
   * Binary quantization encoding method
   *
   * @generated from field: optional qdrant.BinaryQuantizationEncoding encoding = 2;
   */
  encoding?: BinaryQuantizationEncoding;

  /**
   *
   * Asymmetric quantization configuration allows a query to have different quantization than stored vectors.
   * It can increase the accuracy of search at the cost of performance.
   *
   * @generated from field: optional qdrant.BinaryQuantizationQueryEncoding query_encoding = 3;
   */
  queryEncoding?: BinaryQuantizationQueryEncoding;
};

/**
 * Describes the message qdrant.BinaryQuantization.
 * Use `create(BinaryQuantizationSchema)` to create a new message.
 */
export const BinaryQuantizationSchema: GenMessage<BinaryQuantization> = /*@__PURE__*/
  messageDesc(file_collections, 27);

/**
 * @generated from message qdrant.QuantizationConfig
 */
export type QuantizationConfig = Message<"qdrant.QuantizationConfig"> & {
  /**
   * @generated from oneof qdrant.QuantizationConfig.quantization
   */
  quantization: {
    /**
     * @generated from field: qdrant.ScalarQuantization scalar = 1;
     */
    value: ScalarQuantization;
    case: "scalar";
  } | {
    /**
     * @generated from field: qdrant.ProductQuantization product = 2;
     */
    value: ProductQuantization;
    case: "product";
  } | {
    /**
     * @generated from field: qdrant.BinaryQuantization binary = 3;
     */
    value: BinaryQuantization;
    case: "binary";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.QuantizationConfig.
 * Use `create(QuantizationConfigSchema)` to create a new message.
 */
export const QuantizationConfigSchema: GenMessage<QuantizationConfig> = /*@__PURE__*/
  messageDesc(file_collections, 28);

/**
 * @generated from message qdrant.Disabled
 */
export type Disabled = Message<"qdrant.Disabled"> & {
};

/**
 * Describes the message qdrant.Disabled.
 * Use `create(DisabledSchema)` to create a new message.
 */
export const DisabledSchema: GenMessage<Disabled> = /*@__PURE__*/
  messageDesc(file_collections, 29);

/**
 * @generated from message qdrant.QuantizationConfigDiff
 */
export type QuantizationConfigDiff = Message<"qdrant.QuantizationConfigDiff"> & {
  /**
   * @generated from oneof qdrant.QuantizationConfigDiff.quantization
   */
  quantization: {
    /**
     * @generated from field: qdrant.ScalarQuantization scalar = 1;
     */
    value: ScalarQuantization;
    case: "scalar";
  } | {
    /**
     * @generated from field: qdrant.ProductQuantization product = 2;
     */
    value: ProductQuantization;
    case: "product";
  } | {
    /**
     * @generated from field: qdrant.Disabled disabled = 3;
     */
    value: Disabled;
    case: "disabled";
  } | {
    /**
     * @generated from field: qdrant.BinaryQuantization binary = 4;
     */
    value: BinaryQuantization;
    case: "binary";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.QuantizationConfigDiff.
 * Use `create(QuantizationConfigDiffSchema)` to create a new message.
 */
export const QuantizationConfigDiffSchema: GenMessage<QuantizationConfigDiff> = /*@__PURE__*/
  messageDesc(file_collections, 30);

/**
 * @generated from message qdrant.StrictModeConfig
 */
export type StrictModeConfig = Message<"qdrant.StrictModeConfig"> & {
  /**
   * Whether strict mode is enabled for a collection or not.
   *
   * @generated from field: optional bool enabled = 1;
   */
  enabled?: boolean;

  /**
   * Max allowed `limit` parameter for all APIs that don't have their own max limit.
   *
   * @generated from field: optional uint32 max_query_limit = 2;
   */
  maxQueryLimit?: number;

  /**
   * Max allowed `timeout` parameter.
   *
   * @generated from field: optional uint32 max_timeout = 3;
   */
  maxTimeout?: number;

  /**
   * Allow usage of unindexed fields in retrieval based (e.g. search) filters.
   *
   * @generated from field: optional bool unindexed_filtering_retrieve = 4;
   */
  unindexedFilteringRetrieve?: boolean;

  /**
   * Allow usage of unindexed fields in filtered updates (e.g. delete by payload).
   *
   * @generated from field: optional bool unindexed_filtering_update = 5;
   */
  unindexedFilteringUpdate?: boolean;

  /**
   * Max HNSW ef value allowed in search parameters.
   *
   * @generated from field: optional uint32 search_max_hnsw_ef = 6;
   */
  searchMaxHnswEf?: number;

  /**
   * Whether exact search is allowed.
   *
   * @generated from field: optional bool search_allow_exact = 7;
   */
  searchAllowExact?: boolean;

  /**
   * Max oversampling value allowed in search
   *
   * @generated from field: optional float search_max_oversampling = 8;
   */
  searchMaxOversampling?: number;

  /**
   * Max batchsize when upserting
   *
   * @generated from field: optional uint64 upsert_max_batchsize = 9;
   */
  upsertMaxBatchsize?: bigint;

  /**
   * Max size of a collections vector storage in bytes, ignoring replicas.
   *
   * @generated from field: optional uint64 max_collection_vector_size_bytes = 10;
   */
  maxCollectionVectorSizeBytes?: bigint;

  /**
   * Max number of read operations per minute per replica
   *
   * @generated from field: optional uint32 read_rate_limit = 11;
   */
  readRateLimit?: number;

  /**
   * Max number of write operations per minute per replica
   *
   * @generated from field: optional uint32 write_rate_limit = 12;
   */
  writeRateLimit?: number;

  /**
   * Max size of a collections payload storage in bytes, ignoring replicas.
   *
   * @generated from field: optional uint64 max_collection_payload_size_bytes = 13;
   */
  maxCollectionPayloadSizeBytes?: bigint;

  /**
   * Max conditions a filter can have.
   *
   * @generated from field: optional uint64 filter_max_conditions = 14;
   */
  filterMaxConditions?: bigint;

  /**
   * Max size of a condition, eg. items in `MatchAny`.
   *
   * @generated from field: optional uint64 condition_max_size = 15;
   */
  conditionMaxSize?: bigint;

  /**
   * Multivector strict mode configuration
   *
   * @generated from field: optional qdrant.StrictModeMultivectorConfig multivector_config = 16;
   */
  multivectorConfig?: StrictModeMultivectorConfig;

  /**
   * Sparse vector strict mode configuration
   *
   * @generated from field: optional qdrant.StrictModeSparseConfig sparse_config = 17;
   */
  sparseConfig?: StrictModeSparseConfig;

  /**
   * Max number of points estimated in a collection
   *
   * @generated from field: optional uint64 max_points_count = 18;
   */
  maxPointsCount?: bigint;

  /**
   * Max number of payload indexes in a collection
   *
   * @generated from field: optional uint64 max_payload_index_count = 19;
   */
  maxPayloadIndexCount?: bigint;
};

/**
 * Describes the message qdrant.StrictModeConfig.
 * Use `create(StrictModeConfigSchema)` to create a new message.
 */
export const StrictModeConfigSchema: GenMessage<StrictModeConfig> = /*@__PURE__*/
  messageDesc(file_collections, 31);

/**
 * @generated from message qdrant.StrictModeSparseConfig
 */
export type StrictModeSparseConfig = Message<"qdrant.StrictModeSparseConfig"> & {
  /**
   * @generated from field: map<string, qdrant.StrictModeSparse> sparse_config = 1;
   */
  sparseConfig: { [key: string]: StrictModeSparse };
};

/**
 * Describes the message qdrant.StrictModeSparseConfig.
 * Use `create(StrictModeSparseConfigSchema)` to create a new message.
 */
export const StrictModeSparseConfigSchema: GenMessage<StrictModeSparseConfig> = /*@__PURE__*/
  messageDesc(file_collections, 32);

/**
 * @generated from message qdrant.StrictModeSparse
 */
export type StrictModeSparse = Message<"qdrant.StrictModeSparse"> & {
  /**
   * Max length of sparse vector
   *
   * @generated from field: optional uint64 max_length = 10;
   */
  maxLength?: bigint;
};

/**
 * Describes the message qdrant.StrictModeSparse.
 * Use `create(StrictModeSparseSchema)` to create a new message.
 */
export const StrictModeSparseSchema: GenMessage<StrictModeSparse> = /*@__PURE__*/
  messageDesc(file_collections, 33);

/**
 * @generated from message qdrant.StrictModeMultivectorConfig
 */
export type StrictModeMultivectorConfig = Message<"qdrant.StrictModeMultivectorConfig"> & {
  /**
   * @generated from field: map<string, qdrant.StrictModeMultivector> multivector_config = 1;
   */
  multivectorConfig: { [key: string]: StrictModeMultivector };
};

/**
 * Describes the message qdrant.StrictModeMultivectorConfig.
 * Use `create(StrictModeMultivectorConfigSchema)` to create a new message.
 */
export const StrictModeMultivectorConfigSchema: GenMessage<StrictModeMultivectorConfig> = /*@__PURE__*/
  messageDesc(file_collections, 34);

/**
 * @generated from message qdrant.StrictModeMultivector
 */
export type StrictModeMultivector = Message<"qdrant.StrictModeMultivector"> & {
  /**
   * Max number of vectors in a multivector
   *
   * @generated from field: optional uint64 max_vectors = 1;
   */
  maxVectors?: bigint;
};

/**
 * Describes the message qdrant.StrictModeMultivector.
 * Use `create(StrictModeMultivectorSchema)` to create a new message.
 */
export const StrictModeMultivectorSchema: GenMessage<StrictModeMultivector> = /*@__PURE__*/
  messageDesc(file_collections, 35);

/**
 * @generated from message qdrant.CreateCollection
 */
export type CreateCollection = Message<"qdrant.CreateCollection"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Configuration of vector index
   *
   * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 4;
   */
  hnswConfig?: HnswConfigDiff;

  /**
   * Configuration of the Write-Ahead-Log
   *
   * @generated from field: optional qdrant.WalConfigDiff wal_config = 5;
   */
  walConfig?: WalConfigDiff;

  /**
   * Configuration of the optimizers
   *
   * @generated from field: optional qdrant.OptimizersConfigDiff optimizers_config = 6;
   */
  optimizersConfig?: OptimizersConfigDiff;

  /**
   * Number of shards in the collection, default is 1 for standalone, otherwise equal to the number of nodes. Minimum is 1
   *
   * @generated from field: optional uint32 shard_number = 7;
   */
  shardNumber?: number;

  /**
   * If true - point's payload will not be stored in memory
   *
   * @generated from field: optional bool on_disk_payload = 8;
   */
  onDiskPayload?: boolean;

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 9;
   */
  timeout?: bigint;

  /**
   * Configuration for vectors
   *
   * @generated from field: optional qdrant.VectorsConfig vectors_config = 10;
   */
  vectorsConfig?: VectorsConfig;

  /**
   * Number of replicas of each shard that network tries to maintain, default = 1
   *
   * @generated from field: optional uint32 replication_factor = 11;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful, default = 1
   *
   * @generated from field: optional uint32 write_consistency_factor = 12;
   */
  writeConsistencyFactor?: number;

  /**
   * Quantization configuration of vector
   *
   * @generated from field: optional qdrant.QuantizationConfig quantization_config = 14;
   */
  quantizationConfig?: QuantizationConfig;

  /**
   * Sharding method
   *
   * @generated from field: optional qdrant.ShardingMethod sharding_method = 15;
   */
  shardingMethod?: ShardingMethod;

  /**
   * Configuration for sparse vectors
   *
   * @generated from field: optional qdrant.SparseVectorConfig sparse_vectors_config = 16;
   */
  sparseVectorsConfig?: SparseVectorConfig;

  /**
   * Configuration for strict mode
   *
   * @generated from field: optional qdrant.StrictModeConfig strict_mode_config = 17;
   */
  strictModeConfig?: StrictModeConfig;

  /**
   * Arbitrary JSON metadata for the collection
   *
   * @generated from field: map<string, qdrant.Value> metadata = 18;
   */
  metadata: { [key: string]: Value };
};

/**
 * Describes the message qdrant.CreateCollection.
 * Use `create(CreateCollectionSchema)` to create a new message.
 */
export const CreateCollectionSchema: GenMessage<CreateCollection> = /*@__PURE__*/
  messageDesc(file_collections, 36);

/**
 * @generated from message qdrant.UpdateCollection
 */
export type UpdateCollection = Message<"qdrant.UpdateCollection"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * New configuration parameters for the collection. This operation is blocking, it will only proceed once all current optimizations are complete
   *
   * @generated from field: optional qdrant.OptimizersConfigDiff optimizers_config = 2;
   */
  optimizersConfig?: OptimizersConfigDiff;

  /**
   * Wait timeout for operation commit in seconds if blocking, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 3;
   */
  timeout?: bigint;

  /**
   * New configuration parameters for the collection
   *
   * @generated from field: optional qdrant.CollectionParamsDiff params = 4;
   */
  params?: CollectionParamsDiff;

  /**
   * New HNSW parameters for the collection index
   *
   * @generated from field: optional qdrant.HnswConfigDiff hnsw_config = 5;
   */
  hnswConfig?: HnswConfigDiff;

  /**
   * New vector parameters
   *
   * @generated from field: optional qdrant.VectorsConfigDiff vectors_config = 6;
   */
  vectorsConfig?: VectorsConfigDiff;

  /**
   * Quantization configuration of vector
   *
   * @generated from field: optional qdrant.QuantizationConfigDiff quantization_config = 7;
   */
  quantizationConfig?: QuantizationConfigDiff;

  /**
   * New sparse vector parameters
   *
   * @generated from field: optional qdrant.SparseVectorConfig sparse_vectors_config = 8;
   */
  sparseVectorsConfig?: SparseVectorConfig;

  /**
   * New strict mode configuration
   *
   * @generated from field: optional qdrant.StrictModeConfig strict_mode_config = 9;
   */
  strictModeConfig?: StrictModeConfig;

  /**
   * Arbitrary JSON-like metadata for the collection, will be merged with already stored metadata
   *
   * @generated from field: map<string, qdrant.Value> metadata = 10;
   */
  metadata: { [key: string]: Value };
};

/**
 * Describes the message qdrant.UpdateCollection.
 * Use `create(UpdateCollectionSchema)` to create a new message.
 */
export const UpdateCollectionSchema: GenMessage<UpdateCollection> = /*@__PURE__*/
  messageDesc(file_collections, 37);

/**
 * @generated from message qdrant.DeleteCollection
 */
export type DeleteCollection = Message<"qdrant.DeleteCollection"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 2;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.DeleteCollection.
 * Use `create(DeleteCollectionSchema)` to create a new message.
 */
export const DeleteCollectionSchema: GenMessage<DeleteCollection> = /*@__PURE__*/
  messageDesc(file_collections, 38);

/**
 * @generated from message qdrant.CollectionOperationResponse
 */
export type CollectionOperationResponse = Message<"qdrant.CollectionOperationResponse"> & {
  /**
   * if operation made changes
   *
   * @generated from field: bool result = 1;
   */
  result: boolean;

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;
};

/**
 * Describes the message qdrant.CollectionOperationResponse.
 * Use `create(CollectionOperationResponseSchema)` to create a new message.
 */
export const CollectionOperationResponseSchema: GenMessage<CollectionOperationResponse> = /*@__PURE__*/
  messageDesc(file_collections, 39);

/**
 * @generated from message qdrant.CollectionParams
 */
export type CollectionParams = Message<"qdrant.CollectionParams"> & {
  /**
   * Number of shards in collection
   *
   * @generated from field: uint32 shard_number = 3;
   */
  shardNumber: number;

  /**
   * If true - point's payload will not be stored in memory
   *
   * @generated from field: bool on_disk_payload = 4;
   */
  onDiskPayload: boolean;

  /**
   * Configuration for vectors
   *
   * @generated from field: optional qdrant.VectorsConfig vectors_config = 5;
   */
  vectorsConfig?: VectorsConfig;

  /**
   * Number of replicas of each shard that network tries to maintain
   *
   * @generated from field: optional uint32 replication_factor = 6;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   *
   * @generated from field: optional uint32 write_consistency_factor = 7;
   */
  writeConsistencyFactor?: number;

  /**
   * Fan-out every read request to these many additional remote nodes (and return first available response)
   *
   * @generated from field: optional uint32 read_fan_out_factor = 8;
   */
  readFanOutFactor?: number;

  /**
   * Sharding method
   *
   * @generated from field: optional qdrant.ShardingMethod sharding_method = 9;
   */
  shardingMethod?: ShardingMethod;

  /**
   * Configuration for sparse vectors
   *
   * @generated from field: optional qdrant.SparseVectorConfig sparse_vectors_config = 10;
   */
  sparseVectorsConfig?: SparseVectorConfig;
};

/**
 * Describes the message qdrant.CollectionParams.
 * Use `create(CollectionParamsSchema)` to create a new message.
 */
export const CollectionParamsSchema: GenMessage<CollectionParams> = /*@__PURE__*/
  messageDesc(file_collections, 40);

/**
 * @generated from message qdrant.CollectionParamsDiff
 */
export type CollectionParamsDiff = Message<"qdrant.CollectionParamsDiff"> & {
  /**
   * Number of replicas of each shard that network tries to maintain
   *
   * @generated from field: optional uint32 replication_factor = 1;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   *
   * @generated from field: optional uint32 write_consistency_factor = 2;
   */
  writeConsistencyFactor?: number;

  /**
   * If true - point's payload will not be stored in memory
   *
   * @generated from field: optional bool on_disk_payload = 3;
   */
  onDiskPayload?: boolean;

  /**
   * Fan-out every read request to these many additional remote nodes (and return first available response)
   *
   * @generated from field: optional uint32 read_fan_out_factor = 4;
   */
  readFanOutFactor?: number;
};

/**
 * Describes the message qdrant.CollectionParamsDiff.
 * Use `create(CollectionParamsDiffSchema)` to create a new message.
 */
export const CollectionParamsDiffSchema: GenMessage<CollectionParamsDiff> = /*@__PURE__*/
  messageDesc(file_collections, 41);

/**
 * @generated from message qdrant.CollectionConfig
 */
export type CollectionConfig = Message<"qdrant.CollectionConfig"> & {
  /**
   * Collection parameters
   *
   * @generated from field: qdrant.CollectionParams params = 1;
   */
  params?: CollectionParams;

  /**
   * Configuration of vector index
   *
   * @generated from field: qdrant.HnswConfigDiff hnsw_config = 2;
   */
  hnswConfig?: HnswConfigDiff;

  /**
   * Configuration of the optimizers
   *
   * @generated from field: qdrant.OptimizersConfigDiff optimizer_config = 3;
   */
  optimizerConfig?: OptimizersConfigDiff;

  /**
   * Configuration of the Write-Ahead-Log
   *
   * @generated from field: qdrant.WalConfigDiff wal_config = 4;
   */
  walConfig?: WalConfigDiff;

  /**
   * Configuration of the vector quantization
   *
   * @generated from field: optional qdrant.QuantizationConfig quantization_config = 5;
   */
  quantizationConfig?: QuantizationConfig;

  /**
   * Configuration of strict mode.
   *
   * @generated from field: optional qdrant.StrictModeConfig strict_mode_config = 6;
   */
  strictModeConfig?: StrictModeConfig;

  /**
   * Arbitrary JSON metadata for the collection
   *
   * @generated from field: map<string, qdrant.Value> metadata = 7;
   */
  metadata: { [key: string]: Value };
};

/**
 * Describes the message qdrant.CollectionConfig.
 * Use `create(CollectionConfigSchema)` to create a new message.
 */
export const CollectionConfigSchema: GenMessage<CollectionConfig> = /*@__PURE__*/
  messageDesc(file_collections, 42);

/**
 * @generated from message qdrant.KeywordIndexParams
 */
export type KeywordIndexParams = Message<"qdrant.KeywordIndexParams"> & {
  /**
   * If true - used for tenant optimization.
   *
   * @generated from field: optional bool is_tenant = 1;
   */
  isTenant?: boolean;

  /**
   * If true - store index on disk.
   *
   * @generated from field: optional bool on_disk = 2;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.KeywordIndexParams.
 * Use `create(KeywordIndexParamsSchema)` to create a new message.
 */
export const KeywordIndexParamsSchema: GenMessage<KeywordIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 43);

/**
 * @generated from message qdrant.IntegerIndexParams
 */
export type IntegerIndexParams = Message<"qdrant.IntegerIndexParams"> & {
  /**
   * If true - support direct lookups. Default is true.
   *
   * @generated from field: optional bool lookup = 1;
   */
  lookup?: boolean;

  /**
   * If true - support ranges filters. Default is true.
   *
   * @generated from field: optional bool range = 2;
   */
  range?: boolean;

  /**
   * If true - use this key to organize storage of the collection data. This option assumes that this key will be used in majority of filtered requests. Default is false.
   *
   * @generated from field: optional bool is_principal = 3;
   */
  isPrincipal?: boolean;

  /**
   * If true - store index on disk. Default is false.
   *
   * @generated from field: optional bool on_disk = 4;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.IntegerIndexParams.
 * Use `create(IntegerIndexParamsSchema)` to create a new message.
 */
export const IntegerIndexParamsSchema: GenMessage<IntegerIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 44);

/**
 * @generated from message qdrant.FloatIndexParams
 */
export type FloatIndexParams = Message<"qdrant.FloatIndexParams"> & {
  /**
   * If true - store index on disk.
   *
   * @generated from field: optional bool on_disk = 1;
   */
  onDisk?: boolean;

  /**
   * If true - use this key to organize storage of the collection data. This option assumes that this key will be used in majority of filtered requests.
   *
   * @generated from field: optional bool is_principal = 2;
   */
  isPrincipal?: boolean;
};

/**
 * Describes the message qdrant.FloatIndexParams.
 * Use `create(FloatIndexParamsSchema)` to create a new message.
 */
export const FloatIndexParamsSchema: GenMessage<FloatIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 45);

/**
 * @generated from message qdrant.GeoIndexParams
 */
export type GeoIndexParams = Message<"qdrant.GeoIndexParams"> & {
  /**
   * If true - store index on disk.
   *
   * @generated from field: optional bool on_disk = 1;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.GeoIndexParams.
 * Use `create(GeoIndexParamsSchema)` to create a new message.
 */
export const GeoIndexParamsSchema: GenMessage<GeoIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 46);

/**
 * @generated from message qdrant.StopwordsSet
 */
export type StopwordsSet = Message<"qdrant.StopwordsSet"> & {
  /**
   * List of languages to use stopwords from
   *
   * @generated from field: repeated string languages = 1;
   */
  languages: string[];

  /**
   * List of custom stopwords
   *
   * @generated from field: repeated string custom = 2;
   */
  custom: string[];
};

/**
 * Describes the message qdrant.StopwordsSet.
 * Use `create(StopwordsSetSchema)` to create a new message.
 */
export const StopwordsSetSchema: GenMessage<StopwordsSet> = /*@__PURE__*/
  messageDesc(file_collections, 47);

/**
 * @generated from message qdrant.TextIndexParams
 */
export type TextIndexParams = Message<"qdrant.TextIndexParams"> & {
  /**
   * Tokenizer type
   *
   * @generated from field: qdrant.TokenizerType tokenizer = 1;
   */
  tokenizer: TokenizerType;

  /**
   * If true - all tokens will be lowercase
   *
   * @generated from field: optional bool lowercase = 2;
   */
  lowercase?: boolean;

  /**
   * Minimal token length
   *
   * @generated from field: optional uint64 min_token_len = 3;
   */
  minTokenLen?: bigint;

  /**
   * Maximal token length
   *
   * @generated from field: optional uint64 max_token_len = 4;
   */
  maxTokenLen?: bigint;

  /**
   * If true - store index on disk.
   *
   * @generated from field: optional bool on_disk = 5;
   */
  onDisk?: boolean;

  /**
   * Stopwords for the text index
   *
   * @generated from field: optional qdrant.StopwordsSet stopwords = 6;
   */
  stopwords?: StopwordsSet;

  /**
   * If true - support phrase matching.
   *
   * @generated from field: optional bool phrase_matching = 7;
   */
  phraseMatching?: boolean;

  /**
   * Set an algorithm for stemming.
   *
   * @generated from field: optional qdrant.StemmingAlgorithm stemmer = 8;
   */
  stemmer?: StemmingAlgorithm;

  /**
   * If true, normalize tokens by folding accented characters to ASCII (e.g., "ao" -> "acao"). Default: false.
   *
   * @generated from field: optional bool ascii_folding = 9;
   */
  asciiFolding?: boolean;
};

/**
 * Describes the message qdrant.TextIndexParams.
 * Use `create(TextIndexParamsSchema)` to create a new message.
 */
export const TextIndexParamsSchema: GenMessage<TextIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 48);

/**
 * @generated from message qdrant.StemmingAlgorithm
 */
export type StemmingAlgorithm = Message<"qdrant.StemmingAlgorithm"> & {
  /**
   * @generated from oneof qdrant.StemmingAlgorithm.stemming_params
   */
  stemmingParams: {
    /**
     * Parameters for snowball stemming
     *
     * @generated from field: qdrant.SnowballParams snowball = 1;
     */
    value: SnowballParams;
    case: "snowball";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.StemmingAlgorithm.
 * Use `create(StemmingAlgorithmSchema)` to create a new message.
 */
export const StemmingAlgorithmSchema: GenMessage<StemmingAlgorithm> = /*@__PURE__*/
  messageDesc(file_collections, 49);

/**
 * @generated from message qdrant.SnowballParams
 */
export type SnowballParams = Message<"qdrant.SnowballParams"> & {
  /**
   * Which language the algorithm should stem.
   *
   * @generated from field: string language = 1;
   */
  language: string;
};

/**
 * Describes the message qdrant.SnowballParams.
 * Use `create(SnowballParamsSchema)` to create a new message.
 */
export const SnowballParamsSchema: GenMessage<SnowballParams> = /*@__PURE__*/
  messageDesc(file_collections, 50);

/**
 * @generated from message qdrant.BoolIndexParams
 */
export type BoolIndexParams = Message<"qdrant.BoolIndexParams"> & {
  /**
   * If true - store index on disk.
   *
   * @generated from field: optional bool on_disk = 1;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.BoolIndexParams.
 * Use `create(BoolIndexParamsSchema)` to create a new message.
 */
export const BoolIndexParamsSchema: GenMessage<BoolIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 51);

/**
 * @generated from message qdrant.DatetimeIndexParams
 */
export type DatetimeIndexParams = Message<"qdrant.DatetimeIndexParams"> & {
  /**
   * If true - store index on disk.
   *
   * @generated from field: optional bool on_disk = 1;
   */
  onDisk?: boolean;

  /**
   * If true - use this key to organize storage of the collection data. This option assumes that this key will be used in majority of filtered requests.
   *
   * @generated from field: optional bool is_principal = 2;
   */
  isPrincipal?: boolean;
};

/**
 * Describes the message qdrant.DatetimeIndexParams.
 * Use `create(DatetimeIndexParamsSchema)` to create a new message.
 */
export const DatetimeIndexParamsSchema: GenMessage<DatetimeIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 52);

/**
 * @generated from message qdrant.UuidIndexParams
 */
export type UuidIndexParams = Message<"qdrant.UuidIndexParams"> & {
  /**
   * If true - used for tenant optimization.
   *
   * @generated from field: optional bool is_tenant = 1;
   */
  isTenant?: boolean;

  /**
   * If true - store index on disk.
   *
   * @generated from field: optional bool on_disk = 2;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.UuidIndexParams.
 * Use `create(UuidIndexParamsSchema)` to create a new message.
 */
export const UuidIndexParamsSchema: GenMessage<UuidIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 53);

/**
 * @generated from message qdrant.PayloadIndexParams
 */
export type PayloadIndexParams = Message<"qdrant.PayloadIndexParams"> & {
  /**
   * @generated from oneof qdrant.PayloadIndexParams.index_params
   */
  indexParams: {
    /**
     * Parameters for keyword index
     *
     * @generated from field: qdrant.KeywordIndexParams keyword_index_params = 3;
     */
    value: KeywordIndexParams;
    case: "keywordIndexParams";
  } | {
    /**
     * Parameters for integer index
     *
     * @generated from field: qdrant.IntegerIndexParams integer_index_params = 2;
     */
    value: IntegerIndexParams;
    case: "integerIndexParams";
  } | {
    /**
     * Parameters for float index
     *
     * @generated from field: qdrant.FloatIndexParams float_index_params = 4;
     */
    value: FloatIndexParams;
    case: "floatIndexParams";
  } | {
    /**
     * Parameters for geo index
     *
     * @generated from field: qdrant.GeoIndexParams geo_index_params = 5;
     */
    value: GeoIndexParams;
    case: "geoIndexParams";
  } | {
    /**
     * Parameters for text index
     *
     * @generated from field: qdrant.TextIndexParams text_index_params = 1;
     */
    value: TextIndexParams;
    case: "textIndexParams";
  } | {
    /**
     * Parameters for bool index
     *
     * @generated from field: qdrant.BoolIndexParams bool_index_params = 6;
     */
    value: BoolIndexParams;
    case: "boolIndexParams";
  } | {
    /**
     * Parameters for datetime index
     *
     * @generated from field: qdrant.DatetimeIndexParams datetime_index_params = 7;
     */
    value: DatetimeIndexParams;
    case: "datetimeIndexParams";
  } | {
    /**
     * Parameters for uuid index
     *
     * @generated from field: qdrant.UuidIndexParams uuid_index_params = 8;
     */
    value: UuidIndexParams;
    case: "uuidIndexParams";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.PayloadIndexParams.
 * Use `create(PayloadIndexParamsSchema)` to create a new message.
 */
export const PayloadIndexParamsSchema: GenMessage<PayloadIndexParams> = /*@__PURE__*/
  messageDesc(file_collections, 54);

/**
 * @generated from message qdrant.PayloadSchemaInfo
 */
export type PayloadSchemaInfo = Message<"qdrant.PayloadSchemaInfo"> & {
  /**
   * Field data type
   *
   * @generated from field: qdrant.PayloadSchemaType data_type = 1;
   */
  dataType: PayloadSchemaType;

  /**
   * Field index parameters
   *
   * @generated from field: optional qdrant.PayloadIndexParams params = 2;
   */
  params?: PayloadIndexParams;

  /**
   * Number of points indexed within this field indexed
   *
   * @generated from field: optional uint64 points = 3;
   */
  points?: bigint;
};

/**
 * Describes the message qdrant.PayloadSchemaInfo.
 * Use `create(PayloadSchemaInfoSchema)` to create a new message.
 */
export const PayloadSchemaInfoSchema: GenMessage<PayloadSchemaInfo> = /*@__PURE__*/
  messageDesc(file_collections, 55);

/**
 * @generated from message qdrant.CollectionInfo
 */
export type CollectionInfo = Message<"qdrant.CollectionInfo"> & {
  /**
   * operating condition of the collection
   *
   * @generated from field: qdrant.CollectionStatus status = 1;
   */
  status: CollectionStatus;

  /**
   * status of collection optimizers
   *
   * @generated from field: qdrant.OptimizerStatus optimizer_status = 2;
   */
  optimizerStatus?: OptimizerStatus;

  /**
   * Number of independent segments
   *
   * @generated from field: uint64 segments_count = 4;
   */
  segmentsCount: bigint;

  /**
   * Configuration
   *
   * @generated from field: qdrant.CollectionConfig config = 7;
   */
  config?: CollectionConfig;

  /**
   * Collection data types
   *
   * @generated from field: map<string, qdrant.PayloadSchemaInfo> payload_schema = 8;
   */
  payloadSchema: { [key: string]: PayloadSchemaInfo };

  /**
   * Approximate number of points in the collection
   *
   * @generated from field: optional uint64 points_count = 9;
   */
  pointsCount?: bigint;

  /**
   * Approximate number of indexed vectors in the collection.
   *
   * @generated from field: optional uint64 indexed_vectors_count = 10;
   */
  indexedVectorsCount?: bigint;

  /**
   * Warnings related to the collection
   *
   * @generated from field: repeated qdrant.CollectionWarning warnings = 11;
   */
  warnings: CollectionWarning[];
};

/**
 * Describes the message qdrant.CollectionInfo.
 * Use `create(CollectionInfoSchema)` to create a new message.
 */
export const CollectionInfoSchema: GenMessage<CollectionInfo> = /*@__PURE__*/
  messageDesc(file_collections, 56);

/**
 * @generated from message qdrant.ChangeAliases
 */
export type ChangeAliases = Message<"qdrant.ChangeAliases"> & {
  /**
   * List of actions
   *
   * @generated from field: repeated qdrant.AliasOperations actions = 1;
   */
  actions: AliasOperations[];

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 2;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.ChangeAliases.
 * Use `create(ChangeAliasesSchema)` to create a new message.
 */
export const ChangeAliasesSchema: GenMessage<ChangeAliases> = /*@__PURE__*/
  messageDesc(file_collections, 57);

/**
 * @generated from message qdrant.AliasOperations
 */
export type AliasOperations = Message<"qdrant.AliasOperations"> & {
  /**
   * @generated from oneof qdrant.AliasOperations.action
   */
  action: {
    /**
     * @generated from field: qdrant.CreateAlias create_alias = 1;
     */
    value: CreateAlias;
    case: "createAlias";
  } | {
    /**
     * @generated from field: qdrant.RenameAlias rename_alias = 2;
     */
    value: RenameAlias;
    case: "renameAlias";
  } | {
    /**
     * @generated from field: qdrant.DeleteAlias delete_alias = 3;
     */
    value: DeleteAlias;
    case: "deleteAlias";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.AliasOperations.
 * Use `create(AliasOperationsSchema)` to create a new message.
 */
export const AliasOperationsSchema: GenMessage<AliasOperations> = /*@__PURE__*/
  messageDesc(file_collections, 58);

/**
 * @generated from message qdrant.CreateAlias
 */
export type CreateAlias = Message<"qdrant.CreateAlias"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * New name of the alias
   *
   * @generated from field: string alias_name = 2;
   */
  aliasName: string;
};

/**
 * Describes the message qdrant.CreateAlias.
 * Use `create(CreateAliasSchema)` to create a new message.
 */
export const CreateAliasSchema: GenMessage<CreateAlias> = /*@__PURE__*/
  messageDesc(file_collections, 59);

/**
 * @generated from message qdrant.RenameAlias
 */
export type RenameAlias = Message<"qdrant.RenameAlias"> & {
  /**
   * Name of the alias to rename
   *
   * @generated from field: string old_alias_name = 1;
   */
  oldAliasName: string;

  /**
   * Name of the alias
   *
   * @generated from field: string new_alias_name = 2;
   */
  newAliasName: string;
};

/**
 * Describes the message qdrant.RenameAlias.
 * Use `create(RenameAliasSchema)` to create a new message.
 */
export const RenameAliasSchema: GenMessage<RenameAlias> = /*@__PURE__*/
  messageDesc(file_collections, 60);

/**
 * @generated from message qdrant.DeleteAlias
 */
export type DeleteAlias = Message<"qdrant.DeleteAlias"> & {
  /**
   * Name of the alias
   *
   * @generated from field: string alias_name = 1;
   */
  aliasName: string;
};

/**
 * Describes the message qdrant.DeleteAlias.
 * Use `create(DeleteAliasSchema)` to create a new message.
 */
export const DeleteAliasSchema: GenMessage<DeleteAlias> = /*@__PURE__*/
  messageDesc(file_collections, 61);

/**
 * @generated from message qdrant.ListAliasesRequest
 */
export type ListAliasesRequest = Message<"qdrant.ListAliasesRequest"> & {
};

/**
 * Describes the message qdrant.ListAliasesRequest.
 * Use `create(ListAliasesRequestSchema)` to create a new message.
 */
export const ListAliasesRequestSchema: GenMessage<ListAliasesRequest> = /*@__PURE__*/
  messageDesc(file_collections, 62);

/**
 * @generated from message qdrant.ListCollectionAliasesRequest
 */
export type ListCollectionAliasesRequest = Message<"qdrant.ListCollectionAliasesRequest"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;
};

/**
 * Describes the message qdrant.ListCollectionAliasesRequest.
 * Use `create(ListCollectionAliasesRequestSchema)` to create a new message.
 */
export const ListCollectionAliasesRequestSchema: GenMessage<ListCollectionAliasesRequest> = /*@__PURE__*/
  messageDesc(file_collections, 63);

/**
 * @generated from message qdrant.AliasDescription
 */
export type AliasDescription = Message<"qdrant.AliasDescription"> & {
  /**
   * Name of the alias
   *
   * @generated from field: string alias_name = 1;
   */
  aliasName: string;

  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 2;
   */
  collectionName: string;
};

/**
 * Describes the message qdrant.AliasDescription.
 * Use `create(AliasDescriptionSchema)` to create a new message.
 */
export const AliasDescriptionSchema: GenMessage<AliasDescription> = /*@__PURE__*/
  messageDesc(file_collections, 64);

/**
 * @generated from message qdrant.ListAliasesResponse
 */
export type ListAliasesResponse = Message<"qdrant.ListAliasesResponse"> & {
  /**
   * @generated from field: repeated qdrant.AliasDescription aliases = 1;
   */
  aliases: AliasDescription[];

  /**
   * Time spent to process
   *
   * @generated from field: double time = 2;
   */
  time: number;
};

/**
 * Describes the message qdrant.ListAliasesResponse.
 * Use `create(ListAliasesResponseSchema)` to create a new message.
 */
export const ListAliasesResponseSchema: GenMessage<ListAliasesResponse> = /*@__PURE__*/
  messageDesc(file_collections, 65);

/**
 * @generated from message qdrant.CollectionClusterInfoRequest
 */
export type CollectionClusterInfoRequest = Message<"qdrant.CollectionClusterInfoRequest"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;
};

/**
 * Describes the message qdrant.CollectionClusterInfoRequest.
 * Use `create(CollectionClusterInfoRequestSchema)` to create a new message.
 */
export const CollectionClusterInfoRequestSchema: GenMessage<CollectionClusterInfoRequest> = /*@__PURE__*/
  messageDesc(file_collections, 66);

/**
 * @generated from message qdrant.ShardKey
 */
export type ShardKey = Message<"qdrant.ShardKey"> & {
  /**
   * @generated from oneof qdrant.ShardKey.key
   */
  key: {
    /**
     * String key
     *
     * @generated from field: string keyword = 1;
     */
    value: string;
    case: "keyword";
  } | {
    /**
     * Number key
     *
     * @generated from field: uint64 number = 2;
     */
    value: bigint;
    case: "number";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message qdrant.ShardKey.
 * Use `create(ShardKeySchema)` to create a new message.
 */
export const ShardKeySchema: GenMessage<ShardKey> = /*@__PURE__*/
  messageDesc(file_collections, 67);

/**
 * @generated from message qdrant.LocalShardInfo
 */
export type LocalShardInfo = Message<"qdrant.LocalShardInfo"> & {
  /**
   * Local shard id
   *
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * Number of points in the shard
   *
   * @generated from field: uint64 points_count = 2;
   */
  pointsCount: bigint;

  /**
   * Is replica active
   *
   * @generated from field: qdrant.ReplicaState state = 3;
   */
  state: ReplicaState;

  /**
   * User-defined shard key
   *
   * @generated from field: optional qdrant.ShardKey shard_key = 4;
   */
  shardKey?: ShardKey;
};

/**
 * Describes the message qdrant.LocalShardInfo.
 * Use `create(LocalShardInfoSchema)` to create a new message.
 */
export const LocalShardInfoSchema: GenMessage<LocalShardInfo> = /*@__PURE__*/
  messageDesc(file_collections, 68);

/**
 * @generated from message qdrant.RemoteShardInfo
 */
export type RemoteShardInfo = Message<"qdrant.RemoteShardInfo"> & {
  /**
   * Local shard id
   *
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * Remote peer id
   *
   * @generated from field: uint64 peer_id = 2;
   */
  peerId: bigint;

  /**
   * Is replica active
   *
   * @generated from field: qdrant.ReplicaState state = 3;
   */
  state: ReplicaState;

  /**
   * User-defined shard key
   *
   * @generated from field: optional qdrant.ShardKey shard_key = 4;
   */
  shardKey?: ShardKey;
};

/**
 * Describes the message qdrant.RemoteShardInfo.
 * Use `create(RemoteShardInfoSchema)` to create a new message.
 */
export const RemoteShardInfoSchema: GenMessage<RemoteShardInfo> = /*@__PURE__*/
  messageDesc(file_collections, 69);

/**
 * @generated from message qdrant.ShardTransferInfo
 */
export type ShardTransferInfo = Message<"qdrant.ShardTransferInfo"> & {
  /**
   * Local shard id
   *
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * @generated from field: optional uint32 to_shard_id = 5;
   */
  toShardId?: number;

  /**
   * @generated from field: uint64 from = 2;
   */
  from: bigint;

  /**
   * @generated from field: uint64 to = 3;
   */
  to: bigint;

  /**
   * If `true` transfer is a synchronization of a replicas; If `false` transfer is a moving of a shard from one peer to another
   *
   * @generated from field: bool sync = 4;
   */
  sync: boolean;
};

/**
 * Describes the message qdrant.ShardTransferInfo.
 * Use `create(ShardTransferInfoSchema)` to create a new message.
 */
export const ShardTransferInfoSchema: GenMessage<ShardTransferInfo> = /*@__PURE__*/
  messageDesc(file_collections, 70);

/**
 * @generated from message qdrant.ReshardingInfo
 */
export type ReshardingInfo = Message<"qdrant.ReshardingInfo"> & {
  /**
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * @generated from field: uint64 peer_id = 2;
   */
  peerId: bigint;

  /**
   * @generated from field: optional qdrant.ShardKey shard_key = 3;
   */
  shardKey?: ShardKey;

  /**
   * @generated from field: qdrant.ReshardingDirection direction = 4;
   */
  direction: ReshardingDirection;
};

/**
 * Describes the message qdrant.ReshardingInfo.
 * Use `create(ReshardingInfoSchema)` to create a new message.
 */
export const ReshardingInfoSchema: GenMessage<ReshardingInfo> = /*@__PURE__*/
  messageDesc(file_collections, 71);

/**
 * @generated from message qdrant.CollectionClusterInfoResponse
 */
export type CollectionClusterInfoResponse = Message<"qdrant.CollectionClusterInfoResponse"> & {
  /**
   * ID of this peer
   *
   * @generated from field: uint64 peer_id = 1;
   */
  peerId: bigint;

  /**
   * Total number of shards
   *
   * @generated from field: uint64 shard_count = 2;
   */
  shardCount: bigint;

  /**
   * Local shards
   *
   * @generated from field: repeated qdrant.LocalShardInfo local_shards = 3;
   */
  localShards: LocalShardInfo[];

  /**
   * Remote shards
   *
   * @generated from field: repeated qdrant.RemoteShardInfo remote_shards = 4;
   */
  remoteShards: RemoteShardInfo[];

  /**
   * Shard transfers
   *
   * @generated from field: repeated qdrant.ShardTransferInfo shard_transfers = 5;
   */
  shardTransfers: ShardTransferInfo[];

  /**
   * Resharding operations
   *
   * @generated from field: repeated qdrant.ReshardingInfo resharding_operations = 6;
   */
  reshardingOperations: ReshardingInfo[];
};

/**
 * Describes the message qdrant.CollectionClusterInfoResponse.
 * Use `create(CollectionClusterInfoResponseSchema)` to create a new message.
 */
export const CollectionClusterInfoResponseSchema: GenMessage<CollectionClusterInfoResponse> = /*@__PURE__*/
  messageDesc(file_collections, 72);

/**
 * @generated from message qdrant.MoveShard
 */
export type MoveShard = Message<"qdrant.MoveShard"> & {
  /**
   * Local shard id
   *
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * @generated from field: optional uint32 to_shard_id = 5;
   */
  toShardId?: number;

  /**
   * @generated from field: uint64 from_peer_id = 2;
   */
  fromPeerId: bigint;

  /**
   * @generated from field: uint64 to_peer_id = 3;
   */
  toPeerId: bigint;

  /**
   * @generated from field: optional qdrant.ShardTransferMethod method = 4;
   */
  method?: ShardTransferMethod;
};

/**
 * Describes the message qdrant.MoveShard.
 * Use `create(MoveShardSchema)` to create a new message.
 */
export const MoveShardSchema: GenMessage<MoveShard> = /*@__PURE__*/
  messageDesc(file_collections, 73);

/**
 * @generated from message qdrant.ReplicateShard
 */
export type ReplicateShard = Message<"qdrant.ReplicateShard"> & {
  /**
   * Local shard id
   *
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * @generated from field: optional uint32 to_shard_id = 5;
   */
  toShardId?: number;

  /**
   * @generated from field: uint64 from_peer_id = 2;
   */
  fromPeerId: bigint;

  /**
   * @generated from field: uint64 to_peer_id = 3;
   */
  toPeerId: bigint;

  /**
   * @generated from field: optional qdrant.ShardTransferMethod method = 4;
   */
  method?: ShardTransferMethod;
};

/**
 * Describes the message qdrant.ReplicateShard.
 * Use `create(ReplicateShardSchema)` to create a new message.
 */
export const ReplicateShardSchema: GenMessage<ReplicateShard> = /*@__PURE__*/
  messageDesc(file_collections, 74);

/**
 * @generated from message qdrant.AbortShardTransfer
 */
export type AbortShardTransfer = Message<"qdrant.AbortShardTransfer"> & {
  /**
   * Local shard id
   *
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * @generated from field: optional uint32 to_shard_id = 4;
   */
  toShardId?: number;

  /**
   * @generated from field: uint64 from_peer_id = 2;
   */
  fromPeerId: bigint;

  /**
   * @generated from field: uint64 to_peer_id = 3;
   */
  toPeerId: bigint;
};

/**
 * Describes the message qdrant.AbortShardTransfer.
 * Use `create(AbortShardTransferSchema)` to create a new message.
 */
export const AbortShardTransferSchema: GenMessage<AbortShardTransfer> = /*@__PURE__*/
  messageDesc(file_collections, 75);

/**
 * @generated from message qdrant.RestartTransfer
 */
export type RestartTransfer = Message<"qdrant.RestartTransfer"> & {
  /**
   * Local shard id
   *
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * @generated from field: optional uint32 to_shard_id = 5;
   */
  toShardId?: number;

  /**
   * @generated from field: uint64 from_peer_id = 2;
   */
  fromPeerId: bigint;

  /**
   * @generated from field: uint64 to_peer_id = 3;
   */
  toPeerId: bigint;

  /**
   * @generated from field: qdrant.ShardTransferMethod method = 4;
   */
  method: ShardTransferMethod;
};

/**
 * Describes the message qdrant.RestartTransfer.
 * Use `create(RestartTransferSchema)` to create a new message.
 */
export const RestartTransferSchema: GenMessage<RestartTransfer> = /*@__PURE__*/
  messageDesc(file_collections, 76);

/**
 * @generated from message qdrant.ReplicatePoints
 */
export type ReplicatePoints = Message<"qdrant.ReplicatePoints"> & {
  /**
   * Source shard key
   *
   * @generated from field: qdrant.ShardKey from_shard_key = 1;
   */
  fromShardKey?: ShardKey;

  /**
   * Target shard key
   *
   * @generated from field: qdrant.ShardKey to_shard_key = 2;
   */
  toShardKey?: ShardKey;

  /**
   * If set - only points matching the filter will be replicated
   *
   * @generated from field: optional qdrant.Filter filter = 3;
   */
  filter?: Filter;
};

/**
 * Describes the message qdrant.ReplicatePoints.
 * Use `create(ReplicatePointsSchema)` to create a new message.
 */
export const ReplicatePointsSchema: GenMessage<ReplicatePoints> = /*@__PURE__*/
  messageDesc(file_collections, 77);

/**
 * @generated from message qdrant.Replica
 */
export type Replica = Message<"qdrant.Replica"> & {
  /**
   * @generated from field: uint32 shard_id = 1;
   */
  shardId: number;

  /**
   * @generated from field: uint64 peer_id = 2;
   */
  peerId: bigint;
};

/**
 * Describes the message qdrant.Replica.
 * Use `create(ReplicaSchema)` to create a new message.
 */
export const ReplicaSchema: GenMessage<Replica> = /*@__PURE__*/
  messageDesc(file_collections, 78);

/**
 * @generated from message qdrant.CreateShardKey
 */
export type CreateShardKey = Message<"qdrant.CreateShardKey"> & {
  /**
   * User-defined shard key
   *
   * @generated from field: qdrant.ShardKey shard_key = 1;
   */
  shardKey?: ShardKey;

  /**
   * Number of shards to create per shard key
   *
   * @generated from field: optional uint32 shards_number = 2;
   */
  shardsNumber?: number;

  /**
   * Number of replicas of each shard to create
   *
   * @generated from field: optional uint32 replication_factor = 3;
   */
  replicationFactor?: number;

  /**
   * List of peer ids, allowed to create shards. If empty - all peers are allowed
   *
   * @generated from field: repeated uint64 placement = 4;
   */
  placement: bigint[];

  /**
   * Initial state of created replicas. Warning: use with care.
   *
   * @generated from field: optional qdrant.ReplicaState initial_state = 5;
   */
  initialState?: ReplicaState;
};

/**
 * Describes the message qdrant.CreateShardKey.
 * Use `create(CreateShardKeySchema)` to create a new message.
 */
export const CreateShardKeySchema: GenMessage<CreateShardKey> = /*@__PURE__*/
  messageDesc(file_collections, 79);

/**
 * @generated from message qdrant.DeleteShardKey
 */
export type DeleteShardKey = Message<"qdrant.DeleteShardKey"> & {
  /**
   * Shard key to delete
   *
   * @generated from field: qdrant.ShardKey shard_key = 1;
   */
  shardKey?: ShardKey;
};

/**
 * Describes the message qdrant.DeleteShardKey.
 * Use `create(DeleteShardKeySchema)` to create a new message.
 */
export const DeleteShardKeySchema: GenMessage<DeleteShardKey> = /*@__PURE__*/
  messageDesc(file_collections, 80);

/**
 * @generated from message qdrant.UpdateCollectionClusterSetupRequest
 */
export type UpdateCollectionClusterSetupRequest = Message<"qdrant.UpdateCollectionClusterSetupRequest"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * @generated from oneof qdrant.UpdateCollectionClusterSetupRequest.operation
   */
  operation: {
    /**
     * @generated from field: qdrant.MoveShard move_shard = 2;
     */
    value: MoveShard;
    case: "moveShard";
  } | {
    /**
     * @generated from field: qdrant.ReplicateShard replicate_shard = 3;
     */
    value: ReplicateShard;
    case: "replicateShard";
  } | {
    /**
     * @generated from field: qdrant.AbortShardTransfer abort_transfer = 4;
     */
    value: AbortShardTransfer;
    case: "abortTransfer";
  } | {
    /**
     * @generated from field: qdrant.Replica drop_replica = 5;
     */
    value: Replica;
    case: "dropReplica";
  } | {
    /**
     * @generated from field: qdrant.CreateShardKey create_shard_key = 7;
     */
    value: CreateShardKey;
    case: "createShardKey";
  } | {
    /**
     * @generated from field: qdrant.DeleteShardKey delete_shard_key = 8;
     */
    value: DeleteShardKey;
    case: "deleteShardKey";
  } | {
    /**
     * @generated from field: qdrant.RestartTransfer restart_transfer = 9;
     */
    value: RestartTransfer;
    case: "restartTransfer";
  } | {
    /**
     * @generated from field: qdrant.ReplicatePoints replicate_points = 10;
     */
    value: ReplicatePoints;
    case: "replicatePoints";
  } | { case: undefined; value?: undefined };

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 6;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.UpdateCollectionClusterSetupRequest.
 * Use `create(UpdateCollectionClusterSetupRequestSchema)` to create a new message.
 */
export const UpdateCollectionClusterSetupRequestSchema: GenMessage<UpdateCollectionClusterSetupRequest> = /*@__PURE__*/
  messageDesc(file_collections, 81);

/**
 * @generated from message qdrant.UpdateCollectionClusterSetupResponse
 */
export type UpdateCollectionClusterSetupResponse = Message<"qdrant.UpdateCollectionClusterSetupResponse"> & {
  /**
   * @generated from field: bool result = 1;
   */
  result: boolean;
};

/**
 * Describes the message qdrant.UpdateCollectionClusterSetupResponse.
 * Use `create(UpdateCollectionClusterSetupResponseSchema)` to create a new message.
 */
export const UpdateCollectionClusterSetupResponseSchema: GenMessage<UpdateCollectionClusterSetupResponse> = /*@__PURE__*/
  messageDesc(file_collections, 82);

/**
 * @generated from message qdrant.CreateShardKeyRequest
 */
export type CreateShardKeyRequest = Message<"qdrant.CreateShardKeyRequest"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Request to create shard key
   *
   * @generated from field: qdrant.CreateShardKey request = 2;
   */
  request?: CreateShardKey;

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 3;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.CreateShardKeyRequest.
 * Use `create(CreateShardKeyRequestSchema)` to create a new message.
 */
export const CreateShardKeyRequestSchema: GenMessage<CreateShardKeyRequest> = /*@__PURE__*/
  messageDesc(file_collections, 83);

/**
 * @generated from message qdrant.DeleteShardKeyRequest
 */
export type DeleteShardKeyRequest = Message<"qdrant.DeleteShardKeyRequest"> & {
  /**
   * Name of the collection
   *
   * @generated from field: string collection_name = 1;
   */
  collectionName: string;

  /**
   * Request to delete shard key
   *
   * @generated from field: qdrant.DeleteShardKey request = 2;
   */
  request?: DeleteShardKey;

  /**
   * Wait timeout for operation commit in seconds, if not specified - default value will be supplied
   *
   * @generated from field: optional uint64 timeout = 3;
   */
  timeout?: bigint;
};

/**
 * Describes the message qdrant.DeleteShardKeyRequest.
 * Use `create(DeleteShardKeyRequestSchema)` to create a new message.
 */
export const DeleteShardKeyRequestSchema: GenMessage<DeleteShardKeyRequest> = /*@__PURE__*/
  messageDesc(file_collections, 84);

/**
 * @generated from message qdrant.CreateShardKeyResponse
 */
export type CreateShardKeyResponse = Message<"qdrant.CreateShardKeyResponse"> & {
  /**
   * @generated from field: bool result = 1;
   */
  result: boolean;
};

/**
 * Describes the message qdrant.CreateShardKeyResponse.
 * Use `create(CreateShardKeyResponseSchema)` to create a new message.
 */
export const CreateShardKeyResponseSchema: GenMessage<CreateShardKeyResponse> = /*@__PURE__*/
  messageDesc(file_collections, 85);

/**
 * @generated from message qdrant.DeleteShardKeyResponse
 */
export type DeleteShardKeyResponse = Message<"qdrant.DeleteShardKeyResponse"> & {
  /**
   * @generated from field: bool result = 1;
   */
  result: boolean;
};

/**
 * Describes the message qdrant.DeleteShardKeyResponse.
 * Use `create(DeleteShardKeyResponseSchema)` to create a new message.
 */
export const DeleteShardKeyResponseSchema: GenMessage<DeleteShardKeyResponse> = /*@__PURE__*/
  messageDesc(file_collections, 86);

/**
 * @generated from enum qdrant.Datatype
 */
export enum Datatype {
  /**
   * @generated from enum value: Default = 0;
   */
  Default = 0,

  /**
   * @generated from enum value: Float32 = 1;
   */
  Float32 = 1,

  /**
   * @generated from enum value: Uint8 = 2;
   */
  Uint8 = 2,

  /**
   * @generated from enum value: Float16 = 3;
   */
  Float16 = 3,
}

/**
 * Describes the enum qdrant.Datatype.
 */
export const DatatypeSchema: GenEnum<Datatype> = /*@__PURE__*/
  enumDesc(file_collections, 0);

/**
 * @generated from enum qdrant.Modifier
 */
export enum Modifier {
  /**
   * @generated from enum value: None = 0;
   */
  None = 0,

  /**
   * Apply Inverse Document Frequency
   *
   * @generated from enum value: Idf = 1;
   */
  Idf = 1,
}

/**
 * Describes the enum qdrant.Modifier.
 */
export const ModifierSchema: GenEnum<Modifier> = /*@__PURE__*/
  enumDesc(file_collections, 1);

/**
 * @generated from enum qdrant.MultiVectorComparator
 */
export enum MultiVectorComparator {
  /**
   * @generated from enum value: MaxSim = 0;
   */
  MaxSim = 0,
}

/**
 * Describes the enum qdrant.MultiVectorComparator.
 */
export const MultiVectorComparatorSchema: GenEnum<MultiVectorComparator> = /*@__PURE__*/
  enumDesc(file_collections, 2);

/**
 * @generated from enum qdrant.Distance
 */
export enum Distance {
  /**
   * @generated from enum value: UnknownDistance = 0;
   */
  UnknownDistance = 0,

  /**
   * @generated from enum value: Cosine = 1;
   */
  Cosine = 1,

  /**
   * @generated from enum value: Euclid = 2;
   */
  Euclid = 2,

  /**
   * @generated from enum value: Dot = 3;
   */
  Dot = 3,

  /**
   * @generated from enum value: Manhattan = 4;
   */
  Manhattan = 4,
}

/**
 * Describes the enum qdrant.Distance.
 */
export const DistanceSchema: GenEnum<Distance> = /*@__PURE__*/
  enumDesc(file_collections, 3);

/**
 * @generated from enum qdrant.CollectionStatus
 */
export enum CollectionStatus {
  /**
   * @generated from enum value: UnknownCollectionStatus = 0;
   */
  UnknownCollectionStatus = 0,

  /**
   * All segments are ready
   *
   * @generated from enum value: Green = 1;
   */
  Green = 1,

  /**
   * Optimization in process
   *
   * @generated from enum value: Yellow = 2;
   */
  Yellow = 2,

  /**
   * Something went wrong
   *
   * @generated from enum value: Red = 3;
   */
  Red = 3,

  /**
   * Optimization is pending
   *
   * @generated from enum value: Grey = 4;
   */
  Grey = 4,
}

/**
 * Describes the enum qdrant.CollectionStatus.
 */
export const CollectionStatusSchema: GenEnum<CollectionStatus> = /*@__PURE__*/
  enumDesc(file_collections, 4);

/**
 * @generated from enum qdrant.PayloadSchemaType
 */
export enum PayloadSchemaType {
  /**
   * @generated from enum value: UnknownType = 0;
   */
  UnknownType = 0,

  /**
   * @generated from enum value: Keyword = 1;
   */
  Keyword = 1,

  /**
   * @generated from enum value: Integer = 2;
   */
  Integer = 2,

  /**
   * @generated from enum value: Float = 3;
   */
  Float = 3,

  /**
   * @generated from enum value: Geo = 4;
   */
  Geo = 4,

  /**
   * @generated from enum value: Text = 5;
   */
  Text = 5,

  /**
   * @generated from enum value: Bool = 6;
   */
  Bool = 6,

  /**
   * @generated from enum value: Datetime = 7;
   */
  Datetime = 7,

  /**
   * @generated from enum value: Uuid = 8;
   */
  Uuid = 8,
}

/**
 * Describes the enum qdrant.PayloadSchemaType.
 */
export const PayloadSchemaTypeSchema: GenEnum<PayloadSchemaType> = /*@__PURE__*/
  enumDesc(file_collections, 5);

/**
 * @generated from enum qdrant.QuantizationType
 */
export enum QuantizationType {
  /**
   * @generated from enum value: UnknownQuantization = 0;
   */
  UnknownQuantization = 0,

  /**
   * @generated from enum value: Int8 = 1;
   */
  Int8 = 1,
}

/**
 * Describes the enum qdrant.QuantizationType.
 */
export const QuantizationTypeSchema: GenEnum<QuantizationType> = /*@__PURE__*/
  enumDesc(file_collections, 6);

/**
 * @generated from enum qdrant.CompressionRatio
 */
export enum CompressionRatio {
  /**
   * @generated from enum value: x4 = 0;
   */
  x4 = 0,

  /**
   * @generated from enum value: x8 = 1;
   */
  x8 = 1,

  /**
   * @generated from enum value: x16 = 2;
   */
  x16 = 2,

  /**
   * @generated from enum value: x32 = 3;
   */
  x32 = 3,

  /**
   * @generated from enum value: x64 = 4;
   */
  x64 = 4,
}

/**
 * Describes the enum qdrant.CompressionRatio.
 */
export const CompressionRatioSchema: GenEnum<CompressionRatio> = /*@__PURE__*/
  enumDesc(file_collections, 7);

/**
 * @generated from enum qdrant.BinaryQuantizationEncoding
 */
export enum BinaryQuantizationEncoding {
  /**
   * @generated from enum value: OneBit = 0;
   */
  OneBit = 0,

  /**
   * @generated from enum value: TwoBits = 1;
   */
  TwoBits = 1,

  /**
   * @generated from enum value: OneAndHalfBits = 2;
   */
  OneAndHalfBits = 2,
}

/**
 * Describes the enum qdrant.BinaryQuantizationEncoding.
 */
export const BinaryQuantizationEncodingSchema: GenEnum<BinaryQuantizationEncoding> = /*@__PURE__*/
  enumDesc(file_collections, 8);

/**
 * @generated from enum qdrant.ShardingMethod
 */
export enum ShardingMethod {
  /**
   * Auto-sharding based on record ids
   *
   * @generated from enum value: Auto = 0;
   */
  Auto = 0,

  /**
   * Shard by user-defined key
   *
   * @generated from enum value: Custom = 1;
   */
  Custom = 1,
}

/**
 * Describes the enum qdrant.ShardingMethod.
 */
export const ShardingMethodSchema: GenEnum<ShardingMethod> = /*@__PURE__*/
  enumDesc(file_collections, 9);

/**
 * @generated from enum qdrant.TokenizerType
 */
export enum TokenizerType {
  /**
   * @generated from enum value: Unknown = 0;
   */
  Unknown = 0,

  /**
   * @generated from enum value: Prefix = 1;
   */
  Prefix = 1,

  /**
   * @generated from enum value: Whitespace = 2;
   */
  Whitespace = 2,

  /**
   * @generated from enum value: Word = 3;
   */
  Word = 3,

  /**
   * @generated from enum value: Multilingual = 4;
   */
  Multilingual = 4,
}

/**
 * Describes the enum qdrant.TokenizerType.
 */
export const TokenizerTypeSchema: GenEnum<TokenizerType> = /*@__PURE__*/
  enumDesc(file_collections, 10);

/**
 * @generated from enum qdrant.ReplicaState
 */
export enum ReplicaState {
  /**
   * Active and sound
   *
   * @generated from enum value: Active = 0;
   */
  Active = 0,

  /**
   * Failed for some reason
   *
   * @generated from enum value: Dead = 1;
   */
  Dead = 1,

  /**
   * The shard is partially loaded and is currently receiving data from other shards
   *
   * @generated from enum value: Partial = 2;
   */
  Partial = 2,

  /**
   * Collection is being created
   *
   * @generated from enum value: Initializing = 3;
   */
  Initializing = 3,

  /**
   * A shard which receives data, but is not used for search; Useful for backup shards
   *
   * @generated from enum value: Listener = 4;
   */
  Listener = 4,

  /**
   * Deprecated: snapshot shard transfer is in progress; Updates should not be sent to (and are ignored by) the shard
   *
   * @generated from enum value: PartialSnapshot = 5;
   */
  PartialSnapshot = 5,

  /**
   * Shard is undergoing recovered by an external node; Normally rejects updates, accepts updates if force is true
   *
   * @generated from enum value: Recovery = 6;
   */
  Recovery = 6,

  /**
   * Points are being migrated to this shard as part of scale-up resharding
   *
   * @generated from enum value: Resharding = 7;
   */
  Resharding = 7,

  /**
   * Points are being migrated to this shard as part of scale-down resharding
   *
   * @generated from enum value: ReshardingScaleDown = 8;
   */
  ReshardingScaleDown = 8,

  /**
   * Active for readers, Partial for writers
   *
   * @generated from enum value: ActiveRead = 9;
   */
  ActiveRead = 9,
}

/**
 * Describes the enum qdrant.ReplicaState.
 */
export const ReplicaStateSchema: GenEnum<ReplicaState> = /*@__PURE__*/
  enumDesc(file_collections, 11);

/**
 *
 * Resharding direction, scale up or down in number of shards
 *
 * @generated from enum qdrant.ReshardingDirection
 */
export enum ReshardingDirection {
  /**
   * Scale up, add a new shard
   *
   * @generated from enum value: Up = 0;
   */
  Up = 0,

  /**
   * Scale down, remove a shard
   *
   * @generated from enum value: Down = 1;
   */
  Down = 1,
}

/**
 * Describes the enum qdrant.ReshardingDirection.
 */
export const ReshardingDirectionSchema: GenEnum<ReshardingDirection> = /*@__PURE__*/
  enumDesc(file_collections, 12);

/**
 * @generated from enum qdrant.ShardTransferMethod
 */
export enum ShardTransferMethod {
  /**
   * Stream shard records in batches
   *
   * @generated from enum value: StreamRecords = 0;
   */
  StreamRecords = 0,

  /**
   * Snapshot the shard and recover it on the target peer
   *
   * @generated from enum value: Snapshot = 1;
   */
  Snapshot = 1,

  /**
   * Resolve WAL delta between peers and transfer the difference
   *
   * @generated from enum value: WalDelta = 2;
   */
  WalDelta = 2,

  /**
   * Stream shard records in batches for resharding
   *
   * @generated from enum value: ReshardingStreamRecords = 3;
   */
  ReshardingStreamRecords = 3,
}

/**
 * Describes the enum qdrant.ShardTransferMethod.
 */
export const ShardTransferMethodSchema: GenEnum<ShardTransferMethod> = /*@__PURE__*/
  enumDesc(file_collections, 13);

