// @generated by protoc-gen-es v2.10.0 with parameter "target=ts,import_extension=js"
// @generated from file points_service.proto (package qdrant, syntax proto3)
/* eslint-disable */

import type { GenFile, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { ClearPayloadPointsSchema, CountPointsSchema, CountResponseSchema, CreateFieldIndexCollectionSchema, DeleteFieldIndexCollectionSchema, DeletePayloadPointsSchema, DeletePointsSchema, DeletePointVectorsSchema, DiscoverBatchPointsSchema, DiscoverBatchResponseSchema, DiscoverPointsSchema, DiscoverResponseSchema, FacetCountsSchema, FacetResponseSchema, GetPointsSchema, GetResponseSchema, PointsOperationResponseSchema, QueryBatchPointsSchema, QueryBatchResponseSchema, QueryGroupsResponseSchema, QueryPointGroupsSchema, QueryPointsSchema, QueryResponseSchema, RecommendBatchPointsSchema, RecommendBatchResponseSchema, RecommendGroupsResponseSchema, RecommendPointGroupsSchema, RecommendPointsSchema, RecommendResponseSchema, ScrollPointsSchema, ScrollResponseSchema, SearchBatchPointsSchema, SearchBatchResponseSchema, SearchGroupsResponseSchema, SearchMatrixOffsetsResponseSchema, SearchMatrixPairsResponseSchema, SearchMatrixPointsSchema, SearchPointGroupsSchema, SearchPointsSchema, SearchResponseSchema, SetPayloadPointsSchema, UpdateBatchPointsSchema, UpdateBatchResponseSchema, UpdatePointVectorsSchema, UpsertPointsSchema } from "./points_pb.js";
import { file_points } from "./points_pb.js";

/**
 * Describes the file points_service.proto.
 */
export const file_points_service: GenFile = /*@__PURE__*/
  fileDesc("ChRwb2ludHNfc2VydmljZS5wcm90bxIGcWRyYW50Mv0PCgZQb2ludHMSQQoGVXBzZXJ0EhQucWRyYW50LlVwc2VydFBvaW50cxofLnFkcmFudC5Qb2ludHNPcGVyYXRpb25SZXNwb25zZSIAEkEKBkRlbGV0ZRIULnFkcmFudC5EZWxldGVQb2ludHMaHy5xZHJhbnQuUG9pbnRzT3BlcmF0aW9uUmVzcG9uc2UiABIvCgNHZXQSES5xZHJhbnQuR2V0UG9pbnRzGhMucWRyYW50LkdldFJlc3BvbnNlIgASTgoNVXBkYXRlVmVjdG9ycxIaLnFkcmFudC5VcGRhdGVQb2ludFZlY3RvcnMaHy5xZHJhbnQuUG9pbnRzT3BlcmF0aW9uUmVzcG9uc2UiABJOCg1EZWxldGVWZWN0b3JzEhoucWRyYW50LkRlbGV0ZVBvaW50VmVjdG9ycxofLnFkcmFudC5Qb2ludHNPcGVyYXRpb25SZXNwb25zZSIAEkkKClNldFBheWxvYWQSGC5xZHJhbnQuU2V0UGF5bG9hZFBvaW50cxofLnFkcmFudC5Qb2ludHNPcGVyYXRpb25SZXNwb25zZSIAEk8KEE92ZXJ3cml0ZVBheWxvYWQSGC5xZHJhbnQuU2V0UGF5bG9hZFBvaW50cxofLnFkcmFudC5Qb2ludHNPcGVyYXRpb25SZXNwb25zZSIAEk8KDURlbGV0ZVBheWxvYWQSGy5xZHJhbnQuRGVsZXRlUGF5bG9hZFBvaW50cxofLnFkcmFudC5Qb2ludHNPcGVyYXRpb25SZXNwb25zZSIAEk0KDENsZWFyUGF5bG9hZBIaLnFkcmFudC5DbGVhclBheWxvYWRQb2ludHMaHy5xZHJhbnQuUG9pbnRzT3BlcmF0aW9uUmVzcG9uc2UiABJZChBDcmVhdGVGaWVsZEluZGV4EiIucWRyYW50LkNyZWF0ZUZpZWxkSW5kZXhDb2xsZWN0aW9uGh8ucWRyYW50LlBvaW50c09wZXJhdGlvblJlc3BvbnNlIgASWQoQRGVsZXRlRmllbGRJbmRleBIiLnFkcmFudC5EZWxldGVGaWVsZEluZGV4Q29sbGVjdGlvbhofLnFkcmFudC5Qb2ludHNPcGVyYXRpb25SZXNwb25zZSIAEjgKBlNlYXJjaBIULnFkcmFudC5TZWFyY2hQb2ludHMaFi5xZHJhbnQuU2VhcmNoUmVzcG9uc2UiABJHCgtTZWFyY2hCYXRjaBIZLnFkcmFudC5TZWFyY2hCYXRjaFBvaW50cxobLnFkcmFudC5TZWFyY2hCYXRjaFJlc3BvbnNlIgASSQoMU2VhcmNoR3JvdXBzEhkucWRyYW50LlNlYXJjaFBvaW50R3JvdXBzGhwucWRyYW50LlNlYXJjaEdyb3Vwc1Jlc3BvbnNlIgASOAoGU2Nyb2xsEhQucWRyYW50LlNjcm9sbFBvaW50cxoWLnFkcmFudC5TY3JvbGxSZXNwb25zZSIAEkEKCVJlY29tbWVuZBIXLnFkcmFudC5SZWNvbW1lbmRQb2ludHMaGS5xZHJhbnQuUmVjb21tZW5kUmVzcG9uc2UiABJQCg5SZWNvbW1lbmRCYXRjaBIcLnFkcmFudC5SZWNvbW1lbmRCYXRjaFBvaW50cxoeLnFkcmFudC5SZWNvbW1lbmRCYXRjaFJlc3BvbnNlIgASUgoPUmVjb21tZW5kR3JvdXBzEhwucWRyYW50LlJlY29tbWVuZFBvaW50R3JvdXBzGh8ucWRyYW50LlJlY29tbWVuZEdyb3Vwc1Jlc3BvbnNlIgASPgoIRGlzY292ZXISFi5xZHJhbnQuRGlzY292ZXJQb2ludHMaGC5xZHJhbnQuRGlzY292ZXJSZXNwb25zZSIAEk0KDURpc2NvdmVyQmF0Y2gSGy5xZHJhbnQuRGlzY292ZXJCYXRjaFBvaW50cxodLnFkcmFudC5EaXNjb3ZlckJhdGNoUmVzcG9uc2UiABI1CgVDb3VudBITLnFkcmFudC5Db3VudFBvaW50cxoVLnFkcmFudC5Db3VudFJlc3BvbnNlIgASRwoLVXBkYXRlQmF0Y2gSGS5xZHJhbnQuVXBkYXRlQmF0Y2hQb2ludHMaGy5xZHJhbnQuVXBkYXRlQmF0Y2hSZXNwb25zZSIAEjUKBVF1ZXJ5EhMucWRyYW50LlF1ZXJ5UG9pbnRzGhUucWRyYW50LlF1ZXJ5UmVzcG9uc2UiABJECgpRdWVyeUJhdGNoEhgucWRyYW50LlF1ZXJ5QmF0Y2hQb2ludHMaGi5xZHJhbnQuUXVlcnlCYXRjaFJlc3BvbnNlIgASRgoLUXVlcnlHcm91cHMSGC5xZHJhbnQuUXVlcnlQb2ludEdyb3VwcxobLnFkcmFudC5RdWVyeUdyb3Vwc1Jlc3BvbnNlIgASNQoFRmFjZXQSEy5xZHJhbnQuRmFjZXRDb3VudHMaFS5xZHJhbnQuRmFjZXRSZXNwb25zZSIAElQKEVNlYXJjaE1hdHJpeFBhaXJzEhoucWRyYW50LlNlYXJjaE1hdHJpeFBvaW50cxohLnFkcmFudC5TZWFyY2hNYXRyaXhQYWlyc1Jlc3BvbnNlIgASWAoTU2VhcmNoTWF0cml4T2Zmc2V0cxIaLnFkcmFudC5TZWFyY2hNYXRyaXhQb2ludHMaIy5xZHJhbnQuU2VhcmNoTWF0cml4T2Zmc2V0c1Jlc3BvbnNlIgBCFaoCElFkcmFudC5DbGllbnQuR3JwY2IGcHJvdG8z", [file_points]);

/**
 * @generated from service qdrant.Points
 */
export const Points: GenService<{
  /**
   *
   * Perform insert + updates on points. If a point with a given ID already exists - it will be overwritten.
   *
   * @generated from rpc qdrant.Points.Upsert
   */
  upsert: {
    methodKind: "unary";
    input: typeof UpsertPointsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Delete points
   *
   * @generated from rpc qdrant.Points.Delete
   */
  delete: {
    methodKind: "unary";
    input: typeof DeletePointsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Retrieve points
   *
   * @generated from rpc qdrant.Points.Get
   */
  get: {
    methodKind: "unary";
    input: typeof GetPointsSchema;
    output: typeof GetResponseSchema;
  },
  /**
   *
   * Update named vectors for point
   *
   * @generated from rpc qdrant.Points.UpdateVectors
   */
  updateVectors: {
    methodKind: "unary";
    input: typeof UpdatePointVectorsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Delete named vectors for points
   *
   * @generated from rpc qdrant.Points.DeleteVectors
   */
  deleteVectors: {
    methodKind: "unary";
    input: typeof DeletePointVectorsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Set payload for points
   *
   * @generated from rpc qdrant.Points.SetPayload
   */
  setPayload: {
    methodKind: "unary";
    input: typeof SetPayloadPointsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Overwrite payload for points
   *
   * @generated from rpc qdrant.Points.OverwritePayload
   */
  overwritePayload: {
    methodKind: "unary";
    input: typeof SetPayloadPointsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Delete specified key payload for points
   *
   * @generated from rpc qdrant.Points.DeletePayload
   */
  deletePayload: {
    methodKind: "unary";
    input: typeof DeletePayloadPointsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Remove all payload for specified points
   *
   * @generated from rpc qdrant.Points.ClearPayload
   */
  clearPayload: {
    methodKind: "unary";
    input: typeof ClearPayloadPointsSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Create index for field in collection
   *
   * @generated from rpc qdrant.Points.CreateFieldIndex
   */
  createFieldIndex: {
    methodKind: "unary";
    input: typeof CreateFieldIndexCollectionSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Delete field index for collection
   *
   * @generated from rpc qdrant.Points.DeleteFieldIndex
   */
  deleteFieldIndex: {
    methodKind: "unary";
    input: typeof DeleteFieldIndexCollectionSchema;
    output: typeof PointsOperationResponseSchema;
  },
  /**
   *
   * Retrieve closest points based on vector similarity and given filtering conditions
   *
   * @generated from rpc qdrant.Points.Search
   */
  search: {
    methodKind: "unary";
    input: typeof SearchPointsSchema;
    output: typeof SearchResponseSchema;
  },
  /**
   *
   * Retrieve closest points based on vector similarity and given filtering conditions
   *
   * @generated from rpc qdrant.Points.SearchBatch
   */
  searchBatch: {
    methodKind: "unary";
    input: typeof SearchBatchPointsSchema;
    output: typeof SearchBatchResponseSchema;
  },
  /**
   *
   * Retrieve closest points based on vector similarity and given filtering conditions, grouped by a given field
   *
   * @generated from rpc qdrant.Points.SearchGroups
   */
  searchGroups: {
    methodKind: "unary";
    input: typeof SearchPointGroupsSchema;
    output: typeof SearchGroupsResponseSchema;
  },
  /**
   *
   * Iterate over all or filtered points
   *
   * @generated from rpc qdrant.Points.Scroll
   */
  scroll: {
    methodKind: "unary";
    input: typeof ScrollPointsSchema;
    output: typeof ScrollResponseSchema;
  },
  /**
   *
   * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
   *
   * @generated from rpc qdrant.Points.Recommend
   */
  recommend: {
    methodKind: "unary";
    input: typeof RecommendPointsSchema;
    output: typeof RecommendResponseSchema;
  },
  /**
   *
   * Look for the points which are closer to stored positive examples and at the same time further to negative examples.
   *
   * @generated from rpc qdrant.Points.RecommendBatch
   */
  recommendBatch: {
    methodKind: "unary";
    input: typeof RecommendBatchPointsSchema;
    output: typeof RecommendBatchResponseSchema;
  },
  /**
   *
   * Look for the points which are closer to stored positive examples and at the same time further to negative examples, grouped by a given field
   *
   * @generated from rpc qdrant.Points.RecommendGroups
   */
  recommendGroups: {
    methodKind: "unary";
    input: typeof RecommendPointGroupsSchema;
    output: typeof RecommendGroupsResponseSchema;
  },
  /**
   *
   * Use context and a target to find the most similar points to the target, constrained by the context.
   *
   * When using only the context (without a target), a special search - called context search - is performed where
   * pairs of points are used to generate a loss that guides the search towards the zone where
   * most positive examples overlap. This means that the score minimizes the scenario of
   * finding a point closer to a negative than to a positive part of a pair.
   *
   * Since the score of a context relates to loss, the maximum score a point can get is 0.0,
   * and it becomes normal that many points can have a score of 0.0.
   *
   * When using target (with or without context), the score behaves a little different: The 
   * integer part of the score represents the rank with respect to the context, while the
   * decimal part of the score relates to the distance to the target. The context part of the score for 
   * each pair is calculated +1 if the point is closer to a positive than to a negative part of a pair, 
   * and -1 otherwise.
   *
   * @generated from rpc qdrant.Points.Discover
   */
  discover: {
    methodKind: "unary";
    input: typeof DiscoverPointsSchema;
    output: typeof DiscoverResponseSchema;
  },
  /**
   *
   * Batch request points based on { positive, negative } pairs of examples, and/or a target
   *
   * @generated from rpc qdrant.Points.DiscoverBatch
   */
  discoverBatch: {
    methodKind: "unary";
    input: typeof DiscoverBatchPointsSchema;
    output: typeof DiscoverBatchResponseSchema;
  },
  /**
   *
   * Count points in collection with given filtering conditions
   *
   * @generated from rpc qdrant.Points.Count
   */
  count: {
    methodKind: "unary";
    input: typeof CountPointsSchema;
    output: typeof CountResponseSchema;
  },
  /**
   *
   * Perform multiple update operations in one request
   *
   * @generated from rpc qdrant.Points.UpdateBatch
   */
  updateBatch: {
    methodKind: "unary";
    input: typeof UpdateBatchPointsSchema;
    output: typeof UpdateBatchResponseSchema;
  },
  /**
   *
   * Universally query points. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.
   *
   * @generated from rpc qdrant.Points.Query
   */
  query: {
    methodKind: "unary";
    input: typeof QueryPointsSchema;
    output: typeof QueryResponseSchema;
  },
  /**
   *
   * Universally query points in a batch fashion. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.
   *
   * @generated from rpc qdrant.Points.QueryBatch
   */
  queryBatch: {
    methodKind: "unary";
    input: typeof QueryBatchPointsSchema;
    output: typeof QueryBatchResponseSchema;
  },
  /**
   *
   * Universally query points in a group fashion. This endpoint covers all capabilities of search, recommend, discover, filters. But also enables hybrid and multi-stage queries.
   *
   * @generated from rpc qdrant.Points.QueryGroups
   */
  queryGroups: {
    methodKind: "unary";
    input: typeof QueryPointGroupsSchema;
    output: typeof QueryGroupsResponseSchema;
  },
  /**
   *
   * Perform facet counts. For each value in the field, count the number of points that have this value and match the conditions.
   *
   * @generated from rpc qdrant.Points.Facet
   */
  facet: {
    methodKind: "unary";
    input: typeof FacetCountsSchema;
    output: typeof FacetResponseSchema;
  },
  /**
   *
   * Compute distance matrix for sampled points with a pair based output format
   *
   * @generated from rpc qdrant.Points.SearchMatrixPairs
   */
  searchMatrixPairs: {
    methodKind: "unary";
    input: typeof SearchMatrixPointsSchema;
    output: typeof SearchMatrixPairsResponseSchema;
  },
  /**
   *
   * Compute distance matrix for sampled points with an offset based output format
   *
   * @generated from rpc qdrant.Points.SearchMatrixOffsets
   */
  searchMatrixOffsets: {
    methodKind: "unary";
    input: typeof SearchMatrixPointsSchema;
    output: typeof SearchMatrixOffsetsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_points_service, 0);

